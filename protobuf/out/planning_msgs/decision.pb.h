// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: planning_msgs/decision.proto
// Protobuf C++ Version: 5.28.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fdecision_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fdecision_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common_msgs/basic_msgs/geometry.pb.h"
#include "common_msgs/basic_msgs/vehicle_signal.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_planning_5fmsgs_2fdecision_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_planning_5fmsgs_2fdecision_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_planning_5fmsgs_2fdecision_2eproto;
namespace control {
namespace planning {
class DecisionResult;
struct DecisionResultDefaultTypeInternal;
extern DecisionResultDefaultTypeInternal _DecisionResult_default_instance_;
class EmergencyStopCruiseToStop;
struct EmergencyStopCruiseToStopDefaultTypeInternal;
extern EmergencyStopCruiseToStopDefaultTypeInternal _EmergencyStopCruiseToStop_default_instance_;
class EmergencyStopHardBrake;
struct EmergencyStopHardBrakeDefaultTypeInternal;
extern EmergencyStopHardBrakeDefaultTypeInternal _EmergencyStopHardBrake_default_instance_;
class MainChangeLane;
struct MainChangeLaneDefaultTypeInternal;
extern MainChangeLaneDefaultTypeInternal _MainChangeLane_default_instance_;
class MainCruise;
struct MainCruiseDefaultTypeInternal;
extern MainCruiseDefaultTypeInternal _MainCruise_default_instance_;
class MainDecision;
struct MainDecisionDefaultTypeInternal;
extern MainDecisionDefaultTypeInternal _MainDecision_default_instance_;
class MainEmergencyStop;
struct MainEmergencyStopDefaultTypeInternal;
extern MainEmergencyStopDefaultTypeInternal _MainEmergencyStop_default_instance_;
class MainMissionComplete;
struct MainMissionCompleteDefaultTypeInternal;
extern MainMissionCompleteDefaultTypeInternal _MainMissionComplete_default_instance_;
class MainNotReady;
struct MainNotReadyDefaultTypeInternal;
extern MainNotReadyDefaultTypeInternal _MainNotReady_default_instance_;
class MainParking;
struct MainParkingDefaultTypeInternal;
extern MainParkingDefaultTypeInternal _MainParking_default_instance_;
class MainStop;
struct MainStopDefaultTypeInternal;
extern MainStopDefaultTypeInternal _MainStop_default_instance_;
class ObjectAvoid;
struct ObjectAvoidDefaultTypeInternal;
extern ObjectAvoidDefaultTypeInternal _ObjectAvoid_default_instance_;
class ObjectDecision;
struct ObjectDecisionDefaultTypeInternal;
extern ObjectDecisionDefaultTypeInternal _ObjectDecision_default_instance_;
class ObjectDecisionType;
struct ObjectDecisionTypeDefaultTypeInternal;
extern ObjectDecisionTypeDefaultTypeInternal _ObjectDecisionType_default_instance_;
class ObjectDecisions;
struct ObjectDecisionsDefaultTypeInternal;
extern ObjectDecisionsDefaultTypeInternal _ObjectDecisions_default_instance_;
class ObjectDynamic;
struct ObjectDynamicDefaultTypeInternal;
extern ObjectDynamicDefaultTypeInternal _ObjectDynamic_default_instance_;
class ObjectFollow;
struct ObjectFollowDefaultTypeInternal;
extern ObjectFollowDefaultTypeInternal _ObjectFollow_default_instance_;
class ObjectIgnore;
struct ObjectIgnoreDefaultTypeInternal;
extern ObjectIgnoreDefaultTypeInternal _ObjectIgnore_default_instance_;
class ObjectMotionType;
struct ObjectMotionTypeDefaultTypeInternal;
extern ObjectMotionTypeDefaultTypeInternal _ObjectMotionType_default_instance_;
class ObjectNudge;
struct ObjectNudgeDefaultTypeInternal;
extern ObjectNudgeDefaultTypeInternal _ObjectNudge_default_instance_;
class ObjectOvertake;
struct ObjectOvertakeDefaultTypeInternal;
extern ObjectOvertakeDefaultTypeInternal _ObjectOvertake_default_instance_;
class ObjectSidePass;
struct ObjectSidePassDefaultTypeInternal;
extern ObjectSidePassDefaultTypeInternal _ObjectSidePass_default_instance_;
class ObjectStatic;
struct ObjectStaticDefaultTypeInternal;
extern ObjectStaticDefaultTypeInternal _ObjectStatic_default_instance_;
class ObjectStatus;
struct ObjectStatusDefaultTypeInternal;
extern ObjectStatusDefaultTypeInternal _ObjectStatus_default_instance_;
class ObjectStop;
struct ObjectStopDefaultTypeInternal;
extern ObjectStopDefaultTypeInternal _ObjectStop_default_instance_;
class ObjectYield;
struct ObjectYieldDefaultTypeInternal;
extern ObjectYieldDefaultTypeInternal _ObjectYield_default_instance_;
class TargetLane;
struct TargetLaneDefaultTypeInternal;
extern TargetLaneDefaultTypeInternal _TargetLane_default_instance_;
}  // namespace planning
}  // namespace control
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace control {
namespace planning {
enum ObjectNudge_Type : int {
  ObjectNudge_Type_LEFT_NUDGE = 1,
  ObjectNudge_Type_RIGHT_NUDGE = 2,
  ObjectNudge_Type_DYNAMIC_LEFT_NUDGE = 3,
  ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE = 4,
};

bool ObjectNudge_Type_IsValid(int value);
extern const uint32_t ObjectNudge_Type_internal_data_[];
constexpr ObjectNudge_Type ObjectNudge_Type_Type_MIN = static_cast<ObjectNudge_Type>(1);
constexpr ObjectNudge_Type ObjectNudge_Type_Type_MAX = static_cast<ObjectNudge_Type>(4);
constexpr int ObjectNudge_Type_Type_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ObjectNudge_Type_descriptor();
template <typename T>
const std::string& ObjectNudge_Type_Name(T value) {
  static_assert(std::is_same<T, ObjectNudge_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return ObjectNudge_Type_Name(static_cast<ObjectNudge_Type>(value));
}
template <>
inline const std::string& ObjectNudge_Type_Name(ObjectNudge_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjectNudge_Type_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool ObjectNudge_Type_Parse(absl::string_view name, ObjectNudge_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectNudge_Type>(
      ObjectNudge_Type_descriptor(), name, value);
}
enum ObjectSidePass_Type : int {
  ObjectSidePass_Type_LEFT = 1,
  ObjectSidePass_Type_RIGHT = 2,
};

bool ObjectSidePass_Type_IsValid(int value);
extern const uint32_t ObjectSidePass_Type_internal_data_[];
constexpr ObjectSidePass_Type ObjectSidePass_Type_Type_MIN = static_cast<ObjectSidePass_Type>(1);
constexpr ObjectSidePass_Type ObjectSidePass_Type_Type_MAX = static_cast<ObjectSidePass_Type>(2);
constexpr int ObjectSidePass_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ObjectSidePass_Type_descriptor();
template <typename T>
const std::string& ObjectSidePass_Type_Name(T value) {
  static_assert(std::is_same<T, ObjectSidePass_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return ObjectSidePass_Type_Name(static_cast<ObjectSidePass_Type>(value));
}
template <>
inline const std::string& ObjectSidePass_Type_Name(ObjectSidePass_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjectSidePass_Type_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ObjectSidePass_Type_Parse(absl::string_view name, ObjectSidePass_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectSidePass_Type>(
      ObjectSidePass_Type_descriptor(), name, value);
}
enum MainEmergencyStop_ReasonCode : int {
  MainEmergencyStop_ReasonCode_ESTOP_REASON_INTERNAL_ERR = 1,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_COLLISION = 2,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_FIND_PATH = 3,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_MAKE_DECISION = 4,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_SENSOR_ERROR = 5,
};

bool MainEmergencyStop_ReasonCode_IsValid(int value);
extern const uint32_t MainEmergencyStop_ReasonCode_internal_data_[];
constexpr MainEmergencyStop_ReasonCode MainEmergencyStop_ReasonCode_ReasonCode_MIN = static_cast<MainEmergencyStop_ReasonCode>(1);
constexpr MainEmergencyStop_ReasonCode MainEmergencyStop_ReasonCode_ReasonCode_MAX = static_cast<MainEmergencyStop_ReasonCode>(5);
constexpr int MainEmergencyStop_ReasonCode_ReasonCode_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
MainEmergencyStop_ReasonCode_descriptor();
template <typename T>
const std::string& MainEmergencyStop_ReasonCode_Name(T value) {
  static_assert(std::is_same<T, MainEmergencyStop_ReasonCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReasonCode_Name().");
  return MainEmergencyStop_ReasonCode_Name(static_cast<MainEmergencyStop_ReasonCode>(value));
}
template <>
inline const std::string& MainEmergencyStop_ReasonCode_Name(MainEmergencyStop_ReasonCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MainEmergencyStop_ReasonCode_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool MainEmergencyStop_ReasonCode_Parse(absl::string_view name, MainEmergencyStop_ReasonCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MainEmergencyStop_ReasonCode>(
      MainEmergencyStop_ReasonCode_descriptor(), name, value);
}
enum MainChangeLane_Type : int {
  MainChangeLane_Type_LEFT = 1,
  MainChangeLane_Type_RIGHT = 2,
};

bool MainChangeLane_Type_IsValid(int value);
extern const uint32_t MainChangeLane_Type_internal_data_[];
constexpr MainChangeLane_Type MainChangeLane_Type_Type_MIN = static_cast<MainChangeLane_Type>(1);
constexpr MainChangeLane_Type MainChangeLane_Type_Type_MAX = static_cast<MainChangeLane_Type>(2);
constexpr int MainChangeLane_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MainChangeLane_Type_descriptor();
template <typename T>
const std::string& MainChangeLane_Type_Name(T value) {
  static_assert(std::is_same<T, MainChangeLane_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return MainChangeLane_Type_Name(static_cast<MainChangeLane_Type>(value));
}
template <>
inline const std::string& MainChangeLane_Type_Name(MainChangeLane_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MainChangeLane_Type_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool MainChangeLane_Type_Parse(absl::string_view name, MainChangeLane_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MainChangeLane_Type>(
      MainChangeLane_Type_descriptor(), name, value);
}
enum MainParking_ParkingStatus : int {
  MainParking_ParkingStatus_IN_PARKING = 1,
};

bool MainParking_ParkingStatus_IsValid(int value);
extern const uint32_t MainParking_ParkingStatus_internal_data_[];
constexpr MainParking_ParkingStatus MainParking_ParkingStatus_ParkingStatus_MIN = static_cast<MainParking_ParkingStatus>(1);
constexpr MainParking_ParkingStatus MainParking_ParkingStatus_ParkingStatus_MAX = static_cast<MainParking_ParkingStatus>(1);
constexpr int MainParking_ParkingStatus_ParkingStatus_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
MainParking_ParkingStatus_descriptor();
template <typename T>
const std::string& MainParking_ParkingStatus_Name(T value) {
  static_assert(std::is_same<T, MainParking_ParkingStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ParkingStatus_Name().");
  return MainParking_ParkingStatus_Name(static_cast<MainParking_ParkingStatus>(value));
}
template <>
inline const std::string& MainParking_ParkingStatus_Name(MainParking_ParkingStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MainParking_ParkingStatus_descriptor,
                                                 1, 1>(
      static_cast<int>(value));
}
inline bool MainParking_ParkingStatus_Parse(absl::string_view name, MainParking_ParkingStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MainParking_ParkingStatus>(
      MainParking_ParkingStatus_descriptor(), name, value);
}
enum StopReasonCode : int {
  STOP_REASON_HEAD_VEHICLE = 1,
  STOP_REASON_DESTINATION = 2,
  STOP_REASON_PEDESTRIAN = 3,
  STOP_REASON_OBSTACLE = 4,
  STOP_REASON_PREPARKING = 5,
  STOP_REASON_SIGNAL = 100,
  STOP_REASON_STOP_SIGN = 101,
  STOP_REASON_YIELD_SIGN = 102,
  STOP_REASON_CLEAR_ZONE = 103,
  STOP_REASON_CROSSWALK = 104,
  STOP_REASON_CREEPER = 105,
  STOP_REASON_REFERENCE_END = 106,
  STOP_REASON_YELLOW_SIGNAL = 107,
  STOP_REASON_PULL_OVER = 108,
  STOP_REASON_SIDEPASS_SAFETY = 109,
  STOP_REASON_PRE_OPEN_SPACE_STOP = 200,
  STOP_REASON_LANE_CHANGE_URGENCY = 201,
  STOP_REASON_EMERGENCY = 202,
};

bool StopReasonCode_IsValid(int value);
extern const uint32_t StopReasonCode_internal_data_[];
constexpr StopReasonCode StopReasonCode_MIN = static_cast<StopReasonCode>(1);
constexpr StopReasonCode StopReasonCode_MAX = static_cast<StopReasonCode>(202);
constexpr int StopReasonCode_ARRAYSIZE = 202 + 1;
const ::google::protobuf::EnumDescriptor*
StopReasonCode_descriptor();
template <typename T>
const std::string& StopReasonCode_Name(T value) {
  static_assert(std::is_same<T, StopReasonCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StopReasonCode_Name().");
  return ::google::protobuf::internal::NameOfEnum(StopReasonCode_descriptor(), value);
}
inline bool StopReasonCode_Parse(absl::string_view name, StopReasonCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopReasonCode>(
      StopReasonCode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TargetLane final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.TargetLane) */ {
 public:
  inline TargetLane() : TargetLane(nullptr) {}
  ~TargetLane() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TargetLane(
      ::google::protobuf::internal::ConstantInitialized);

  inline TargetLane(const TargetLane& from) : TargetLane(nullptr, from) {}
  inline TargetLane(TargetLane&& from) noexcept
      : TargetLane(nullptr, std::move(from)) {}
  inline TargetLane& operator=(const TargetLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetLane& operator=(TargetLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetLane* internal_default_instance() {
    return reinterpret_cast<const TargetLane*>(
        &_TargetLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(TargetLane& a, TargetLane& b) { a.Swap(&b); }
  inline void Swap(TargetLane* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetLane* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetLane* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TargetLane>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TargetLane& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TargetLane& from) { TargetLane::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TargetLane* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.TargetLane"; }

 protected:
  explicit TargetLane(::google::protobuf::Arena* arena);
  TargetLane(::google::protobuf::Arena* arena, const TargetLane& from);
  TargetLane(::google::protobuf::Arena* arena, TargetLane&& from) noexcept
      : TargetLane(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kStartSFieldNumber = 2,
    kEndSFieldNumber = 3,
    kSpeedLimitFieldNumber = 4,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional double start_s = 2;
  bool has_start_s() const;
  void clear_start_s() ;
  double start_s() const;
  void set_start_s(double value);

  private:
  double _internal_start_s() const;
  void _internal_set_start_s(double value);

  public:
  // optional double end_s = 3;
  bool has_end_s() const;
  void clear_end_s() ;
  double end_s() const;
  void set_end_s(double value);

  private:
  double _internal_end_s() const;
  void _internal_set_end_s(double value);

  public:
  // optional double speed_limit = 4;
  bool has_speed_limit() const;
  void clear_speed_limit() ;
  double speed_limit() const;
  void set_speed_limit(double value);

  private:
  double _internal_speed_limit() const;
  void _internal_set_speed_limit(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.TargetLane)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TargetLane_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TargetLane& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    double start_s_;
    double end_s_;
    double speed_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatic final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.ObjectStatic) */ {
 public:
  inline ObjectStatic() : ObjectStatic(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectStatic(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectStatic(const ObjectStatic& from) : ObjectStatic(nullptr, from) {}
  inline ObjectStatic(ObjectStatic&& from) noexcept
      : ObjectStatic(nullptr, std::move(from)) {}
  inline ObjectStatic& operator=(const ObjectStatic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStatic& operator=(ObjectStatic&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectStatic& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectStatic* internal_default_instance() {
    return reinterpret_cast<const ObjectStatic*>(
        &_ObjectStatic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ObjectStatic& a, ObjectStatic& b) { a.Swap(&b); }
  inline void Swap(ObjectStatic* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStatic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectStatic* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ObjectStatic>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectStatic& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectStatic& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectStatic"; }

 protected:
  explicit ObjectStatic(::google::protobuf::Arena* arena);
  ObjectStatic(::google::protobuf::Arena* arena, const ObjectStatic& from);
  ObjectStatic(::google::protobuf::Arena* arena, ObjectStatic&& from) noexcept
      : ObjectStatic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.ObjectStatic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectStatic_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectStatic& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectSidePass final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectSidePass) */ {
 public:
  inline ObjectSidePass() : ObjectSidePass(nullptr) {}
  ~ObjectSidePass() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectSidePass(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectSidePass(const ObjectSidePass& from) : ObjectSidePass(nullptr, from) {}
  inline ObjectSidePass(ObjectSidePass&& from) noexcept
      : ObjectSidePass(nullptr, std::move(from)) {}
  inline ObjectSidePass& operator=(const ObjectSidePass& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectSidePass& operator=(ObjectSidePass&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectSidePass& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectSidePass* internal_default_instance() {
    return reinterpret_cast<const ObjectSidePass*>(
        &_ObjectSidePass_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ObjectSidePass& a, ObjectSidePass& b) { a.Swap(&b); }
  inline void Swap(ObjectSidePass* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectSidePass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectSidePass* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectSidePass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectSidePass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectSidePass& from) { ObjectSidePass::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectSidePass* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectSidePass"; }

 protected:
  explicit ObjectSidePass(::google::protobuf::Arena* arena);
  ObjectSidePass(::google::protobuf::Arena* arena, const ObjectSidePass& from);
  ObjectSidePass(::google::protobuf::Arena* arena, ObjectSidePass&& from) noexcept
      : ObjectSidePass(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = ObjectSidePass_Type;
  static constexpr Type LEFT = ObjectSidePass_Type_LEFT;
  static constexpr Type RIGHT = ObjectSidePass_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return ObjectSidePass_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = ObjectSidePass_Type_Type_MIN;
  static constexpr Type Type_MAX = ObjectSidePass_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = ObjectSidePass_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return ObjectSidePass_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return ObjectSidePass_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return ObjectSidePass_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .control.planning.ObjectSidePass.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::control::planning::ObjectSidePass_Type type() const;
  void set_type(::control::planning::ObjectSidePass_Type value);

  private:
  ::control::planning::ObjectSidePass_Type _internal_type() const;
  void _internal_set_type(::control::planning::ObjectSidePass_Type value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectSidePass)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectSidePass_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectSidePass& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectNudge final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectNudge) */ {
 public:
  inline ObjectNudge() : ObjectNudge(nullptr) {}
  ~ObjectNudge() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectNudge(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectNudge(const ObjectNudge& from) : ObjectNudge(nullptr, from) {}
  inline ObjectNudge(ObjectNudge&& from) noexcept
      : ObjectNudge(nullptr, std::move(from)) {}
  inline ObjectNudge& operator=(const ObjectNudge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectNudge& operator=(ObjectNudge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectNudge& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectNudge* internal_default_instance() {
    return reinterpret_cast<const ObjectNudge*>(
        &_ObjectNudge_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ObjectNudge& a, ObjectNudge& b) { a.Swap(&b); }
  inline void Swap(ObjectNudge* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectNudge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectNudge* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectNudge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectNudge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectNudge& from) { ObjectNudge::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectNudge* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectNudge"; }

 protected:
  explicit ObjectNudge(::google::protobuf::Arena* arena);
  ObjectNudge(::google::protobuf::Arena* arena, const ObjectNudge& from);
  ObjectNudge(::google::protobuf::Arena* arena, ObjectNudge&& from) noexcept
      : ObjectNudge(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = ObjectNudge_Type;
  static constexpr Type LEFT_NUDGE = ObjectNudge_Type_LEFT_NUDGE;
  static constexpr Type RIGHT_NUDGE = ObjectNudge_Type_RIGHT_NUDGE;
  static constexpr Type DYNAMIC_LEFT_NUDGE = ObjectNudge_Type_DYNAMIC_LEFT_NUDGE;
  static constexpr Type DYNAMIC_RIGHT_NUDGE = ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
  static inline bool Type_IsValid(int value) {
    return ObjectNudge_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = ObjectNudge_Type_Type_MIN;
  static constexpr Type Type_MAX = ObjectNudge_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = ObjectNudge_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return ObjectNudge_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return ObjectNudge_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return ObjectNudge_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDistanceLFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional double distance_l = 2;
  bool has_distance_l() const;
  void clear_distance_l() ;
  double distance_l() const;
  void set_distance_l(double value);

  private:
  double _internal_distance_l() const;
  void _internal_set_distance_l(double value);

  public:
  // optional .control.planning.ObjectNudge.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::control::planning::ObjectNudge_Type type() const;
  void set_type(::control::planning::ObjectNudge_Type value);

  private:
  ::control::planning::ObjectNudge_Type _internal_type() const;
  void _internal_set_type(::control::planning::ObjectNudge_Type value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectNudge)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectNudge_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectNudge& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double distance_l_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectIgnore final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.ObjectIgnore) */ {
 public:
  inline ObjectIgnore() : ObjectIgnore(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectIgnore(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectIgnore(const ObjectIgnore& from) : ObjectIgnore(nullptr, from) {}
  inline ObjectIgnore(ObjectIgnore&& from) noexcept
      : ObjectIgnore(nullptr, std::move(from)) {}
  inline ObjectIgnore& operator=(const ObjectIgnore& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectIgnore& operator=(ObjectIgnore&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectIgnore& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectIgnore* internal_default_instance() {
    return reinterpret_cast<const ObjectIgnore*>(
        &_ObjectIgnore_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ObjectIgnore& a, ObjectIgnore& b) { a.Swap(&b); }
  inline void Swap(ObjectIgnore* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectIgnore* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectIgnore* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ObjectIgnore>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectIgnore& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectIgnore& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectIgnore"; }

 protected:
  explicit ObjectIgnore(::google::protobuf::Arena* arena);
  ObjectIgnore(::google::protobuf::Arena* arena, const ObjectIgnore& from);
  ObjectIgnore(::google::protobuf::Arena* arena, ObjectIgnore&& from) noexcept
      : ObjectIgnore(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.ObjectIgnore)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectIgnore_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectIgnore& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDynamic final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.ObjectDynamic) */ {
 public:
  inline ObjectDynamic() : ObjectDynamic(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectDynamic(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectDynamic(const ObjectDynamic& from) : ObjectDynamic(nullptr, from) {}
  inline ObjectDynamic(ObjectDynamic&& from) noexcept
      : ObjectDynamic(nullptr, std::move(from)) {}
  inline ObjectDynamic& operator=(const ObjectDynamic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDynamic& operator=(ObjectDynamic&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDynamic& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectDynamic* internal_default_instance() {
    return reinterpret_cast<const ObjectDynamic*>(
        &_ObjectDynamic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ObjectDynamic& a, ObjectDynamic& b) { a.Swap(&b); }
  inline void Swap(ObjectDynamic* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDynamic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDynamic* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ObjectDynamic>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectDynamic& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectDynamic& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectDynamic"; }

 protected:
  explicit ObjectDynamic(::google::protobuf::Arena* arena);
  ObjectDynamic(::google::protobuf::Arena* arena, const ObjectDynamic& from);
  ObjectDynamic(::google::protobuf::Arena* arena, ObjectDynamic&& from) noexcept
      : ObjectDynamic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.ObjectDynamic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectDynamic_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectDynamic& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectAvoid final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.ObjectAvoid) */ {
 public:
  inline ObjectAvoid() : ObjectAvoid(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectAvoid(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectAvoid(const ObjectAvoid& from) : ObjectAvoid(nullptr, from) {}
  inline ObjectAvoid(ObjectAvoid&& from) noexcept
      : ObjectAvoid(nullptr, std::move(from)) {}
  inline ObjectAvoid& operator=(const ObjectAvoid& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectAvoid& operator=(ObjectAvoid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectAvoid& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectAvoid* internal_default_instance() {
    return reinterpret_cast<const ObjectAvoid*>(
        &_ObjectAvoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ObjectAvoid& a, ObjectAvoid& b) { a.Swap(&b); }
  inline void Swap(ObjectAvoid* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectAvoid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectAvoid* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ObjectAvoid>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectAvoid& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectAvoid& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectAvoid"; }

 protected:
  explicit ObjectAvoid(::google::protobuf::Arena* arena);
  ObjectAvoid(::google::protobuf::Arena* arena, const ObjectAvoid& from);
  ObjectAvoid(::google::protobuf::Arena* arena, ObjectAvoid&& from) noexcept
      : ObjectAvoid(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.ObjectAvoid)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectAvoid_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectAvoid& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainParking final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainParking) */ {
 public:
  inline MainParking() : MainParking(nullptr) {}
  ~MainParking() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainParking(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainParking(const MainParking& from) : MainParking(nullptr, from) {}
  inline MainParking(MainParking&& from) noexcept
      : MainParking(nullptr, std::move(from)) {}
  inline MainParking& operator=(const MainParking& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainParking& operator=(MainParking&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainParking& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainParking* internal_default_instance() {
    return reinterpret_cast<const MainParking*>(
        &_MainParking_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(MainParking& a, MainParking& b) { a.Swap(&b); }
  inline void Swap(MainParking* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainParking* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainParking* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainParking>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainParking& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainParking& from) { MainParking::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainParking* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainParking"; }

 protected:
  explicit MainParking(::google::protobuf::Arena* arena);
  MainParking(::google::protobuf::Arena* arena, const MainParking& from);
  MainParking(::google::protobuf::Arena* arena, MainParking&& from) noexcept
      : MainParking(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ParkingStatus = MainParking_ParkingStatus;
  static constexpr ParkingStatus IN_PARKING = MainParking_ParkingStatus_IN_PARKING;
  static inline bool ParkingStatus_IsValid(int value) {
    return MainParking_ParkingStatus_IsValid(value);
  }
  static constexpr ParkingStatus ParkingStatus_MIN = MainParking_ParkingStatus_ParkingStatus_MIN;
  static constexpr ParkingStatus ParkingStatus_MAX = MainParking_ParkingStatus_ParkingStatus_MAX;
  static constexpr int ParkingStatus_ARRAYSIZE = MainParking_ParkingStatus_ParkingStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ParkingStatus_descriptor() {
    return MainParking_ParkingStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& ParkingStatus_Name(T value) {
    return MainParking_ParkingStatus_Name(value);
  }
  static inline bool ParkingStatus_Parse(absl::string_view name, ParkingStatus* value) {
    return MainParking_ParkingStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .control.planning.MainParking.ParkingStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::control::planning::MainParking_ParkingStatus status() const;
  void set_status(::control::planning::MainParking_ParkingStatus value);

  private:
  ::control::planning::MainParking_ParkingStatus _internal_status() const;
  void _internal_set_status(::control::planning::MainParking_ParkingStatus value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.MainParking)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainParking_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainParking& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainNotReady final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainNotReady) */ {
 public:
  inline MainNotReady() : MainNotReady(nullptr) {}
  ~MainNotReady() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainNotReady(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainNotReady(const MainNotReady& from) : MainNotReady(nullptr, from) {}
  inline MainNotReady(MainNotReady&& from) noexcept
      : MainNotReady(nullptr, std::move(from)) {}
  inline MainNotReady& operator=(const MainNotReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainNotReady& operator=(MainNotReady&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainNotReady& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainNotReady* internal_default_instance() {
    return reinterpret_cast<const MainNotReady*>(
        &_MainNotReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(MainNotReady& a, MainNotReady& b) { a.Swap(&b); }
  inline void Swap(MainNotReady* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainNotReady* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainNotReady* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainNotReady>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainNotReady& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainNotReady& from) { MainNotReady::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainNotReady* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainNotReady"; }

 protected:
  explicit MainNotReady(::google::protobuf::Arena* arena);
  MainNotReady(::google::protobuf::Arena* arena, const MainNotReady& from);
  MainNotReady(::google::protobuf::Arena* arena, MainNotReady&& from) noexcept
      : MainNotReady(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 1,
  };
  // optional string reason = 1;
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // @@protoc_insertion_point(class_scope:control.planning.MainNotReady)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainNotReady_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainNotReady& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainCruise final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.MainCruise) */ {
 public:
  inline MainCruise() : MainCruise(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainCruise(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainCruise(const MainCruise& from) : MainCruise(nullptr, from) {}
  inline MainCruise(MainCruise&& from) noexcept
      : MainCruise(nullptr, std::move(from)) {}
  inline MainCruise& operator=(const MainCruise& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainCruise& operator=(MainCruise&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainCruise& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainCruise* internal_default_instance() {
    return reinterpret_cast<const MainCruise*>(
        &_MainCruise_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(MainCruise& a, MainCruise& b) { a.Swap(&b); }
  inline void Swap(MainCruise* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainCruise* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainCruise* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<MainCruise>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MainCruise& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MainCruise& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainCruise"; }

 protected:
  explicit MainCruise(::google::protobuf::Arena* arena);
  MainCruise(::google::protobuf::Arena* arena, const MainCruise& from);
  MainCruise(::google::protobuf::Arena* arena, MainCruise&& from) noexcept
      : MainCruise(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.MainCruise)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainCruise_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainCruise& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class EmergencyStopHardBrake final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.EmergencyStopHardBrake) */ {
 public:
  inline EmergencyStopHardBrake() : EmergencyStopHardBrake(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmergencyStopHardBrake(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmergencyStopHardBrake(const EmergencyStopHardBrake& from) : EmergencyStopHardBrake(nullptr, from) {}
  inline EmergencyStopHardBrake(EmergencyStopHardBrake&& from) noexcept
      : EmergencyStopHardBrake(nullptr, std::move(from)) {}
  inline EmergencyStopHardBrake& operator=(const EmergencyStopHardBrake& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyStopHardBrake& operator=(EmergencyStopHardBrake&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmergencyStopHardBrake& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmergencyStopHardBrake* internal_default_instance() {
    return reinterpret_cast<const EmergencyStopHardBrake*>(
        &_EmergencyStopHardBrake_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(EmergencyStopHardBrake& a, EmergencyStopHardBrake& b) { a.Swap(&b); }
  inline void Swap(EmergencyStopHardBrake* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyStopHardBrake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmergencyStopHardBrake* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<EmergencyStopHardBrake>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmergencyStopHardBrake& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmergencyStopHardBrake& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.EmergencyStopHardBrake"; }

 protected:
  explicit EmergencyStopHardBrake(::google::protobuf::Arena* arena);
  EmergencyStopHardBrake(::google::protobuf::Arena* arena, const EmergencyStopHardBrake& from);
  EmergencyStopHardBrake(::google::protobuf::Arena* arena, EmergencyStopHardBrake&& from) noexcept
      : EmergencyStopHardBrake(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.EmergencyStopHardBrake)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EmergencyStopHardBrake_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmergencyStopHardBrake& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class EmergencyStopCruiseToStop final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control.planning.EmergencyStopCruiseToStop) */ {
 public:
  inline EmergencyStopCruiseToStop() : EmergencyStopCruiseToStop(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmergencyStopCruiseToStop(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmergencyStopCruiseToStop(const EmergencyStopCruiseToStop& from) : EmergencyStopCruiseToStop(nullptr, from) {}
  inline EmergencyStopCruiseToStop(EmergencyStopCruiseToStop&& from) noexcept
      : EmergencyStopCruiseToStop(nullptr, std::move(from)) {}
  inline EmergencyStopCruiseToStop& operator=(const EmergencyStopCruiseToStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyStopCruiseToStop& operator=(EmergencyStopCruiseToStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmergencyStopCruiseToStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmergencyStopCruiseToStop* internal_default_instance() {
    return reinterpret_cast<const EmergencyStopCruiseToStop*>(
        &_EmergencyStopCruiseToStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(EmergencyStopCruiseToStop& a, EmergencyStopCruiseToStop& b) { a.Swap(&b); }
  inline void Swap(EmergencyStopCruiseToStop* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyStopCruiseToStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmergencyStopCruiseToStop* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<EmergencyStopCruiseToStop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmergencyStopCruiseToStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmergencyStopCruiseToStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.EmergencyStopCruiseToStop"; }

 protected:
  explicit EmergencyStopCruiseToStop(::google::protobuf::Arena* arena);
  EmergencyStopCruiseToStop(::google::protobuf::Arena* arena, const EmergencyStopCruiseToStop& from);
  EmergencyStopCruiseToStop(::google::protobuf::Arena* arena, EmergencyStopCruiseToStop&& from) noexcept
      : EmergencyStopCruiseToStop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control.planning.EmergencyStopCruiseToStop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EmergencyStopCruiseToStop_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmergencyStopCruiseToStop& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectYield final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectYield) */ {
 public:
  inline ObjectYield() : ObjectYield(nullptr) {}
  ~ObjectYield() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectYield(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectYield(const ObjectYield& from) : ObjectYield(nullptr, from) {}
  inline ObjectYield(ObjectYield&& from) noexcept
      : ObjectYield(nullptr, std::move(from)) {}
  inline ObjectYield& operator=(const ObjectYield& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectYield& operator=(ObjectYield&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectYield& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectYield* internal_default_instance() {
    return reinterpret_cast<const ObjectYield*>(
        &_ObjectYield_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ObjectYield& a, ObjectYield& b) { a.Swap(&b); }
  inline void Swap(ObjectYield* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectYield* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectYield* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectYield>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectYield& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectYield& from) { ObjectYield::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectYield* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectYield"; }

 protected:
  explicit ObjectYield(::google::protobuf::Arena* arena);
  ObjectYield(::google::protobuf::Arena* arena, const ObjectYield& from);
  ObjectYield(::google::protobuf::Arena* arena, ObjectYield&& from) noexcept
      : ObjectYield(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
    kTimeBufferFieldNumber = 4,
  };
  // optional .control.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  void clear_fence_point() ;
  const ::control::common::PointENU& fence_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_fence_point();
  ::control::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_fence_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_fence_point();

  private:
  const ::control::common::PointENU& _internal_fence_point() const;
  ::control::common::PointENU* _internal_mutable_fence_point();

  public:
  // optional double distance_s = 1;
  bool has_distance_s() const;
  void clear_distance_s() ;
  double distance_s() const;
  void set_distance_s(double value);

  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);

  public:
  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  void clear_fence_heading() ;
  double fence_heading() const;
  void set_fence_heading(double value);

  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);

  public:
  // optional double time_buffer = 4;
  bool has_time_buffer() const;
  void clear_time_buffer() ;
  double time_buffer() const;
  void set_time_buffer(double value);

  private:
  double _internal_time_buffer() const;
  void _internal_set_time_buffer(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectYield)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectYield_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectYield& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::common::PointENU* fence_point_;
    double distance_s_;
    double fence_heading_;
    double time_buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectStop) */ {
 public:
  inline ObjectStop() : ObjectStop(nullptr) {}
  ~ObjectStop() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectStop(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectStop(const ObjectStop& from) : ObjectStop(nullptr, from) {}
  inline ObjectStop(ObjectStop&& from) noexcept
      : ObjectStop(nullptr, std::move(from)) {}
  inline ObjectStop& operator=(const ObjectStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStop& operator=(ObjectStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectStop* internal_default_instance() {
    return reinterpret_cast<const ObjectStop*>(
        &_ObjectStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ObjectStop& a, ObjectStop& b) { a.Swap(&b); }
  inline void Swap(ObjectStop* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectStop* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectStop& from) { ObjectStop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectStop* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectStop"; }

 protected:
  explicit ObjectStop(::google::protobuf::Arena* arena);
  ObjectStop(::google::protobuf::Arena* arena, const ObjectStop& from);
  ObjectStop(::google::protobuf::Arena* arena, ObjectStop&& from) noexcept
      : ObjectStop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWaitForObstacleFieldNumber = 5,
    kStopPointFieldNumber = 3,
    kDistanceSFieldNumber = 2,
    kStopHeadingFieldNumber = 4,
    kReasonCodeFieldNumber = 1,
  };
  // repeated string wait_for_obstacle = 5;
  int wait_for_obstacle_size() const;
  private:
  int _internal_wait_for_obstacle_size() const;

  public:
  void clear_wait_for_obstacle() ;
  const std::string& wait_for_obstacle(int index) const;
  std::string* mutable_wait_for_obstacle(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wait_for_obstacle(int index, Arg_&& value, Args_... args);
  std::string* add_wait_for_obstacle();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_wait_for_obstacle(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& wait_for_obstacle() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_wait_for_obstacle();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_wait_for_obstacle() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_wait_for_obstacle();

  public:
  // optional .control.common.PointENU stop_point = 3;
  bool has_stop_point() const;
  void clear_stop_point() ;
  const ::control::common::PointENU& stop_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_stop_point();
  ::control::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_stop_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_stop_point();

  private:
  const ::control::common::PointENU& _internal_stop_point() const;
  ::control::common::PointENU* _internal_mutable_stop_point();

  public:
  // optional double distance_s = 2;
  bool has_distance_s() const;
  void clear_distance_s() ;
  double distance_s() const;
  void set_distance_s(double value);

  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);

  public:
  // optional double stop_heading = 4;
  bool has_stop_heading() const;
  void clear_stop_heading() ;
  double stop_heading() const;
  void set_stop_heading(double value);

  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);

  public:
  // optional .control.planning.StopReasonCode reason_code = 1;
  bool has_reason_code() const;
  void clear_reason_code() ;
  ::control::planning::StopReasonCode reason_code() const;
  void set_reason_code(::control::planning::StopReasonCode value);

  private:
  ::control::planning::StopReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::control::planning::StopReasonCode value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectStop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectStop_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectStop& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> wait_for_obstacle_;
    ::control::common::PointENU* stop_point_;
    double distance_s_;
    double stop_heading_;
    int reason_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectOvertake final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectOvertake) */ {
 public:
  inline ObjectOvertake() : ObjectOvertake(nullptr) {}
  ~ObjectOvertake() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectOvertake(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectOvertake(const ObjectOvertake& from) : ObjectOvertake(nullptr, from) {}
  inline ObjectOvertake(ObjectOvertake&& from) noexcept
      : ObjectOvertake(nullptr, std::move(from)) {}
  inline ObjectOvertake& operator=(const ObjectOvertake& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectOvertake& operator=(ObjectOvertake&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectOvertake& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectOvertake* internal_default_instance() {
    return reinterpret_cast<const ObjectOvertake*>(
        &_ObjectOvertake_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ObjectOvertake& a, ObjectOvertake& b) { a.Swap(&b); }
  inline void Swap(ObjectOvertake* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectOvertake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectOvertake* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectOvertake>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectOvertake& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectOvertake& from) { ObjectOvertake::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectOvertake* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectOvertake"; }

 protected:
  explicit ObjectOvertake(::google::protobuf::Arena* arena);
  ObjectOvertake(::google::protobuf::Arena* arena, const ObjectOvertake& from);
  ObjectOvertake(::google::protobuf::Arena* arena, ObjectOvertake&& from) noexcept
      : ObjectOvertake(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
    kTimeBufferFieldNumber = 4,
  };
  // optional .control.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  void clear_fence_point() ;
  const ::control::common::PointENU& fence_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_fence_point();
  ::control::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_fence_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_fence_point();

  private:
  const ::control::common::PointENU& _internal_fence_point() const;
  ::control::common::PointENU* _internal_mutable_fence_point();

  public:
  // optional double distance_s = 1;
  bool has_distance_s() const;
  void clear_distance_s() ;
  double distance_s() const;
  void set_distance_s(double value);

  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);

  public:
  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  void clear_fence_heading() ;
  double fence_heading() const;
  void set_fence_heading(double value);

  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);

  public:
  // optional double time_buffer = 4;
  bool has_time_buffer() const;
  void clear_time_buffer() ;
  double time_buffer() const;
  void set_time_buffer(double value);

  private:
  double _internal_time_buffer() const;
  void _internal_set_time_buffer(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectOvertake)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectOvertake_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectOvertake& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::common::PointENU* fence_point_;
    double distance_s_;
    double fence_heading_;
    double time_buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectMotionType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectMotionType) */ {
 public:
  inline ObjectMotionType() : ObjectMotionType(nullptr) {}
  ~ObjectMotionType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectMotionType(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectMotionType(const ObjectMotionType& from) : ObjectMotionType(nullptr, from) {}
  inline ObjectMotionType(ObjectMotionType&& from) noexcept
      : ObjectMotionType(nullptr, std::move(from)) {}
  inline ObjectMotionType& operator=(const ObjectMotionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectMotionType& operator=(ObjectMotionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectMotionType& default_instance() {
    return *internal_default_instance();
  }
  enum MotionTagCase {
    kStatic = 1,
    kDynamic = 2,
    MOTION_TAG_NOT_SET = 0,
  };
  static inline const ObjectMotionType* internal_default_instance() {
    return reinterpret_cast<const ObjectMotionType*>(
        &_ObjectMotionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ObjectMotionType& a, ObjectMotionType& b) { a.Swap(&b); }
  inline void Swap(ObjectMotionType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectMotionType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectMotionType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectMotionType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectMotionType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectMotionType& from) { ObjectMotionType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectMotionType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectMotionType"; }

 protected:
  explicit ObjectMotionType(::google::protobuf::Arena* arena);
  ObjectMotionType(::google::protobuf::Arena* arena, const ObjectMotionType& from);
  ObjectMotionType(::google::protobuf::Arena* arena, ObjectMotionType&& from) noexcept
      : ObjectMotionType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStaticFieldNumber = 1,
    kDynamicFieldNumber = 2,
  };
  // .control.planning.ObjectStatic static = 1;
  bool has_static_() const;
  private:
  bool _internal_has_static_() const;

  public:
  void clear_static_() ;
  const ::control::planning::ObjectStatic& static_() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectStatic* release_static_();
  ::control::planning::ObjectStatic* mutable_static_();
  void set_allocated_static_(::control::planning::ObjectStatic* value);
  void unsafe_arena_set_allocated_static_(::control::planning::ObjectStatic* value);
  ::control::planning::ObjectStatic* unsafe_arena_release_static_();

  private:
  const ::control::planning::ObjectStatic& _internal_static_() const;
  ::control::planning::ObjectStatic* _internal_mutable_static_();

  public:
  // .control.planning.ObjectDynamic dynamic = 2;
  bool has_dynamic() const;
  private:
  bool _internal_has_dynamic() const;

  public:
  void clear_dynamic() ;
  const ::control::planning::ObjectDynamic& dynamic() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectDynamic* release_dynamic();
  ::control::planning::ObjectDynamic* mutable_dynamic();
  void set_allocated_dynamic(::control::planning::ObjectDynamic* value);
  void unsafe_arena_set_allocated_dynamic(::control::planning::ObjectDynamic* value);
  ::control::planning::ObjectDynamic* unsafe_arena_release_dynamic();

  private:
  const ::control::planning::ObjectDynamic& _internal_dynamic() const;
  ::control::planning::ObjectDynamic* _internal_mutable_dynamic();

  public:
  void clear_motion_tag();
  MotionTagCase motion_tag_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.ObjectMotionType)
 private:
  class _Internal;
  void set_has_static_();
  void set_has_dynamic();
  inline bool has_motion_tag() const;
  inline void clear_has_motion_tag();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectMotionType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectMotionType& from_msg);
    union MotionTagUnion {
      constexpr MotionTagUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::control::planning::ObjectStatic* static__;
      ::control::planning::ObjectDynamic* dynamic_;
    } motion_tag_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectFollow final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectFollow) */ {
 public:
  inline ObjectFollow() : ObjectFollow(nullptr) {}
  ~ObjectFollow() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectFollow(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectFollow(const ObjectFollow& from) : ObjectFollow(nullptr, from) {}
  inline ObjectFollow(ObjectFollow&& from) noexcept
      : ObjectFollow(nullptr, std::move(from)) {}
  inline ObjectFollow& operator=(const ObjectFollow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectFollow& operator=(ObjectFollow&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectFollow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectFollow* internal_default_instance() {
    return reinterpret_cast<const ObjectFollow*>(
        &_ObjectFollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ObjectFollow& a, ObjectFollow& b) { a.Swap(&b); }
  inline void Swap(ObjectFollow* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectFollow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectFollow* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectFollow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectFollow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectFollow& from) { ObjectFollow::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectFollow* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectFollow"; }

 protected:
  explicit ObjectFollow(::google::protobuf::Arena* arena);
  ObjectFollow(::google::protobuf::Arena* arena, const ObjectFollow& from);
  ObjectFollow(::google::protobuf::Arena* arena, ObjectFollow&& from) noexcept
      : ObjectFollow(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
  };
  // optional .control.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  void clear_fence_point() ;
  const ::control::common::PointENU& fence_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_fence_point();
  ::control::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_fence_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_fence_point();

  private:
  const ::control::common::PointENU& _internal_fence_point() const;
  ::control::common::PointENU* _internal_mutable_fence_point();

  public:
  // optional double distance_s = 1;
  bool has_distance_s() const;
  void clear_distance_s() ;
  double distance_s() const;
  void set_distance_s(double value);

  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);

  public:
  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  void clear_fence_heading() ;
  double fence_heading() const;
  void set_fence_heading(double value);

  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectFollow)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectFollow_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectFollow& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::common::PointENU* fence_point_;
    double distance_s_;
    double fence_heading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainStop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainStop) */ {
 public:
  inline MainStop() : MainStop(nullptr) {}
  ~MainStop() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainStop(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainStop(const MainStop& from) : MainStop(nullptr, from) {}
  inline MainStop(MainStop&& from) noexcept
      : MainStop(nullptr, std::move(from)) {}
  inline MainStop& operator=(const MainStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainStop& operator=(MainStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainStop* internal_default_instance() {
    return reinterpret_cast<const MainStop*>(
        &_MainStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(MainStop& a, MainStop& b) { a.Swap(&b); }
  inline void Swap(MainStop* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainStop* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainStop& from) { MainStop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainStop* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainStop"; }

 protected:
  explicit MainStop(::google::protobuf::Arena* arena);
  MainStop(::google::protobuf::Arena* arena, const MainStop& from);
  MainStop(::google::protobuf::Arena* arena, MainStop&& from) noexcept
      : MainStop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 2,
    kStopPointFieldNumber = 3,
    kStopHeadingFieldNumber = 4,
    kReasonCodeFieldNumber = 1,
  };
  // optional string reason = 2;
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // optional .control.common.PointENU stop_point = 3;
  bool has_stop_point() const;
  void clear_stop_point() ;
  const ::control::common::PointENU& stop_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_stop_point();
  ::control::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_stop_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_stop_point();

  private:
  const ::control::common::PointENU& _internal_stop_point() const;
  ::control::common::PointENU* _internal_mutable_stop_point();

  public:
  // optional double stop_heading = 4;
  bool has_stop_heading() const;
  void clear_stop_heading() ;
  double stop_heading() const;
  void set_stop_heading(double value);

  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);

  public:
  // optional .control.planning.StopReasonCode reason_code = 1;
  bool has_reason_code() const;
  void clear_reason_code() ;
  ::control::planning::StopReasonCode reason_code() const;
  void set_reason_code(::control::planning::StopReasonCode value);

  private:
  ::control::planning::StopReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::control::planning::StopReasonCode value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.MainStop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      40, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainStop_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainStop& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::control::common::PointENU* stop_point_;
    double stop_heading_;
    int reason_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainMissionComplete final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainMissionComplete) */ {
 public:
  inline MainMissionComplete() : MainMissionComplete(nullptr) {}
  ~MainMissionComplete() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainMissionComplete(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainMissionComplete(const MainMissionComplete& from) : MainMissionComplete(nullptr, from) {}
  inline MainMissionComplete(MainMissionComplete&& from) noexcept
      : MainMissionComplete(nullptr, std::move(from)) {}
  inline MainMissionComplete& operator=(const MainMissionComplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainMissionComplete& operator=(MainMissionComplete&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainMissionComplete& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainMissionComplete* internal_default_instance() {
    return reinterpret_cast<const MainMissionComplete*>(
        &_MainMissionComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(MainMissionComplete& a, MainMissionComplete& b) { a.Swap(&b); }
  inline void Swap(MainMissionComplete* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainMissionComplete* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainMissionComplete* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainMissionComplete>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainMissionComplete& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainMissionComplete& from) { MainMissionComplete::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainMissionComplete* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainMissionComplete"; }

 protected:
  explicit MainMissionComplete(::google::protobuf::Arena* arena);
  MainMissionComplete(::google::protobuf::Arena* arena, const MainMissionComplete& from);
  MainMissionComplete(::google::protobuf::Arena* arena, MainMissionComplete&& from) noexcept
      : MainMissionComplete(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStopPointFieldNumber = 1,
    kStopHeadingFieldNumber = 2,
  };
  // optional .control.common.PointENU stop_point = 1;
  bool has_stop_point() const;
  void clear_stop_point() ;
  const ::control::common::PointENU& stop_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_stop_point();
  ::control::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_stop_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_stop_point();

  private:
  const ::control::common::PointENU& _internal_stop_point() const;
  ::control::common::PointENU* _internal_mutable_stop_point();

  public:
  // optional double stop_heading = 2;
  bool has_stop_heading() const;
  void clear_stop_heading() ;
  double stop_heading() const;
  void set_stop_heading(double value);

  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.MainMissionComplete)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainMissionComplete_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainMissionComplete& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::common::PointENU* stop_point_;
    double stop_heading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainEmergencyStop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainEmergencyStop) */ {
 public:
  inline MainEmergencyStop() : MainEmergencyStop(nullptr) {}
  ~MainEmergencyStop() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainEmergencyStop(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainEmergencyStop(const MainEmergencyStop& from) : MainEmergencyStop(nullptr, from) {}
  inline MainEmergencyStop(MainEmergencyStop&& from) noexcept
      : MainEmergencyStop(nullptr, std::move(from)) {}
  inline MainEmergencyStop& operator=(const MainEmergencyStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainEmergencyStop& operator=(MainEmergencyStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainEmergencyStop& default_instance() {
    return *internal_default_instance();
  }
  enum TaskCase {
    kHardBrake = 3,
    kCruiseToStop = 4,
    TASK_NOT_SET = 0,
  };
  static inline const MainEmergencyStop* internal_default_instance() {
    return reinterpret_cast<const MainEmergencyStop*>(
        &_MainEmergencyStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(MainEmergencyStop& a, MainEmergencyStop& b) { a.Swap(&b); }
  inline void Swap(MainEmergencyStop* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainEmergencyStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainEmergencyStop* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainEmergencyStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainEmergencyStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainEmergencyStop& from) { MainEmergencyStop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainEmergencyStop* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainEmergencyStop"; }

 protected:
  explicit MainEmergencyStop(::google::protobuf::Arena* arena);
  MainEmergencyStop(::google::protobuf::Arena* arena, const MainEmergencyStop& from);
  MainEmergencyStop(::google::protobuf::Arena* arena, MainEmergencyStop&& from) noexcept
      : MainEmergencyStop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ReasonCode = MainEmergencyStop_ReasonCode;
  static constexpr ReasonCode ESTOP_REASON_INTERNAL_ERR = MainEmergencyStop_ReasonCode_ESTOP_REASON_INTERNAL_ERR;
  static constexpr ReasonCode ESTOP_REASON_COLLISION = MainEmergencyStop_ReasonCode_ESTOP_REASON_COLLISION;
  static constexpr ReasonCode ESTOP_REASON_ST_FIND_PATH = MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_FIND_PATH;
  static constexpr ReasonCode ESTOP_REASON_ST_MAKE_DECISION = MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_MAKE_DECISION;
  static constexpr ReasonCode ESTOP_REASON_SENSOR_ERROR = MainEmergencyStop_ReasonCode_ESTOP_REASON_SENSOR_ERROR;
  static inline bool ReasonCode_IsValid(int value) {
    return MainEmergencyStop_ReasonCode_IsValid(value);
  }
  static constexpr ReasonCode ReasonCode_MIN = MainEmergencyStop_ReasonCode_ReasonCode_MIN;
  static constexpr ReasonCode ReasonCode_MAX = MainEmergencyStop_ReasonCode_ReasonCode_MAX;
  static constexpr int ReasonCode_ARRAYSIZE = MainEmergencyStop_ReasonCode_ReasonCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ReasonCode_descriptor() {
    return MainEmergencyStop_ReasonCode_descriptor();
  }
  template <typename T>
  static inline const std::string& ReasonCode_Name(T value) {
    return MainEmergencyStop_ReasonCode_Name(value);
  }
  static inline bool ReasonCode_Parse(absl::string_view name, ReasonCode* value) {
    return MainEmergencyStop_ReasonCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 2,
    kReasonCodeFieldNumber = 1,
    kHardBrakeFieldNumber = 3,
    kCruiseToStopFieldNumber = 4,
  };
  // optional string reason = 2;
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // optional .control.planning.MainEmergencyStop.ReasonCode reason_code = 1;
  bool has_reason_code() const;
  void clear_reason_code() ;
  ::control::planning::MainEmergencyStop_ReasonCode reason_code() const;
  void set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value);

  private:
  ::control::planning::MainEmergencyStop_ReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value);

  public:
  // .control.planning.EmergencyStopHardBrake hard_brake = 3;
  bool has_hard_brake() const;
  private:
  bool _internal_has_hard_brake() const;

  public:
  void clear_hard_brake() ;
  const ::control::planning::EmergencyStopHardBrake& hard_brake() const;
  PROTOBUF_NODISCARD ::control::planning::EmergencyStopHardBrake* release_hard_brake();
  ::control::planning::EmergencyStopHardBrake* mutable_hard_brake();
  void set_allocated_hard_brake(::control::planning::EmergencyStopHardBrake* value);
  void unsafe_arena_set_allocated_hard_brake(::control::planning::EmergencyStopHardBrake* value);
  ::control::planning::EmergencyStopHardBrake* unsafe_arena_release_hard_brake();

  private:
  const ::control::planning::EmergencyStopHardBrake& _internal_hard_brake() const;
  ::control::planning::EmergencyStopHardBrake* _internal_mutable_hard_brake();

  public:
  // .control.planning.EmergencyStopCruiseToStop cruise_to_stop = 4;
  bool has_cruise_to_stop() const;
  private:
  bool _internal_has_cruise_to_stop() const;

  public:
  void clear_cruise_to_stop() ;
  const ::control::planning::EmergencyStopCruiseToStop& cruise_to_stop() const;
  PROTOBUF_NODISCARD ::control::planning::EmergencyStopCruiseToStop* release_cruise_to_stop();
  ::control::planning::EmergencyStopCruiseToStop* mutable_cruise_to_stop();
  void set_allocated_cruise_to_stop(::control::planning::EmergencyStopCruiseToStop* value);
  void unsafe_arena_set_allocated_cruise_to_stop(::control::planning::EmergencyStopCruiseToStop* value);
  ::control::planning::EmergencyStopCruiseToStop* unsafe_arena_release_cruise_to_stop();

  private:
  const ::control::planning::EmergencyStopCruiseToStop& _internal_cruise_to_stop() const;
  ::control::planning::EmergencyStopCruiseToStop* _internal_mutable_cruise_to_stop();

  public:
  void clear_task();
  TaskCase task_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.MainEmergencyStop)
 private:
  class _Internal;
  void set_has_hard_brake();
  void set_has_cruise_to_stop();
  inline bool has_task() const;
  inline void clear_has_task();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 3,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainEmergencyStop_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainEmergencyStop& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    int reason_code_;
    union TaskUnion {
      constexpr TaskUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::control::planning::EmergencyStopHardBrake* hard_brake_;
      ::control::planning::EmergencyStopCruiseToStop* cruise_to_stop_;
    } task_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisionType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectDecisionType) */ {
 public:
  inline ObjectDecisionType() : ObjectDecisionType(nullptr) {}
  ~ObjectDecisionType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectDecisionType(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectDecisionType(const ObjectDecisionType& from) : ObjectDecisionType(nullptr, from) {}
  inline ObjectDecisionType(ObjectDecisionType&& from) noexcept
      : ObjectDecisionType(nullptr, std::move(from)) {}
  inline ObjectDecisionType& operator=(const ObjectDecisionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecisionType& operator=(ObjectDecisionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDecisionType& default_instance() {
    return *internal_default_instance();
  }
  enum ObjectTagCase {
    kIgnore = 1,
    kStop = 2,
    kFollow = 3,
    kYield = 4,
    kOvertake = 5,
    kNudge = 6,
    kAvoid = 7,
    kSidePass = 8,
    OBJECT_TAG_NOT_SET = 0,
  };
  static inline const ObjectDecisionType* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisionType*>(
        &_ObjectDecisionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ObjectDecisionType& a, ObjectDecisionType& b) { a.Swap(&b); }
  inline void Swap(ObjectDecisionType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecisionType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDecisionType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectDecisionType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectDecisionType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectDecisionType& from) { ObjectDecisionType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectDecisionType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectDecisionType"; }

 protected:
  explicit ObjectDecisionType(::google::protobuf::Arena* arena);
  ObjectDecisionType(::google::protobuf::Arena* arena, const ObjectDecisionType& from);
  ObjectDecisionType(::google::protobuf::Arena* arena, ObjectDecisionType&& from) noexcept
      : ObjectDecisionType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIgnoreFieldNumber = 1,
    kStopFieldNumber = 2,
    kFollowFieldNumber = 3,
    kYieldFieldNumber = 4,
    kOvertakeFieldNumber = 5,
    kNudgeFieldNumber = 6,
    kAvoidFieldNumber = 7,
    kSidePassFieldNumber = 8,
  };
  // .control.planning.ObjectIgnore ignore = 1;
  bool has_ignore() const;
  private:
  bool _internal_has_ignore() const;

  public:
  void clear_ignore() ;
  const ::control::planning::ObjectIgnore& ignore() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectIgnore* release_ignore();
  ::control::planning::ObjectIgnore* mutable_ignore();
  void set_allocated_ignore(::control::planning::ObjectIgnore* value);
  void unsafe_arena_set_allocated_ignore(::control::planning::ObjectIgnore* value);
  ::control::planning::ObjectIgnore* unsafe_arena_release_ignore();

  private:
  const ::control::planning::ObjectIgnore& _internal_ignore() const;
  ::control::planning::ObjectIgnore* _internal_mutable_ignore();

  public:
  // .control.planning.ObjectStop stop = 2;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;

  public:
  void clear_stop() ;
  const ::control::planning::ObjectStop& stop() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectStop* release_stop();
  ::control::planning::ObjectStop* mutable_stop();
  void set_allocated_stop(::control::planning::ObjectStop* value);
  void unsafe_arena_set_allocated_stop(::control::planning::ObjectStop* value);
  ::control::planning::ObjectStop* unsafe_arena_release_stop();

  private:
  const ::control::planning::ObjectStop& _internal_stop() const;
  ::control::planning::ObjectStop* _internal_mutable_stop();

  public:
  // .control.planning.ObjectFollow follow = 3;
  bool has_follow() const;
  private:
  bool _internal_has_follow() const;

  public:
  void clear_follow() ;
  const ::control::planning::ObjectFollow& follow() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectFollow* release_follow();
  ::control::planning::ObjectFollow* mutable_follow();
  void set_allocated_follow(::control::planning::ObjectFollow* value);
  void unsafe_arena_set_allocated_follow(::control::planning::ObjectFollow* value);
  ::control::planning::ObjectFollow* unsafe_arena_release_follow();

  private:
  const ::control::planning::ObjectFollow& _internal_follow() const;
  ::control::planning::ObjectFollow* _internal_mutable_follow();

  public:
  // .control.planning.ObjectYield yield = 4;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;

  public:
  void clear_yield() ;
  const ::control::planning::ObjectYield& yield() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectYield* release_yield();
  ::control::planning::ObjectYield* mutable_yield();
  void set_allocated_yield(::control::planning::ObjectYield* value);
  void unsafe_arena_set_allocated_yield(::control::planning::ObjectYield* value);
  ::control::planning::ObjectYield* unsafe_arena_release_yield();

  private:
  const ::control::planning::ObjectYield& _internal_yield() const;
  ::control::planning::ObjectYield* _internal_mutable_yield();

  public:
  // .control.planning.ObjectOvertake overtake = 5;
  bool has_overtake() const;
  private:
  bool _internal_has_overtake() const;

  public:
  void clear_overtake() ;
  const ::control::planning::ObjectOvertake& overtake() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectOvertake* release_overtake();
  ::control::planning::ObjectOvertake* mutable_overtake();
  void set_allocated_overtake(::control::planning::ObjectOvertake* value);
  void unsafe_arena_set_allocated_overtake(::control::planning::ObjectOvertake* value);
  ::control::planning::ObjectOvertake* unsafe_arena_release_overtake();

  private:
  const ::control::planning::ObjectOvertake& _internal_overtake() const;
  ::control::planning::ObjectOvertake* _internal_mutable_overtake();

  public:
  // .control.planning.ObjectNudge nudge = 6;
  bool has_nudge() const;
  private:
  bool _internal_has_nudge() const;

  public:
  void clear_nudge() ;
  const ::control::planning::ObjectNudge& nudge() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectNudge* release_nudge();
  ::control::planning::ObjectNudge* mutable_nudge();
  void set_allocated_nudge(::control::planning::ObjectNudge* value);
  void unsafe_arena_set_allocated_nudge(::control::planning::ObjectNudge* value);
  ::control::planning::ObjectNudge* unsafe_arena_release_nudge();

  private:
  const ::control::planning::ObjectNudge& _internal_nudge() const;
  ::control::planning::ObjectNudge* _internal_mutable_nudge();

  public:
  // .control.planning.ObjectAvoid avoid = 7;
  bool has_avoid() const;
  private:
  bool _internal_has_avoid() const;

  public:
  void clear_avoid() ;
  const ::control::planning::ObjectAvoid& avoid() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectAvoid* release_avoid();
  ::control::planning::ObjectAvoid* mutable_avoid();
  void set_allocated_avoid(::control::planning::ObjectAvoid* value);
  void unsafe_arena_set_allocated_avoid(::control::planning::ObjectAvoid* value);
  ::control::planning::ObjectAvoid* unsafe_arena_release_avoid();

  private:
  const ::control::planning::ObjectAvoid& _internal_avoid() const;
  ::control::planning::ObjectAvoid* _internal_mutable_avoid();

  public:
  // .control.planning.ObjectSidePass side_pass = 8;
  bool has_side_pass() const;
  private:
  bool _internal_has_side_pass() const;

  public:
  void clear_side_pass() ;
  const ::control::planning::ObjectSidePass& side_pass() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectSidePass* release_side_pass();
  ::control::planning::ObjectSidePass* mutable_side_pass();
  void set_allocated_side_pass(::control::planning::ObjectSidePass* value);
  void unsafe_arena_set_allocated_side_pass(::control::planning::ObjectSidePass* value);
  ::control::planning::ObjectSidePass* unsafe_arena_release_side_pass();

  private:
  const ::control::planning::ObjectSidePass& _internal_side_pass() const;
  ::control::planning::ObjectSidePass* _internal_mutable_side_pass();

  public:
  void clear_object_tag();
  ObjectTagCase object_tag_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.ObjectDecisionType)
 private:
  class _Internal;
  void set_has_ignore();
  void set_has_stop();
  void set_has_follow();
  void set_has_yield();
  void set_has_overtake();
  void set_has_nudge();
  void set_has_avoid();
  void set_has_side_pass();
  inline bool has_object_tag() const;
  inline void clear_has_object_tag();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectDecisionType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectDecisionType& from_msg);
    union ObjectTagUnion {
      constexpr ObjectTagUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::control::planning::ObjectIgnore* ignore_;
      ::control::planning::ObjectStop* stop_;
      ::control::planning::ObjectFollow* follow_;
      ::control::planning::ObjectYield* yield_;
      ::control::planning::ObjectOvertake* overtake_;
      ::control::planning::ObjectNudge* nudge_;
      ::control::planning::ObjectAvoid* avoid_;
      ::control::planning::ObjectSidePass* side_pass_;
    } object_tag_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainChangeLane final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainChangeLane) */ {
 public:
  inline MainChangeLane() : MainChangeLane(nullptr) {}
  ~MainChangeLane() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainChangeLane(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainChangeLane(const MainChangeLane& from) : MainChangeLane(nullptr, from) {}
  inline MainChangeLane(MainChangeLane&& from) noexcept
      : MainChangeLane(nullptr, std::move(from)) {}
  inline MainChangeLane& operator=(const MainChangeLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainChangeLane& operator=(MainChangeLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainChangeLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainChangeLane* internal_default_instance() {
    return reinterpret_cast<const MainChangeLane*>(
        &_MainChangeLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(MainChangeLane& a, MainChangeLane& b) { a.Swap(&b); }
  inline void Swap(MainChangeLane* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainChangeLane* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainChangeLane* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainChangeLane>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainChangeLane& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainChangeLane& from) { MainChangeLane::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainChangeLane* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainChangeLane"; }

 protected:
  explicit MainChangeLane(::google::protobuf::Arena* arena);
  MainChangeLane(::google::protobuf::Arena* arena, const MainChangeLane& from);
  MainChangeLane(::google::protobuf::Arena* arena, MainChangeLane&& from) noexcept
      : MainChangeLane(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = MainChangeLane_Type;
  static constexpr Type LEFT = MainChangeLane_Type_LEFT;
  static constexpr Type RIGHT = MainChangeLane_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return MainChangeLane_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = MainChangeLane_Type_Type_MIN;
  static constexpr Type Type_MAX = MainChangeLane_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = MainChangeLane_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return MainChangeLane_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return MainChangeLane_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return MainChangeLane_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDefaultLaneFieldNumber = 2,
    kDefaultLaneStopFieldNumber = 3,
    kTargetLaneStopFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .control.planning.TargetLane default_lane = 2;
  int default_lane_size() const;
  private:
  int _internal_default_lane_size() const;

  public:
  void clear_default_lane() ;
  ::control::planning::TargetLane* mutable_default_lane(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>* mutable_default_lane();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>& _internal_default_lane() const;
  ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>* _internal_mutable_default_lane();
  public:
  const ::control::planning::TargetLane& default_lane(int index) const;
  ::control::planning::TargetLane* add_default_lane();
  const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>& default_lane() const;
  // optional .control.planning.MainStop default_lane_stop = 3;
  bool has_default_lane_stop() const;
  void clear_default_lane_stop() ;
  const ::control::planning::MainStop& default_lane_stop() const;
  PROTOBUF_NODISCARD ::control::planning::MainStop* release_default_lane_stop();
  ::control::planning::MainStop* mutable_default_lane_stop();
  void set_allocated_default_lane_stop(::control::planning::MainStop* value);
  void unsafe_arena_set_allocated_default_lane_stop(::control::planning::MainStop* value);
  ::control::planning::MainStop* unsafe_arena_release_default_lane_stop();

  private:
  const ::control::planning::MainStop& _internal_default_lane_stop() const;
  ::control::planning::MainStop* _internal_mutable_default_lane_stop();

  public:
  // optional .control.planning.MainStop target_lane_stop = 4;
  bool has_target_lane_stop() const;
  void clear_target_lane_stop() ;
  const ::control::planning::MainStop& target_lane_stop() const;
  PROTOBUF_NODISCARD ::control::planning::MainStop* release_target_lane_stop();
  ::control::planning::MainStop* mutable_target_lane_stop();
  void set_allocated_target_lane_stop(::control::planning::MainStop* value);
  void unsafe_arena_set_allocated_target_lane_stop(::control::planning::MainStop* value);
  ::control::planning::MainStop* unsafe_arena_release_target_lane_stop();

  private:
  const ::control::planning::MainStop& _internal_target_lane_stop() const;
  ::control::planning::MainStop* _internal_mutable_target_lane_stop();

  public:
  // optional .control.planning.MainChangeLane.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::control::planning::MainChangeLane_Type type() const;
  void set_type(::control::planning::MainChangeLane_Type value);

  private:
  ::control::planning::MainChangeLane_Type _internal_type() const;
  void _internal_set_type(::control::planning::MainChangeLane_Type value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.MainChangeLane)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainChangeLane_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainChangeLane& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::planning::TargetLane > default_lane_;
    ::control::planning::MainStop* default_lane_stop_;
    ::control::planning::MainStop* target_lane_stop_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectStatus) */ {
 public:
  inline ObjectStatus() : ObjectStatus(nullptr) {}
  ~ObjectStatus() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectStatus(const ObjectStatus& from) : ObjectStatus(nullptr, from) {}
  inline ObjectStatus(ObjectStatus&& from) noexcept
      : ObjectStatus(nullptr, std::move(from)) {}
  inline ObjectStatus& operator=(const ObjectStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStatus& operator=(ObjectStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectStatus* internal_default_instance() {
    return reinterpret_cast<const ObjectStatus*>(
        &_ObjectStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ObjectStatus& a, ObjectStatus& b) { a.Swap(&b); }
  inline void Swap(ObjectStatus* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectStatus* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectStatus& from) { ObjectStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectStatus* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectStatus"; }

 protected:
  explicit ObjectStatus(::google::protobuf::Arena* arena);
  ObjectStatus(::google::protobuf::Arena* arena, const ObjectStatus& from);
  ObjectStatus(::google::protobuf::Arena* arena, ObjectStatus&& from) noexcept
      : ObjectStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMotionTypeFieldNumber = 1,
    kDecisionTypeFieldNumber = 2,
  };
  // optional .control.planning.ObjectMotionType motion_type = 1;
  bool has_motion_type() const;
  void clear_motion_type() ;
  const ::control::planning::ObjectMotionType& motion_type() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectMotionType* release_motion_type();
  ::control::planning::ObjectMotionType* mutable_motion_type();
  void set_allocated_motion_type(::control::planning::ObjectMotionType* value);
  void unsafe_arena_set_allocated_motion_type(::control::planning::ObjectMotionType* value);
  ::control::planning::ObjectMotionType* unsafe_arena_release_motion_type();

  private:
  const ::control::planning::ObjectMotionType& _internal_motion_type() const;
  ::control::planning::ObjectMotionType* _internal_mutable_motion_type();

  public:
  // optional .control.planning.ObjectDecisionType decision_type = 2;
  bool has_decision_type() const;
  void clear_decision_type() ;
  const ::control::planning::ObjectDecisionType& decision_type() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectDecisionType* release_decision_type();
  ::control::planning::ObjectDecisionType* mutable_decision_type();
  void set_allocated_decision_type(::control::planning::ObjectDecisionType* value);
  void unsafe_arena_set_allocated_decision_type(::control::planning::ObjectDecisionType* value);
  ::control::planning::ObjectDecisionType* unsafe_arena_release_decision_type();

  private:
  const ::control::planning::ObjectDecisionType& _internal_decision_type() const;
  ::control::planning::ObjectDecisionType* _internal_mutable_decision_type();

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectStatus_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::planning::ObjectMotionType* motion_type_;
    ::control::planning::ObjectDecisionType* decision_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecision final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectDecision) */ {
 public:
  inline ObjectDecision() : ObjectDecision(nullptr) {}
  ~ObjectDecision() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectDecision(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectDecision(const ObjectDecision& from) : ObjectDecision(nullptr, from) {}
  inline ObjectDecision(ObjectDecision&& from) noexcept
      : ObjectDecision(nullptr, std::move(from)) {}
  inline ObjectDecision& operator=(const ObjectDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecision& operator=(ObjectDecision&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDecision& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectDecision* internal_default_instance() {
    return reinterpret_cast<const ObjectDecision*>(
        &_ObjectDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ObjectDecision& a, ObjectDecision& b) { a.Swap(&b); }
  inline void Swap(ObjectDecision* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecision* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDecision* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectDecision>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectDecision& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectDecision& from) { ObjectDecision::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectDecision* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectDecision"; }

 protected:
  explicit ObjectDecision(::google::protobuf::Arena* arena);
  ObjectDecision(::google::protobuf::Arena* arena, const ObjectDecision& from);
  ObjectDecision(::google::protobuf::Arena* arena, ObjectDecision&& from) noexcept
      : ObjectDecision(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectDecisionFieldNumber = 3,
    kIdFieldNumber = 1,
    kPerceptionIdFieldNumber = 2,
  };
  // repeated .control.planning.ObjectDecisionType object_decision = 3;
  int object_decision_size() const;
  private:
  int _internal_object_decision_size() const;

  public:
  void clear_object_decision() ;
  ::control::planning::ObjectDecisionType* mutable_object_decision(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>* mutable_object_decision();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>& _internal_object_decision() const;
  ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>* _internal_mutable_object_decision();
  public:
  const ::control::planning::ObjectDecisionType& object_decision(int index) const;
  ::control::planning::ObjectDecisionType* add_object_decision();
  const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>& object_decision() const;
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional int32 perception_id = 2;
  bool has_perception_id() const;
  void clear_perception_id() ;
  ::int32_t perception_id() const;
  void set_perception_id(::int32_t value);

  private:
  ::int32_t _internal_perception_id() const;
  void _internal_set_perception_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning.ObjectDecision)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      42, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectDecision_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectDecision& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::planning::ObjectDecisionType > object_decision_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::int32_t perception_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainDecision final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.MainDecision) */ {
 public:
  inline MainDecision() : MainDecision(nullptr) {}
  ~MainDecision() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MainDecision(
      ::google::protobuf::internal::ConstantInitialized);

  inline MainDecision(const MainDecision& from) : MainDecision(nullptr, from) {}
  inline MainDecision(MainDecision&& from) noexcept
      : MainDecision(nullptr, std::move(from)) {}
  inline MainDecision& operator=(const MainDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainDecision& operator=(MainDecision&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainDecision& default_instance() {
    return *internal_default_instance();
  }
  enum TaskCase {
    kCruise = 1,
    kStop = 2,
    kEstop = 3,
    kChangeLane = 4,
    kMissionComplete = 6,
    kNotReady = 7,
    kParking = 8,
    TASK_NOT_SET = 0,
  };
  static inline const MainDecision* internal_default_instance() {
    return reinterpret_cast<const MainDecision*>(
        &_MainDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(MainDecision& a, MainDecision& b) { a.Swap(&b); }
  inline void Swap(MainDecision* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainDecision* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainDecision* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MainDecision>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MainDecision& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MainDecision& from) { MainDecision::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MainDecision* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.MainDecision"; }

 protected:
  explicit MainDecision(::google::protobuf::Arena* arena);
  MainDecision(::google::protobuf::Arena* arena, const MainDecision& from);
  MainDecision(::google::protobuf::Arena* arena, MainDecision&& from) noexcept
      : MainDecision(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetLaneFieldNumber = 5,
    kCruiseFieldNumber = 1,
    kStopFieldNumber = 2,
    kEstopFieldNumber = 3,
    kChangeLaneFieldNumber = 4,
    kMissionCompleteFieldNumber = 6,
    kNotReadyFieldNumber = 7,
    kParkingFieldNumber = 8,
  };
  // repeated .control.planning.TargetLane target_lane = 5 [deprecated = true];
  [[deprecated]]  int target_lane_size() const;
  private:
  int _internal_target_lane_size() const;

  public:
  [[deprecated]]  void clear_target_lane() ;
  [[deprecated]] ::control::planning::TargetLane* mutable_target_lane(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>* mutable_target_lane();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>& _internal_target_lane() const;
  ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>* _internal_mutable_target_lane();
  public:
  [[deprecated]] const ::control::planning::TargetLane& target_lane(int index) const;
  [[deprecated]] ::control::planning::TargetLane* add_target_lane();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>& target_lane() const;
  // .control.planning.MainCruise cruise = 1;
  bool has_cruise() const;
  private:
  bool _internal_has_cruise() const;

  public:
  void clear_cruise() ;
  const ::control::planning::MainCruise& cruise() const;
  PROTOBUF_NODISCARD ::control::planning::MainCruise* release_cruise();
  ::control::planning::MainCruise* mutable_cruise();
  void set_allocated_cruise(::control::planning::MainCruise* value);
  void unsafe_arena_set_allocated_cruise(::control::planning::MainCruise* value);
  ::control::planning::MainCruise* unsafe_arena_release_cruise();

  private:
  const ::control::planning::MainCruise& _internal_cruise() const;
  ::control::planning::MainCruise* _internal_mutable_cruise();

  public:
  // .control.planning.MainStop stop = 2;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;

  public:
  void clear_stop() ;
  const ::control::planning::MainStop& stop() const;
  PROTOBUF_NODISCARD ::control::planning::MainStop* release_stop();
  ::control::planning::MainStop* mutable_stop();
  void set_allocated_stop(::control::planning::MainStop* value);
  void unsafe_arena_set_allocated_stop(::control::planning::MainStop* value);
  ::control::planning::MainStop* unsafe_arena_release_stop();

  private:
  const ::control::planning::MainStop& _internal_stop() const;
  ::control::planning::MainStop* _internal_mutable_stop();

  public:
  // .control.planning.MainEmergencyStop estop = 3;
  bool has_estop() const;
  private:
  bool _internal_has_estop() const;

  public:
  void clear_estop() ;
  const ::control::planning::MainEmergencyStop& estop() const;
  PROTOBUF_NODISCARD ::control::planning::MainEmergencyStop* release_estop();
  ::control::planning::MainEmergencyStop* mutable_estop();
  void set_allocated_estop(::control::planning::MainEmergencyStop* value);
  void unsafe_arena_set_allocated_estop(::control::planning::MainEmergencyStop* value);
  ::control::planning::MainEmergencyStop* unsafe_arena_release_estop();

  private:
  const ::control::planning::MainEmergencyStop& _internal_estop() const;
  ::control::planning::MainEmergencyStop* _internal_mutable_estop();

  public:
  // .control.planning.MainChangeLane change_lane = 4 [deprecated = true];
  [[deprecated]]  bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;

  public:
  [[deprecated]]  void clear_change_lane() ;
  [[deprecated]] const ::control::planning::MainChangeLane& change_lane() const;
  [[deprecated]] PROTOBUF_NODISCARD ::control::planning::MainChangeLane* release_change_lane();
  [[deprecated]] ::control::planning::MainChangeLane* mutable_change_lane();
  [[deprecated]] void set_allocated_change_lane(::control::planning::MainChangeLane* value);
  [[deprecated]] void unsafe_arena_set_allocated_change_lane(::control::planning::MainChangeLane* value);
  [[deprecated]] ::control::planning::MainChangeLane* unsafe_arena_release_change_lane();

  private:
  const ::control::planning::MainChangeLane& _internal_change_lane() const;
  ::control::planning::MainChangeLane* _internal_mutable_change_lane();

  public:
  // .control.planning.MainMissionComplete mission_complete = 6;
  bool has_mission_complete() const;
  private:
  bool _internal_has_mission_complete() const;

  public:
  void clear_mission_complete() ;
  const ::control::planning::MainMissionComplete& mission_complete() const;
  PROTOBUF_NODISCARD ::control::planning::MainMissionComplete* release_mission_complete();
  ::control::planning::MainMissionComplete* mutable_mission_complete();
  void set_allocated_mission_complete(::control::planning::MainMissionComplete* value);
  void unsafe_arena_set_allocated_mission_complete(::control::planning::MainMissionComplete* value);
  ::control::planning::MainMissionComplete* unsafe_arena_release_mission_complete();

  private:
  const ::control::planning::MainMissionComplete& _internal_mission_complete() const;
  ::control::planning::MainMissionComplete* _internal_mutable_mission_complete();

  public:
  // .control.planning.MainNotReady not_ready = 7;
  bool has_not_ready() const;
  private:
  bool _internal_has_not_ready() const;

  public:
  void clear_not_ready() ;
  const ::control::planning::MainNotReady& not_ready() const;
  PROTOBUF_NODISCARD ::control::planning::MainNotReady* release_not_ready();
  ::control::planning::MainNotReady* mutable_not_ready();
  void set_allocated_not_ready(::control::planning::MainNotReady* value);
  void unsafe_arena_set_allocated_not_ready(::control::planning::MainNotReady* value);
  ::control::planning::MainNotReady* unsafe_arena_release_not_ready();

  private:
  const ::control::planning::MainNotReady& _internal_not_ready() const;
  ::control::planning::MainNotReady* _internal_mutable_not_ready();

  public:
  // .control.planning.MainParking parking = 8;
  bool has_parking() const;
  private:
  bool _internal_has_parking() const;

  public:
  void clear_parking() ;
  const ::control::planning::MainParking& parking() const;
  PROTOBUF_NODISCARD ::control::planning::MainParking* release_parking();
  ::control::planning::MainParking* mutable_parking();
  void set_allocated_parking(::control::planning::MainParking* value);
  void unsafe_arena_set_allocated_parking(::control::planning::MainParking* value);
  ::control::planning::MainParking* unsafe_arena_release_parking();

  private:
  const ::control::planning::MainParking& _internal_parking() const;
  ::control::planning::MainParking* _internal_mutable_parking();

  public:
  void clear_task();
  TaskCase task_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.MainDecision)
 private:
  class _Internal;
  void set_has_cruise();
  void set_has_stop();
  void set_has_estop();
  void set_has_change_lane();
  void set_has_mission_complete();
  void set_has_not_ready();
  void set_has_parking();
  inline bool has_task() const;
  inline void clear_has_task();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MainDecision_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MainDecision& from_msg);
    ::google::protobuf::RepeatedPtrField< ::control::planning::TargetLane > target_lane_;
    union TaskUnion {
      constexpr TaskUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::control::planning::MainCruise* cruise_;
      ::control::planning::MainStop* stop_;
      ::control::planning::MainEmergencyStop* estop_;
      ::control::planning::MainChangeLane* change_lane_;
      ::control::planning::MainMissionComplete* mission_complete_;
      ::control::planning::MainNotReady* not_ready_;
      ::control::planning::MainParking* parking_;
    } task_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.ObjectDecisions) */ {
 public:
  inline ObjectDecisions() : ObjectDecisions(nullptr) {}
  ~ObjectDecisions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectDecisions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObjectDecisions(const ObjectDecisions& from) : ObjectDecisions(nullptr, from) {}
  inline ObjectDecisions(ObjectDecisions&& from) noexcept
      : ObjectDecisions(nullptr, std::move(from)) {}
  inline ObjectDecisions& operator=(const ObjectDecisions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecisions& operator=(ObjectDecisions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDecisions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectDecisions* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisions*>(
        &_ObjectDecisions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ObjectDecisions& a, ObjectDecisions& b) { a.Swap(&b); }
  inline void Swap(ObjectDecisions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecisions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDecisions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObjectDecisions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectDecisions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectDecisions& from) { ObjectDecisions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObjectDecisions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.ObjectDecisions"; }

 protected:
  explicit ObjectDecisions(::google::protobuf::Arena* arena);
  ObjectDecisions(::google::protobuf::Arena* arena, const ObjectDecisions& from);
  ObjectDecisions(::google::protobuf::Arena* arena, ObjectDecisions&& from) noexcept
      : ObjectDecisions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDecisionFieldNumber = 1,
  };
  // repeated .control.planning.ObjectDecision decision = 1;
  int decision_size() const;
  private:
  int _internal_decision_size() const;

  public:
  void clear_decision() ;
  ::control::planning::ObjectDecision* mutable_decision(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>* mutable_decision();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>& _internal_decision() const;
  ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>* _internal_mutable_decision();
  public:
  const ::control::planning::ObjectDecision& decision(int index) const;
  ::control::planning::ObjectDecision* add_decision();
  const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>& decision() const;
  // @@protoc_insertion_point(class_scope:control.planning.ObjectDecisions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObjectDecisions_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObjectDecisions& from_msg);
    ::google::protobuf::RepeatedPtrField< ::control::planning::ObjectDecision > decision_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class DecisionResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning.DecisionResult) */ {
 public:
  inline DecisionResult() : DecisionResult(nullptr) {}
  ~DecisionResult() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DecisionResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline DecisionResult(const DecisionResult& from) : DecisionResult(nullptr, from) {}
  inline DecisionResult(DecisionResult&& from) noexcept
      : DecisionResult(nullptr, std::move(from)) {}
  inline DecisionResult& operator=(const DecisionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionResult& operator=(DecisionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecisionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecisionResult* internal_default_instance() {
    return reinterpret_cast<const DecisionResult*>(
        &_DecisionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(DecisionResult& a, DecisionResult& b) { a.Swap(&b); }
  inline void Swap(DecisionResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecisionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecisionResult* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DecisionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DecisionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DecisionResult& from) { DecisionResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DecisionResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning.DecisionResult"; }

 protected:
  explicit DecisionResult(::google::protobuf::Arena* arena);
  DecisionResult(::google::protobuf::Arena* arena, const DecisionResult& from);
  DecisionResult(::google::protobuf::Arena* arena, DecisionResult&& from) noexcept
      : DecisionResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMainDecisionFieldNumber = 1,
    kObjectDecisionFieldNumber = 2,
    kVehicleSignalFieldNumber = 3,
  };
  // optional .control.planning.MainDecision main_decision = 1;
  bool has_main_decision() const;
  void clear_main_decision() ;
  const ::control::planning::MainDecision& main_decision() const;
  PROTOBUF_NODISCARD ::control::planning::MainDecision* release_main_decision();
  ::control::planning::MainDecision* mutable_main_decision();
  void set_allocated_main_decision(::control::planning::MainDecision* value);
  void unsafe_arena_set_allocated_main_decision(::control::planning::MainDecision* value);
  ::control::planning::MainDecision* unsafe_arena_release_main_decision();

  private:
  const ::control::planning::MainDecision& _internal_main_decision() const;
  ::control::planning::MainDecision* _internal_mutable_main_decision();

  public:
  // optional .control.planning.ObjectDecisions object_decision = 2;
  bool has_object_decision() const;
  void clear_object_decision() ;
  const ::control::planning::ObjectDecisions& object_decision() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectDecisions* release_object_decision();
  ::control::planning::ObjectDecisions* mutable_object_decision();
  void set_allocated_object_decision(::control::planning::ObjectDecisions* value);
  void unsafe_arena_set_allocated_object_decision(::control::planning::ObjectDecisions* value);
  ::control::planning::ObjectDecisions* unsafe_arena_release_object_decision();

  private:
  const ::control::planning::ObjectDecisions& _internal_object_decision() const;
  ::control::planning::ObjectDecisions* _internal_mutable_object_decision();

  public:
  // optional .control.common.VehicleSignal vehicle_signal = 3;
  bool has_vehicle_signal() const;
  void clear_vehicle_signal() ;
  const ::control::common::VehicleSignal& vehicle_signal() const;
  PROTOBUF_NODISCARD ::control::common::VehicleSignal* release_vehicle_signal();
  ::control::common::VehicleSignal* mutable_vehicle_signal();
  void set_allocated_vehicle_signal(::control::common::VehicleSignal* value);
  void unsafe_arena_set_allocated_vehicle_signal(::control::common::VehicleSignal* value);
  ::control::common::VehicleSignal* unsafe_arena_release_vehicle_signal();

  private:
  const ::control::common::VehicleSignal& _internal_vehicle_signal() const;
  ::control::common::VehicleSignal* _internal_mutable_vehicle_signal();

  public:
  // @@protoc_insertion_point(class_scope:control.planning.DecisionResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DecisionResult_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DecisionResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::planning::MainDecision* main_decision_;
    ::control::planning::ObjectDecisions* object_decision_;
    ::control::common::VehicleSignal* vehicle_signal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TargetLane

// optional string id = 1;
inline bool TargetLane::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TargetLane::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TargetLane::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TargetLane::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.id)
}
inline std::string* TargetLane::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:control.planning.TargetLane.id)
  return _s;
}
inline const std::string& TargetLane::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void TargetLane::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* TargetLane::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* TargetLane::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.TargetLane.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TargetLane::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning.TargetLane.id)
}

// optional double start_s = 2;
inline bool TargetLane::has_start_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TargetLane::clear_start_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double TargetLane::start_s() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.start_s)
  return _internal_start_s();
}
inline void TargetLane::set_start_s(double value) {
  _internal_set_start_s(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.start_s)
}
inline double TargetLane::_internal_start_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_s_;
}
inline void TargetLane::_internal_set_start_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_s_ = value;
}

// optional double end_s = 3;
inline bool TargetLane::has_end_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TargetLane::clear_end_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double TargetLane::end_s() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.end_s)
  return _internal_end_s();
}
inline void TargetLane::set_end_s(double value) {
  _internal_set_end_s(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.end_s)
}
inline double TargetLane::_internal_end_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_s_;
}
inline void TargetLane::_internal_set_end_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_s_ = value;
}

// optional double speed_limit = 4;
inline bool TargetLane::has_speed_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TargetLane::clear_speed_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double TargetLane::speed_limit() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.speed_limit)
  return _internal_speed_limit();
}
inline void TargetLane::set_speed_limit(double value) {
  _internal_set_speed_limit(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.speed_limit)
}
inline double TargetLane::_internal_speed_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_limit_;
}
inline void TargetLane::_internal_set_speed_limit(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_limit_ = value;
}

// -------------------------------------------------------------------

// ObjectIgnore

// -------------------------------------------------------------------

// ObjectStop

// optional .control.planning.StopReasonCode reason_code = 1;
inline bool ObjectStop::has_reason_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ObjectStop::clear_reason_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_code_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::control::planning::StopReasonCode ObjectStop::reason_code() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.reason_code)
  return _internal_reason_code();
}
inline void ObjectStop::set_reason_code(::control::planning::StopReasonCode value) {
  _internal_set_reason_code(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.reason_code)
}
inline ::control::planning::StopReasonCode ObjectStop::_internal_reason_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::StopReasonCode>(_impl_.reason_code_);
}
inline void ObjectStop::_internal_set_reason_code(::control::planning::StopReasonCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::StopReasonCode_IsValid(value));
  _impl_.reason_code_ = value;
}

// optional double distance_s = 2;
inline bool ObjectStop::has_distance_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectStop::clear_distance_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ObjectStop::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.distance_s)
  return _internal_distance_s();
}
inline void ObjectStop::set_distance_s(double value) {
  _internal_set_distance_s(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.distance_s)
}
inline double ObjectStop::_internal_distance_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_s_;
}
inline void ObjectStop::_internal_set_distance_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = value;
}

// optional .control.common.PointENU stop_point = 3;
inline bool ObjectStop::has_stop_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& ObjectStop::_internal_stop_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.stop_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectStop::stop_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.stop_point)
  return _internal_stop_point();
}
inline void ObjectStop::unsafe_arena_set_allocated_stop_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_point_);
  }
  _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectStop.stop_point)
}
inline ::control::common::PointENU* ObjectStop::release_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* released = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* ObjectStop::unsafe_arena_release_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectStop.stop_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectStop::_internal_mutable_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.stop_point_;
}
inline ::control::common::PointENU* ObjectStop::mutable_stop_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::common::PointENU* _msg = _internal_mutable_stop_point();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStop.stop_point)
  return _msg;
}
inline void ObjectStop::set_allocated_stop_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectStop.stop_point)
}

// optional double stop_heading = 4;
inline bool ObjectStop::has_stop_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ObjectStop::clear_stop_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ObjectStop::stop_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.stop_heading)
  return _internal_stop_heading();
}
inline void ObjectStop::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.stop_heading)
}
inline double ObjectStop::_internal_stop_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_heading_;
}
inline void ObjectStop::_internal_set_stop_heading(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_heading_ = value;
}

// repeated string wait_for_obstacle = 5;
inline int ObjectStop::_internal_wait_for_obstacle_size() const {
  return _internal_wait_for_obstacle().size();
}
inline int ObjectStop::wait_for_obstacle_size() const {
  return _internal_wait_for_obstacle_size();
}
inline void ObjectStop::clear_wait_for_obstacle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_for_obstacle_.Clear();
}
inline std::string* ObjectStop::add_wait_for_obstacle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_wait_for_obstacle()->Add();
  // @@protoc_insertion_point(field_add_mutable:control.planning.ObjectStop.wait_for_obstacle)
  return _s;
}
inline const std::string& ObjectStop::wait_for_obstacle(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.wait_for_obstacle)
  return _internal_wait_for_obstacle().Get(index);
}
inline std::string* ObjectStop::mutable_wait_for_obstacle(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStop.wait_for_obstacle)
  return _internal_mutable_wait_for_obstacle()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ObjectStop::set_wait_for_obstacle(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_wait_for_obstacle()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.wait_for_obstacle)
}
template <typename Arg_, typename... Args_>
inline void ObjectStop::add_wait_for_obstacle(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_wait_for_obstacle(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:control.planning.ObjectStop.wait_for_obstacle)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ObjectStop::wait_for_obstacle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning.ObjectStop.wait_for_obstacle)
  return _internal_wait_for_obstacle();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ObjectStop::mutable_wait_for_obstacle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning.ObjectStop.wait_for_obstacle)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_wait_for_obstacle();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ObjectStop::_internal_wait_for_obstacle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_for_obstacle_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ObjectStop::_internal_mutable_wait_for_obstacle() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.wait_for_obstacle_;
}

// -------------------------------------------------------------------

// ObjectNudge

// optional .control.planning.ObjectNudge.Type type = 1;
inline bool ObjectNudge::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectNudge::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::control::planning::ObjectNudge_Type ObjectNudge::type() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectNudge.type)
  return _internal_type();
}
inline void ObjectNudge::set_type(::control::planning::ObjectNudge_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectNudge.type)
}
inline ::control::planning::ObjectNudge_Type ObjectNudge::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::ObjectNudge_Type>(_impl_.type_);
}
inline void ObjectNudge::_internal_set_type(::control::planning::ObjectNudge_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::ObjectNudge_Type_IsValid(value));
  _impl_.type_ = value;
}

// optional double distance_l = 2;
inline bool ObjectNudge::has_distance_l() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ObjectNudge::clear_distance_l() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_l_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ObjectNudge::distance_l() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectNudge.distance_l)
  return _internal_distance_l();
}
inline void ObjectNudge::set_distance_l(double value) {
  _internal_set_distance_l(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectNudge.distance_l)
}
inline double ObjectNudge::_internal_distance_l() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_l_;
}
inline void ObjectNudge::_internal_set_distance_l(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_l_ = value;
}

// -------------------------------------------------------------------

// ObjectYield

// optional double distance_s = 1;
inline bool ObjectYield::has_distance_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectYield::clear_distance_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ObjectYield::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.distance_s)
  return _internal_distance_s();
}
inline void ObjectYield::set_distance_s(double value) {
  _internal_set_distance_s(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectYield.distance_s)
}
inline double ObjectYield::_internal_distance_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_s_;
}
inline void ObjectYield::_internal_set_distance_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = value;
}

// optional .control.common.PointENU fence_point = 2;
inline bool ObjectYield::has_fence_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fence_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& ObjectYield::_internal_fence_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectYield::fence_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.fence_point)
  return _internal_fence_point();
}
inline void ObjectYield::unsafe_arena_set_allocated_fence_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_point_);
  }
  _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectYield.fence_point)
}
inline ::control::common::PointENU* ObjectYield::release_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* released = _impl_.fence_point_;
  _impl_.fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* ObjectYield::unsafe_arena_release_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectYield.fence_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = _impl_.fence_point_;
  _impl_.fence_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectYield::_internal_mutable_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fence_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.fence_point_;
}
inline ::control::common::PointENU* ObjectYield::mutable_fence_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::common::PointENU* _msg = _internal_mutable_fence_point();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectYield.fence_point)
  return _msg;
}
inline void ObjectYield::set_allocated_fence_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectYield.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectYield::has_fence_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ObjectYield::clear_fence_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fence_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ObjectYield::fence_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectYield::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectYield.fence_heading)
}
inline double ObjectYield::_internal_fence_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fence_heading_;
}
inline void ObjectYield::_internal_set_fence_heading(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fence_heading_ = value;
}

// optional double time_buffer = 4;
inline bool ObjectYield::has_time_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ObjectYield::clear_time_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_buffer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ObjectYield::time_buffer() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.time_buffer)
  return _internal_time_buffer();
}
inline void ObjectYield::set_time_buffer(double value) {
  _internal_set_time_buffer(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectYield.time_buffer)
}
inline double ObjectYield::_internal_time_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_buffer_;
}
inline void ObjectYield::_internal_set_time_buffer(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_buffer_ = value;
}

// -------------------------------------------------------------------

// ObjectFollow

// optional double distance_s = 1;
inline bool ObjectFollow::has_distance_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectFollow::clear_distance_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ObjectFollow::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectFollow.distance_s)
  return _internal_distance_s();
}
inline void ObjectFollow::set_distance_s(double value) {
  _internal_set_distance_s(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectFollow.distance_s)
}
inline double ObjectFollow::_internal_distance_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_s_;
}
inline void ObjectFollow::_internal_set_distance_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = value;
}

// optional .control.common.PointENU fence_point = 2;
inline bool ObjectFollow::has_fence_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fence_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& ObjectFollow::_internal_fence_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectFollow::fence_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectFollow.fence_point)
  return _internal_fence_point();
}
inline void ObjectFollow::unsafe_arena_set_allocated_fence_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_point_);
  }
  _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectFollow.fence_point)
}
inline ::control::common::PointENU* ObjectFollow::release_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* released = _impl_.fence_point_;
  _impl_.fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* ObjectFollow::unsafe_arena_release_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectFollow.fence_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = _impl_.fence_point_;
  _impl_.fence_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectFollow::_internal_mutable_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fence_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.fence_point_;
}
inline ::control::common::PointENU* ObjectFollow::mutable_fence_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::common::PointENU* _msg = _internal_mutable_fence_point();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectFollow.fence_point)
  return _msg;
}
inline void ObjectFollow::set_allocated_fence_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectFollow.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectFollow::has_fence_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ObjectFollow::clear_fence_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fence_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ObjectFollow::fence_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectFollow.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectFollow::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectFollow.fence_heading)
}
inline double ObjectFollow::_internal_fence_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fence_heading_;
}
inline void ObjectFollow::_internal_set_fence_heading(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fence_heading_ = value;
}

// -------------------------------------------------------------------

// ObjectOvertake

// optional double distance_s = 1;
inline bool ObjectOvertake::has_distance_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectOvertake::clear_distance_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ObjectOvertake::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.distance_s)
  return _internal_distance_s();
}
inline void ObjectOvertake::set_distance_s(double value) {
  _internal_set_distance_s(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectOvertake.distance_s)
}
inline double ObjectOvertake::_internal_distance_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_s_;
}
inline void ObjectOvertake::_internal_set_distance_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_s_ = value;
}

// optional .control.common.PointENU fence_point = 2;
inline bool ObjectOvertake::has_fence_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fence_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& ObjectOvertake::_internal_fence_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectOvertake::fence_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.fence_point)
  return _internal_fence_point();
}
inline void ObjectOvertake::unsafe_arena_set_allocated_fence_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_point_);
  }
  _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectOvertake.fence_point)
}
inline ::control::common::PointENU* ObjectOvertake::release_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* released = _impl_.fence_point_;
  _impl_.fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* ObjectOvertake::unsafe_arena_release_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectOvertake.fence_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = _impl_.fence_point_;
  _impl_.fence_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectOvertake::_internal_mutable_fence_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fence_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.fence_point_;
}
inline ::control::common::PointENU* ObjectOvertake::mutable_fence_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::common::PointENU* _msg = _internal_mutable_fence_point();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectOvertake.fence_point)
  return _msg;
}
inline void ObjectOvertake::set_allocated_fence_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fence_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectOvertake.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectOvertake::has_fence_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ObjectOvertake::clear_fence_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fence_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ObjectOvertake::fence_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectOvertake::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectOvertake.fence_heading)
}
inline double ObjectOvertake::_internal_fence_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fence_heading_;
}
inline void ObjectOvertake::_internal_set_fence_heading(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fence_heading_ = value;
}

// optional double time_buffer = 4;
inline bool ObjectOvertake::has_time_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ObjectOvertake::clear_time_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_buffer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ObjectOvertake::time_buffer() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.time_buffer)
  return _internal_time_buffer();
}
inline void ObjectOvertake::set_time_buffer(double value) {
  _internal_set_time_buffer(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectOvertake.time_buffer)
}
inline double ObjectOvertake::_internal_time_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_buffer_;
}
inline void ObjectOvertake::_internal_set_time_buffer(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_buffer_ = value;
}

// -------------------------------------------------------------------

// ObjectSidePass

// optional .control.planning.ObjectSidePass.Type type = 1;
inline bool ObjectSidePass::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ObjectSidePass::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::control::planning::ObjectSidePass_Type ObjectSidePass::type() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectSidePass.type)
  return _internal_type();
}
inline void ObjectSidePass::set_type(::control::planning::ObjectSidePass_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectSidePass.type)
}
inline ::control::planning::ObjectSidePass_Type ObjectSidePass::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::ObjectSidePass_Type>(_impl_.type_);
}
inline void ObjectSidePass::_internal_set_type(::control::planning::ObjectSidePass_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::ObjectSidePass_Type_IsValid(value));
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// ObjectAvoid

// -------------------------------------------------------------------

// ObjectStatus

// optional .control.planning.ObjectMotionType motion_type = 1;
inline bool ObjectStatus::has_motion_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.motion_type_ != nullptr);
  return value;
}
inline void ObjectStatus::clear_motion_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.motion_type_ != nullptr) _impl_.motion_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning::ObjectMotionType& ObjectStatus::_internal_motion_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::ObjectMotionType* p = _impl_.motion_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::ObjectMotionType&>(::control::planning::_ObjectMotionType_default_instance_);
}
inline const ::control::planning::ObjectMotionType& ObjectStatus::motion_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStatus.motion_type)
  return _internal_motion_type();
}
inline void ObjectStatus::unsafe_arena_set_allocated_motion_type(::control::planning::ObjectMotionType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.motion_type_);
  }
  _impl_.motion_type_ = reinterpret_cast<::control::planning::ObjectMotionType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectStatus.motion_type)
}
inline ::control::planning::ObjectMotionType* ObjectStatus::release_motion_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning::ObjectMotionType* released = _impl_.motion_type_;
  _impl_.motion_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::ObjectMotionType* ObjectStatus::unsafe_arena_release_motion_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectStatus.motion_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning::ObjectMotionType* temp = _impl_.motion_type_;
  _impl_.motion_type_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectMotionType* ObjectStatus::_internal_mutable_motion_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.motion_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectMotionType>(GetArena());
    _impl_.motion_type_ = reinterpret_cast<::control::planning::ObjectMotionType*>(p);
  }
  return _impl_.motion_type_;
}
inline ::control::planning::ObjectMotionType* ObjectStatus::mutable_motion_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::planning::ObjectMotionType* _msg = _internal_mutable_motion_type();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStatus.motion_type)
  return _msg;
}
inline void ObjectStatus::set_allocated_motion_type(::control::planning::ObjectMotionType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.motion_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.motion_type_ = reinterpret_cast<::control::planning::ObjectMotionType*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectStatus.motion_type)
}

// optional .control.planning.ObjectDecisionType decision_type = 2;
inline bool ObjectStatus::has_decision_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.decision_type_ != nullptr);
  return value;
}
inline void ObjectStatus::clear_decision_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.decision_type_ != nullptr) _impl_.decision_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning::ObjectDecisionType& ObjectStatus::_internal_decision_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::ObjectDecisionType* p = _impl_.decision_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::ObjectDecisionType&>(::control::planning::_ObjectDecisionType_default_instance_);
}
inline const ::control::planning::ObjectDecisionType& ObjectStatus::decision_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStatus.decision_type)
  return _internal_decision_type();
}
inline void ObjectStatus::unsafe_arena_set_allocated_decision_type(::control::planning::ObjectDecisionType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.decision_type_);
  }
  _impl_.decision_type_ = reinterpret_cast<::control::planning::ObjectDecisionType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectStatus.decision_type)
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::release_decision_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisionType* released = _impl_.decision_type_;
  _impl_.decision_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::unsafe_arena_release_decision_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectStatus.decision_type)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisionType* temp = _impl_.decision_type_;
  _impl_.decision_type_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::_internal_mutable_decision_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.decision_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectDecisionType>(GetArena());
    _impl_.decision_type_ = reinterpret_cast<::control::planning::ObjectDecisionType*>(p);
  }
  return _impl_.decision_type_;
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::mutable_decision_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::planning::ObjectDecisionType* _msg = _internal_mutable_decision_type();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStatus.decision_type)
  return _msg;
}
inline void ObjectStatus::set_allocated_decision_type(::control::planning::ObjectDecisionType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.decision_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.decision_type_ = reinterpret_cast<::control::planning::ObjectDecisionType*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectStatus.decision_type)
}

// -------------------------------------------------------------------

// ObjectStatic

// -------------------------------------------------------------------

// ObjectDynamic

// -------------------------------------------------------------------

// ObjectMotionType

// .control.planning.ObjectStatic static = 1;
inline bool ObjectMotionType::has_static_() const {
  return motion_tag_case() == kStatic;
}
inline bool ObjectMotionType::_internal_has_static_() const {
  return motion_tag_case() == kStatic;
}
inline void ObjectMotionType::set_has_static_() {
  _impl_._oneof_case_[0] = kStatic;
}
inline void ObjectMotionType::clear_static_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (motion_tag_case() == kStatic) {
    if (GetArena() == nullptr) {
      delete _impl_.motion_tag_.static__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.motion_tag_.static__);
    }
    clear_has_motion_tag();
  }
}
inline ::control::planning::ObjectStatic* ObjectMotionType::release_static_() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectMotionType.static)
  if (motion_tag_case() == kStatic) {
    clear_has_motion_tag();
    auto* temp = _impl_.motion_tag_.static__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectStatic& ObjectMotionType::_internal_static_() const {
  return motion_tag_case() == kStatic ? *_impl_.motion_tag_.static__ : reinterpret_cast<::control::planning::ObjectStatic&>(::control::planning::_ObjectStatic_default_instance_);
}
inline const ::control::planning::ObjectStatic& ObjectMotionType::static_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectMotionType.static)
  return _internal_static_();
}
inline ::control::planning::ObjectStatic* ObjectMotionType::unsafe_arena_release_static_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectMotionType.static)
  if (motion_tag_case() == kStatic) {
    clear_has_motion_tag();
    auto* temp = _impl_.motion_tag_.static__;
    _impl_.motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectMotionType::unsafe_arena_set_allocated_static_(::control::planning::ObjectStatic* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_motion_tag();
  if (value) {
    set_has_static_();
    _impl_.motion_tag_.static__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectMotionType.static)
}
inline ::control::planning::ObjectStatic* ObjectMotionType::_internal_mutable_static_() {
  if (motion_tag_case() != kStatic) {
    clear_motion_tag();
    set_has_static_();
    _impl_.motion_tag_.static__ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectStatic>(GetArena());
  }
  return _impl_.motion_tag_.static__;
}
inline ::control::planning::ObjectStatic* ObjectMotionType::mutable_static_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectStatic* _msg = _internal_mutable_static_();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectMotionType.static)
  return _msg;
}

// .control.planning.ObjectDynamic dynamic = 2;
inline bool ObjectMotionType::has_dynamic() const {
  return motion_tag_case() == kDynamic;
}
inline bool ObjectMotionType::_internal_has_dynamic() const {
  return motion_tag_case() == kDynamic;
}
inline void ObjectMotionType::set_has_dynamic() {
  _impl_._oneof_case_[0] = kDynamic;
}
inline void ObjectMotionType::clear_dynamic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (motion_tag_case() == kDynamic) {
    if (GetArena() == nullptr) {
      delete _impl_.motion_tag_.dynamic_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.motion_tag_.dynamic_);
    }
    clear_has_motion_tag();
  }
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::release_dynamic() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectMotionType.dynamic)
  if (motion_tag_case() == kDynamic) {
    clear_has_motion_tag();
    auto* temp = _impl_.motion_tag_.dynamic_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectDynamic& ObjectMotionType::_internal_dynamic() const {
  return motion_tag_case() == kDynamic ? *_impl_.motion_tag_.dynamic_ : reinterpret_cast<::control::planning::ObjectDynamic&>(::control::planning::_ObjectDynamic_default_instance_);
}
inline const ::control::planning::ObjectDynamic& ObjectMotionType::dynamic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectMotionType.dynamic)
  return _internal_dynamic();
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::unsafe_arena_release_dynamic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectMotionType.dynamic)
  if (motion_tag_case() == kDynamic) {
    clear_has_motion_tag();
    auto* temp = _impl_.motion_tag_.dynamic_;
    _impl_.motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectMotionType::unsafe_arena_set_allocated_dynamic(::control::planning::ObjectDynamic* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_motion_tag();
  if (value) {
    set_has_dynamic();
    _impl_.motion_tag_.dynamic_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectMotionType.dynamic)
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::_internal_mutable_dynamic() {
  if (motion_tag_case() != kDynamic) {
    clear_motion_tag();
    set_has_dynamic();
    _impl_.motion_tag_.dynamic_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectDynamic>(GetArena());
  }
  return _impl_.motion_tag_.dynamic_;
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::mutable_dynamic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectDynamic* _msg = _internal_mutable_dynamic();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectMotionType.dynamic)
  return _msg;
}

inline bool ObjectMotionType::has_motion_tag() const {
  return motion_tag_case() != MOTION_TAG_NOT_SET;
}
inline void ObjectMotionType::clear_has_motion_tag() {
  _impl_._oneof_case_[0] = MOTION_TAG_NOT_SET;
}
inline ObjectMotionType::MotionTagCase ObjectMotionType::motion_tag_case() const {
  return ObjectMotionType::MotionTagCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecisionType

// .control.planning.ObjectIgnore ignore = 1;
inline bool ObjectDecisionType::has_ignore() const {
  return object_tag_case() == kIgnore;
}
inline bool ObjectDecisionType::_internal_has_ignore() const {
  return object_tag_case() == kIgnore;
}
inline void ObjectDecisionType::set_has_ignore() {
  _impl_._oneof_case_[0] = kIgnore;
}
inline void ObjectDecisionType::clear_ignore() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kIgnore) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.ignore_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.ignore_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::release_ignore() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.ignore)
  if (object_tag_case() == kIgnore) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.ignore_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectIgnore& ObjectDecisionType::_internal_ignore() const {
  return object_tag_case() == kIgnore ? *_impl_.object_tag_.ignore_ : reinterpret_cast<::control::planning::ObjectIgnore&>(::control::planning::_ObjectIgnore_default_instance_);
}
inline const ::control::planning::ObjectIgnore& ObjectDecisionType::ignore() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.ignore)
  return _internal_ignore();
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::unsafe_arena_release_ignore() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.ignore)
  if (object_tag_case() == kIgnore) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.ignore_;
    _impl_.object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_ignore(::control::planning::ObjectIgnore* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_ignore();
    _impl_.object_tag_.ignore_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.ignore)
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::_internal_mutable_ignore() {
  if (object_tag_case() != kIgnore) {
    clear_object_tag();
    set_has_ignore();
    _impl_.object_tag_.ignore_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectIgnore>(GetArena());
  }
  return _impl_.object_tag_.ignore_;
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::mutable_ignore() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectIgnore* _msg = _internal_mutable_ignore();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.ignore)
  return _msg;
}

// .control.planning.ObjectStop stop = 2;
inline bool ObjectDecisionType::has_stop() const {
  return object_tag_case() == kStop;
}
inline bool ObjectDecisionType::_internal_has_stop() const {
  return object_tag_case() == kStop;
}
inline void ObjectDecisionType::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void ObjectDecisionType::clear_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kStop) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.stop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.stop_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectStop* ObjectDecisionType::release_stop() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.stop)
  if (object_tag_case() == kStop) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectStop& ObjectDecisionType::_internal_stop() const {
  return object_tag_case() == kStop ? *_impl_.object_tag_.stop_ : reinterpret_cast<::control::planning::ObjectStop&>(::control::planning::_ObjectStop_default_instance_);
}
inline const ::control::planning::ObjectStop& ObjectDecisionType::stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.stop)
  return _internal_stop();
}
inline ::control::planning::ObjectStop* ObjectDecisionType::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.stop)
  if (object_tag_case() == kStop) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.stop_;
    _impl_.object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_stop(::control::planning::ObjectStop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_stop();
    _impl_.object_tag_.stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.stop)
}
inline ::control::planning::ObjectStop* ObjectDecisionType::_internal_mutable_stop() {
  if (object_tag_case() != kStop) {
    clear_object_tag();
    set_has_stop();
    _impl_.object_tag_.stop_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectStop>(GetArena());
  }
  return _impl_.object_tag_.stop_;
}
inline ::control::planning::ObjectStop* ObjectDecisionType::mutable_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectStop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.stop)
  return _msg;
}

// .control.planning.ObjectFollow follow = 3;
inline bool ObjectDecisionType::has_follow() const {
  return object_tag_case() == kFollow;
}
inline bool ObjectDecisionType::_internal_has_follow() const {
  return object_tag_case() == kFollow;
}
inline void ObjectDecisionType::set_has_follow() {
  _impl_._oneof_case_[0] = kFollow;
}
inline void ObjectDecisionType::clear_follow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kFollow) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.follow_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.follow_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::release_follow() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.follow)
  if (object_tag_case() == kFollow) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.follow_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectFollow& ObjectDecisionType::_internal_follow() const {
  return object_tag_case() == kFollow ? *_impl_.object_tag_.follow_ : reinterpret_cast<::control::planning::ObjectFollow&>(::control::planning::_ObjectFollow_default_instance_);
}
inline const ::control::planning::ObjectFollow& ObjectDecisionType::follow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.follow)
  return _internal_follow();
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::unsafe_arena_release_follow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.follow)
  if (object_tag_case() == kFollow) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.follow_;
    _impl_.object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_follow(::control::planning::ObjectFollow* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_follow();
    _impl_.object_tag_.follow_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.follow)
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::_internal_mutable_follow() {
  if (object_tag_case() != kFollow) {
    clear_object_tag();
    set_has_follow();
    _impl_.object_tag_.follow_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectFollow>(GetArena());
  }
  return _impl_.object_tag_.follow_;
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::mutable_follow() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectFollow* _msg = _internal_mutable_follow();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.follow)
  return _msg;
}

// .control.planning.ObjectYield yield = 4;
inline bool ObjectDecisionType::has_yield() const {
  return object_tag_case() == kYield;
}
inline bool ObjectDecisionType::_internal_has_yield() const {
  return object_tag_case() == kYield;
}
inline void ObjectDecisionType::set_has_yield() {
  _impl_._oneof_case_[0] = kYield;
}
inline void ObjectDecisionType::clear_yield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kYield) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.yield_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.yield_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectYield* ObjectDecisionType::release_yield() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.yield)
  if (object_tag_case() == kYield) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.yield_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectYield& ObjectDecisionType::_internal_yield() const {
  return object_tag_case() == kYield ? *_impl_.object_tag_.yield_ : reinterpret_cast<::control::planning::ObjectYield&>(::control::planning::_ObjectYield_default_instance_);
}
inline const ::control::planning::ObjectYield& ObjectDecisionType::yield() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.yield)
  return _internal_yield();
}
inline ::control::planning::ObjectYield* ObjectDecisionType::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.yield)
  if (object_tag_case() == kYield) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.yield_;
    _impl_.object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_yield(::control::planning::ObjectYield* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_yield();
    _impl_.object_tag_.yield_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.yield)
}
inline ::control::planning::ObjectYield* ObjectDecisionType::_internal_mutable_yield() {
  if (object_tag_case() != kYield) {
    clear_object_tag();
    set_has_yield();
    _impl_.object_tag_.yield_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectYield>(GetArena());
  }
  return _impl_.object_tag_.yield_;
}
inline ::control::planning::ObjectYield* ObjectDecisionType::mutable_yield() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectYield* _msg = _internal_mutable_yield();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.yield)
  return _msg;
}

// .control.planning.ObjectOvertake overtake = 5;
inline bool ObjectDecisionType::has_overtake() const {
  return object_tag_case() == kOvertake;
}
inline bool ObjectDecisionType::_internal_has_overtake() const {
  return object_tag_case() == kOvertake;
}
inline void ObjectDecisionType::set_has_overtake() {
  _impl_._oneof_case_[0] = kOvertake;
}
inline void ObjectDecisionType::clear_overtake() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kOvertake) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.overtake_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.overtake_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::release_overtake() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.overtake)
  if (object_tag_case() == kOvertake) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.overtake_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectOvertake& ObjectDecisionType::_internal_overtake() const {
  return object_tag_case() == kOvertake ? *_impl_.object_tag_.overtake_ : reinterpret_cast<::control::planning::ObjectOvertake&>(::control::planning::_ObjectOvertake_default_instance_);
}
inline const ::control::planning::ObjectOvertake& ObjectDecisionType::overtake() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.overtake)
  return _internal_overtake();
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::unsafe_arena_release_overtake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.overtake)
  if (object_tag_case() == kOvertake) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.overtake_;
    _impl_.object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_overtake(::control::planning::ObjectOvertake* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_overtake();
    _impl_.object_tag_.overtake_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.overtake)
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::_internal_mutable_overtake() {
  if (object_tag_case() != kOvertake) {
    clear_object_tag();
    set_has_overtake();
    _impl_.object_tag_.overtake_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectOvertake>(GetArena());
  }
  return _impl_.object_tag_.overtake_;
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::mutable_overtake() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectOvertake* _msg = _internal_mutable_overtake();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.overtake)
  return _msg;
}

// .control.planning.ObjectNudge nudge = 6;
inline bool ObjectDecisionType::has_nudge() const {
  return object_tag_case() == kNudge;
}
inline bool ObjectDecisionType::_internal_has_nudge() const {
  return object_tag_case() == kNudge;
}
inline void ObjectDecisionType::set_has_nudge() {
  _impl_._oneof_case_[0] = kNudge;
}
inline void ObjectDecisionType::clear_nudge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kNudge) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.nudge_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.nudge_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::release_nudge() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.nudge)
  if (object_tag_case() == kNudge) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.nudge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectNudge& ObjectDecisionType::_internal_nudge() const {
  return object_tag_case() == kNudge ? *_impl_.object_tag_.nudge_ : reinterpret_cast<::control::planning::ObjectNudge&>(::control::planning::_ObjectNudge_default_instance_);
}
inline const ::control::planning::ObjectNudge& ObjectDecisionType::nudge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.nudge)
  return _internal_nudge();
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::unsafe_arena_release_nudge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.nudge)
  if (object_tag_case() == kNudge) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.nudge_;
    _impl_.object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_nudge(::control::planning::ObjectNudge* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_nudge();
    _impl_.object_tag_.nudge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.nudge)
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::_internal_mutable_nudge() {
  if (object_tag_case() != kNudge) {
    clear_object_tag();
    set_has_nudge();
    _impl_.object_tag_.nudge_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectNudge>(GetArena());
  }
  return _impl_.object_tag_.nudge_;
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::mutable_nudge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectNudge* _msg = _internal_mutable_nudge();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.nudge)
  return _msg;
}

// .control.planning.ObjectAvoid avoid = 7;
inline bool ObjectDecisionType::has_avoid() const {
  return object_tag_case() == kAvoid;
}
inline bool ObjectDecisionType::_internal_has_avoid() const {
  return object_tag_case() == kAvoid;
}
inline void ObjectDecisionType::set_has_avoid() {
  _impl_._oneof_case_[0] = kAvoid;
}
inline void ObjectDecisionType::clear_avoid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kAvoid) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.avoid_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.avoid_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::release_avoid() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.avoid)
  if (object_tag_case() == kAvoid) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.avoid_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectAvoid& ObjectDecisionType::_internal_avoid() const {
  return object_tag_case() == kAvoid ? *_impl_.object_tag_.avoid_ : reinterpret_cast<::control::planning::ObjectAvoid&>(::control::planning::_ObjectAvoid_default_instance_);
}
inline const ::control::planning::ObjectAvoid& ObjectDecisionType::avoid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.avoid)
  return _internal_avoid();
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::unsafe_arena_release_avoid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.avoid)
  if (object_tag_case() == kAvoid) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.avoid_;
    _impl_.object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_avoid(::control::planning::ObjectAvoid* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_avoid();
    _impl_.object_tag_.avoid_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.avoid)
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::_internal_mutable_avoid() {
  if (object_tag_case() != kAvoid) {
    clear_object_tag();
    set_has_avoid();
    _impl_.object_tag_.avoid_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectAvoid>(GetArena());
  }
  return _impl_.object_tag_.avoid_;
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::mutable_avoid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectAvoid* _msg = _internal_mutable_avoid();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.avoid)
  return _msg;
}

// .control.planning.ObjectSidePass side_pass = 8;
inline bool ObjectDecisionType::has_side_pass() const {
  return object_tag_case() == kSidePass;
}
inline bool ObjectDecisionType::_internal_has_side_pass() const {
  return object_tag_case() == kSidePass;
}
inline void ObjectDecisionType::set_has_side_pass() {
  _impl_._oneof_case_[0] = kSidePass;
}
inline void ObjectDecisionType::clear_side_pass() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (object_tag_case() == kSidePass) {
    if (GetArena() == nullptr) {
      delete _impl_.object_tag_.side_pass_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.object_tag_.side_pass_);
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::release_side_pass() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.side_pass)
  if (object_tag_case() == kSidePass) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.side_pass_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectSidePass& ObjectDecisionType::_internal_side_pass() const {
  return object_tag_case() == kSidePass ? *_impl_.object_tag_.side_pass_ : reinterpret_cast<::control::planning::ObjectSidePass&>(::control::planning::_ObjectSidePass_default_instance_);
}
inline const ::control::planning::ObjectSidePass& ObjectDecisionType::side_pass() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.side_pass)
  return _internal_side_pass();
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::unsafe_arena_release_side_pass() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.side_pass)
  if (object_tag_case() == kSidePass) {
    clear_has_object_tag();
    auto* temp = _impl_.object_tag_.side_pass_;
    _impl_.object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_side_pass(::control::planning::ObjectSidePass* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_object_tag();
  if (value) {
    set_has_side_pass();
    _impl_.object_tag_.side_pass_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.side_pass)
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::_internal_mutable_side_pass() {
  if (object_tag_case() != kSidePass) {
    clear_object_tag();
    set_has_side_pass();
    _impl_.object_tag_.side_pass_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectSidePass>(GetArena());
  }
  return _impl_.object_tag_.side_pass_;
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::mutable_side_pass() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::ObjectSidePass* _msg = _internal_mutable_side_pass();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.side_pass)
  return _msg;
}

inline bool ObjectDecisionType::has_object_tag() const {
  return object_tag_case() != OBJECT_TAG_NOT_SET;
}
inline void ObjectDecisionType::clear_has_object_tag() {
  _impl_._oneof_case_[0] = OBJECT_TAG_NOT_SET;
}
inline ObjectDecisionType::ObjectTagCase ObjectDecisionType::object_tag_case() const {
  return ObjectDecisionType::ObjectTagCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecision

// optional string id = 1;
inline bool ObjectDecision::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ObjectDecision::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObjectDecision::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecision.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ObjectDecision::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning.ObjectDecision.id)
}
inline std::string* ObjectDecision::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecision.id)
  return _s;
}
inline const std::string& ObjectDecision::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ObjectDecision::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ObjectDecision::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ObjectDecision::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecision.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ObjectDecision::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectDecision.id)
}

// optional int32 perception_id = 2;
inline bool ObjectDecision::has_perception_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ObjectDecision::clear_perception_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.perception_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ObjectDecision::perception_id() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecision.perception_id)
  return _internal_perception_id();
}
inline void ObjectDecision::set_perception_id(::int32_t value) {
  _internal_set_perception_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.ObjectDecision.perception_id)
}
inline ::int32_t ObjectDecision::_internal_perception_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.perception_id_;
}
inline void ObjectDecision::_internal_set_perception_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.perception_id_ = value;
}

// repeated .control.planning.ObjectDecisionType object_decision = 3;
inline int ObjectDecision::_internal_object_decision_size() const {
  return _internal_object_decision().size();
}
inline int ObjectDecision::object_decision_size() const {
  return _internal_object_decision_size();
}
inline void ObjectDecision::clear_object_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_decision_.Clear();
}
inline ::control::planning::ObjectDecisionType* ObjectDecision::mutable_object_decision(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecision.object_decision)
  return _internal_mutable_object_decision()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>* ObjectDecision::mutable_object_decision()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning.ObjectDecision.object_decision)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_object_decision();
}
inline const ::control::planning::ObjectDecisionType& ObjectDecision::object_decision(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecision.object_decision)
  return _internal_object_decision().Get(index);
}
inline ::control::planning::ObjectDecisionType* ObjectDecision::add_object_decision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning::ObjectDecisionType* _add = _internal_mutable_object_decision()->Add();
  // @@protoc_insertion_point(field_add:control.planning.ObjectDecision.object_decision)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>& ObjectDecision::object_decision() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning.ObjectDecision.object_decision)
  return _internal_object_decision();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>&
ObjectDecision::_internal_object_decision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.object_decision_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecisionType>*
ObjectDecision::_internal_mutable_object_decision() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.object_decision_;
}

// -------------------------------------------------------------------

// ObjectDecisions

// repeated .control.planning.ObjectDecision decision = 1;
inline int ObjectDecisions::_internal_decision_size() const {
  return _internal_decision().size();
}
inline int ObjectDecisions::decision_size() const {
  return _internal_decision_size();
}
inline void ObjectDecisions::clear_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.decision_.Clear();
}
inline ::control::planning::ObjectDecision* ObjectDecisions::mutable_decision(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisions.decision)
  return _internal_mutable_decision()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>* ObjectDecisions::mutable_decision()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning.ObjectDecisions.decision)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_decision();
}
inline const ::control::planning::ObjectDecision& ObjectDecisions::decision(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisions.decision)
  return _internal_decision().Get(index);
}
inline ::control::planning::ObjectDecision* ObjectDecisions::add_decision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning::ObjectDecision* _add = _internal_mutable_decision()->Add();
  // @@protoc_insertion_point(field_add:control.planning.ObjectDecisions.decision)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>& ObjectDecisions::decision() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning.ObjectDecisions.decision)
  return _internal_decision();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>&
ObjectDecisions::_internal_decision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.decision_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::ObjectDecision>*
ObjectDecisions::_internal_mutable_decision() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.decision_;
}

// -------------------------------------------------------------------

// MainStop

// optional .control.planning.StopReasonCode reason_code = 1;
inline bool MainStop::has_reason_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MainStop::clear_reason_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_code_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::control::planning::StopReasonCode MainStop::reason_code() const {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.reason_code)
  return _internal_reason_code();
}
inline void MainStop::set_reason_code(::control::planning::StopReasonCode value) {
  _internal_set_reason_code(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning.MainStop.reason_code)
}
inline ::control::planning::StopReasonCode MainStop::_internal_reason_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::StopReasonCode>(_impl_.reason_code_);
}
inline void MainStop::_internal_set_reason_code(::control::planning::StopReasonCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::StopReasonCode_IsValid(value));
  _impl_.reason_code_ = value;
}

// optional string reason = 2;
inline bool MainStop::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MainStop::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MainStop::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MainStop::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning.MainStop.reason)
}
inline std::string* MainStop::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:control.planning.MainStop.reason)
  return _s;
}
inline const std::string& MainStop::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void MainStop::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* MainStop::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* MainStop::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainStop.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MainStop::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainStop.reason)
}

// optional .control.common.PointENU stop_point = 3;
inline bool MainStop::has_stop_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& MainStop::_internal_stop_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.stop_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& MainStop::stop_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.stop_point)
  return _internal_stop_point();
}
inline void MainStop::unsafe_arena_set_allocated_stop_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_point_);
  }
  _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainStop.stop_point)
}
inline ::control::common::PointENU* MainStop::release_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::common::PointENU* released = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* MainStop::unsafe_arena_release_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainStop.stop_point)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::common::PointENU* temp = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* MainStop::_internal_mutable_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.stop_point_;
}
inline ::control::common::PointENU* MainStop::mutable_stop_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::common::PointENU* _msg = _internal_mutable_stop_point();
  // @@protoc_insertion_point(field_mutable:control.planning.MainStop.stop_point)
  return _msg;
}
inline void MainStop::set_allocated_stop_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainStop.stop_point)
}

// optional double stop_heading = 4;
inline bool MainStop::has_stop_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MainStop::clear_stop_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double MainStop::stop_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.stop_heading)
  return _internal_stop_heading();
}
inline void MainStop::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.MainStop.stop_heading)
}
inline double MainStop::_internal_stop_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_heading_;
}
inline void MainStop::_internal_set_stop_heading(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_heading_ = value;
}

// -------------------------------------------------------------------

// EmergencyStopHardBrake

// -------------------------------------------------------------------

// EmergencyStopCruiseToStop

// -------------------------------------------------------------------

// MainEmergencyStop

// optional .control.planning.MainEmergencyStop.ReasonCode reason_code = 1;
inline bool MainEmergencyStop::has_reason_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MainEmergencyStop::clear_reason_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_code_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::control::planning::MainEmergencyStop_ReasonCode MainEmergencyStop::reason_code() const {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.reason_code)
  return _internal_reason_code();
}
inline void MainEmergencyStop::set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value) {
  _internal_set_reason_code(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.MainEmergencyStop.reason_code)
}
inline ::control::planning::MainEmergencyStop_ReasonCode MainEmergencyStop::_internal_reason_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::MainEmergencyStop_ReasonCode>(_impl_.reason_code_);
}
inline void MainEmergencyStop::_internal_set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::MainEmergencyStop_ReasonCode_IsValid(value));
  _impl_.reason_code_ = value;
}

// optional string reason = 2;
inline bool MainEmergencyStop::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MainEmergencyStop::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MainEmergencyStop::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MainEmergencyStop::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning.MainEmergencyStop.reason)
}
inline std::string* MainEmergencyStop::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:control.planning.MainEmergencyStop.reason)
  return _s;
}
inline const std::string& MainEmergencyStop::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void MainEmergencyStop::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* MainEmergencyStop::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* MainEmergencyStop::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainEmergencyStop.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MainEmergencyStop::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainEmergencyStop.reason)
}

// .control.planning.EmergencyStopHardBrake hard_brake = 3;
inline bool MainEmergencyStop::has_hard_brake() const {
  return task_case() == kHardBrake;
}
inline bool MainEmergencyStop::_internal_has_hard_brake() const {
  return task_case() == kHardBrake;
}
inline void MainEmergencyStop::set_has_hard_brake() {
  _impl_._oneof_case_[0] = kHardBrake;
}
inline void MainEmergencyStop::clear_hard_brake() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kHardBrake) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.hard_brake_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.hard_brake_);
    }
    clear_has_task();
  }
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::release_hard_brake() {
  // @@protoc_insertion_point(field_release:control.planning.MainEmergencyStop.hard_brake)
  if (task_case() == kHardBrake) {
    clear_has_task();
    auto* temp = _impl_.task_.hard_brake_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.hard_brake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::EmergencyStopHardBrake& MainEmergencyStop::_internal_hard_brake() const {
  return task_case() == kHardBrake ? *_impl_.task_.hard_brake_ : reinterpret_cast<::control::planning::EmergencyStopHardBrake&>(::control::planning::_EmergencyStopHardBrake_default_instance_);
}
inline const ::control::planning::EmergencyStopHardBrake& MainEmergencyStop::hard_brake() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.hard_brake)
  return _internal_hard_brake();
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::unsafe_arena_release_hard_brake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainEmergencyStop.hard_brake)
  if (task_case() == kHardBrake) {
    clear_has_task();
    auto* temp = _impl_.task_.hard_brake_;
    _impl_.task_.hard_brake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainEmergencyStop::unsafe_arena_set_allocated_hard_brake(::control::planning::EmergencyStopHardBrake* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_hard_brake();
    _impl_.task_.hard_brake_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainEmergencyStop.hard_brake)
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::_internal_mutable_hard_brake() {
  if (task_case() != kHardBrake) {
    clear_task();
    set_has_hard_brake();
    _impl_.task_.hard_brake_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::EmergencyStopHardBrake>(GetArena());
  }
  return _impl_.task_.hard_brake_;
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::mutable_hard_brake() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::EmergencyStopHardBrake* _msg = _internal_mutable_hard_brake();
  // @@protoc_insertion_point(field_mutable:control.planning.MainEmergencyStop.hard_brake)
  return _msg;
}

// .control.planning.EmergencyStopCruiseToStop cruise_to_stop = 4;
inline bool MainEmergencyStop::has_cruise_to_stop() const {
  return task_case() == kCruiseToStop;
}
inline bool MainEmergencyStop::_internal_has_cruise_to_stop() const {
  return task_case() == kCruiseToStop;
}
inline void MainEmergencyStop::set_has_cruise_to_stop() {
  _impl_._oneof_case_[0] = kCruiseToStop;
}
inline void MainEmergencyStop::clear_cruise_to_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kCruiseToStop) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.cruise_to_stop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.cruise_to_stop_);
    }
    clear_has_task();
  }
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::release_cruise_to_stop() {
  // @@protoc_insertion_point(field_release:control.planning.MainEmergencyStop.cruise_to_stop)
  if (task_case() == kCruiseToStop) {
    clear_has_task();
    auto* temp = _impl_.task_.cruise_to_stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.cruise_to_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::EmergencyStopCruiseToStop& MainEmergencyStop::_internal_cruise_to_stop() const {
  return task_case() == kCruiseToStop ? *_impl_.task_.cruise_to_stop_ : reinterpret_cast<::control::planning::EmergencyStopCruiseToStop&>(::control::planning::_EmergencyStopCruiseToStop_default_instance_);
}
inline const ::control::planning::EmergencyStopCruiseToStop& MainEmergencyStop::cruise_to_stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.cruise_to_stop)
  return _internal_cruise_to_stop();
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::unsafe_arena_release_cruise_to_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainEmergencyStop.cruise_to_stop)
  if (task_case() == kCruiseToStop) {
    clear_has_task();
    auto* temp = _impl_.task_.cruise_to_stop_;
    _impl_.task_.cruise_to_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainEmergencyStop::unsafe_arena_set_allocated_cruise_to_stop(::control::planning::EmergencyStopCruiseToStop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_cruise_to_stop();
    _impl_.task_.cruise_to_stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainEmergencyStop.cruise_to_stop)
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::_internal_mutable_cruise_to_stop() {
  if (task_case() != kCruiseToStop) {
    clear_task();
    set_has_cruise_to_stop();
    _impl_.task_.cruise_to_stop_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::EmergencyStopCruiseToStop>(GetArena());
  }
  return _impl_.task_.cruise_to_stop_;
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::mutable_cruise_to_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::EmergencyStopCruiseToStop* _msg = _internal_mutable_cruise_to_stop();
  // @@protoc_insertion_point(field_mutable:control.planning.MainEmergencyStop.cruise_to_stop)
  return _msg;
}

inline bool MainEmergencyStop::has_task() const {
  return task_case() != TASK_NOT_SET;
}
inline void MainEmergencyStop::clear_has_task() {
  _impl_._oneof_case_[0] = TASK_NOT_SET;
}
inline MainEmergencyStop::TaskCase MainEmergencyStop::task_case() const {
  return MainEmergencyStop::TaskCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MainCruise

// -------------------------------------------------------------------

// MainChangeLane

// optional .control.planning.MainChangeLane.Type type = 1;
inline bool MainChangeLane::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MainChangeLane::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::control::planning::MainChangeLane_Type MainChangeLane::type() const {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.type)
  return _internal_type();
}
inline void MainChangeLane::set_type(::control::planning::MainChangeLane_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning.MainChangeLane.type)
}
inline ::control::planning::MainChangeLane_Type MainChangeLane::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::MainChangeLane_Type>(_impl_.type_);
}
inline void MainChangeLane::_internal_set_type(::control::planning::MainChangeLane_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::MainChangeLane_Type_IsValid(value));
  _impl_.type_ = value;
}

// repeated .control.planning.TargetLane default_lane = 2;
inline int MainChangeLane::_internal_default_lane_size() const {
  return _internal_default_lane().size();
}
inline int MainChangeLane::default_lane_size() const {
  return _internal_default_lane_size();
}
inline void MainChangeLane::clear_default_lane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_lane_.Clear();
}
inline ::control::planning::TargetLane* MainChangeLane::mutable_default_lane(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning.MainChangeLane.default_lane)
  return _internal_mutable_default_lane()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>* MainChangeLane::mutable_default_lane()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning.MainChangeLane.default_lane)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_default_lane();
}
inline const ::control::planning::TargetLane& MainChangeLane::default_lane(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.default_lane)
  return _internal_default_lane().Get(index);
}
inline ::control::planning::TargetLane* MainChangeLane::add_default_lane() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning::TargetLane* _add = _internal_mutable_default_lane()->Add();
  // @@protoc_insertion_point(field_add:control.planning.MainChangeLane.default_lane)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>& MainChangeLane::default_lane() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning.MainChangeLane.default_lane)
  return _internal_default_lane();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>&
MainChangeLane::_internal_default_lane() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_lane_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>*
MainChangeLane::_internal_mutable_default_lane() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.default_lane_;
}

// optional .control.planning.MainStop default_lane_stop = 3;
inline bool MainChangeLane::has_default_lane_stop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.default_lane_stop_ != nullptr);
  return value;
}
inline void MainChangeLane::clear_default_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.default_lane_stop_ != nullptr) _impl_.default_lane_stop_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning::MainStop& MainChangeLane::_internal_default_lane_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::MainStop* p = _impl_.default_lane_stop_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::MainStop&>(::control::planning::_MainStop_default_instance_);
}
inline const ::control::planning::MainStop& MainChangeLane::default_lane_stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.default_lane_stop)
  return _internal_default_lane_stop();
}
inline void MainChangeLane::unsafe_arena_set_allocated_default_lane_stop(::control::planning::MainStop* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.default_lane_stop_);
  }
  _impl_.default_lane_stop_ = reinterpret_cast<::control::planning::MainStop*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainChangeLane.default_lane_stop)
}
inline ::control::planning::MainStop* MainChangeLane::release_default_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning::MainStop* released = _impl_.default_lane_stop_;
  _impl_.default_lane_stop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::MainStop* MainChangeLane::unsafe_arena_release_default_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainChangeLane.default_lane_stop)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning::MainStop* temp = _impl_.default_lane_stop_;
  _impl_.default_lane_stop_ = nullptr;
  return temp;
}
inline ::control::planning::MainStop* MainChangeLane::_internal_mutable_default_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.default_lane_stop_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::MainStop>(GetArena());
    _impl_.default_lane_stop_ = reinterpret_cast<::control::planning::MainStop*>(p);
  }
  return _impl_.default_lane_stop_;
}
inline ::control::planning::MainStop* MainChangeLane::mutable_default_lane_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::planning::MainStop* _msg = _internal_mutable_default_lane_stop();
  // @@protoc_insertion_point(field_mutable:control.planning.MainChangeLane.default_lane_stop)
  return _msg;
}
inline void MainChangeLane::set_allocated_default_lane_stop(::control::planning::MainStop* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.default_lane_stop_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.default_lane_stop_ = reinterpret_cast<::control::planning::MainStop*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainChangeLane.default_lane_stop)
}

// optional .control.planning.MainStop target_lane_stop = 4;
inline bool MainChangeLane::has_target_lane_stop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_lane_stop_ != nullptr);
  return value;
}
inline void MainChangeLane::clear_target_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_lane_stop_ != nullptr) _impl_.target_lane_stop_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning::MainStop& MainChangeLane::_internal_target_lane_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::MainStop* p = _impl_.target_lane_stop_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::MainStop&>(::control::planning::_MainStop_default_instance_);
}
inline const ::control::planning::MainStop& MainChangeLane::target_lane_stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.target_lane_stop)
  return _internal_target_lane_stop();
}
inline void MainChangeLane::unsafe_arena_set_allocated_target_lane_stop(::control::planning::MainStop* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_lane_stop_);
  }
  _impl_.target_lane_stop_ = reinterpret_cast<::control::planning::MainStop*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainChangeLane.target_lane_stop)
}
inline ::control::planning::MainStop* MainChangeLane::release_target_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::MainStop* released = _impl_.target_lane_stop_;
  _impl_.target_lane_stop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::MainStop* MainChangeLane::unsafe_arena_release_target_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainChangeLane.target_lane_stop)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::MainStop* temp = _impl_.target_lane_stop_;
  _impl_.target_lane_stop_ = nullptr;
  return temp;
}
inline ::control::planning::MainStop* MainChangeLane::_internal_mutable_target_lane_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_lane_stop_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::MainStop>(GetArena());
    _impl_.target_lane_stop_ = reinterpret_cast<::control::planning::MainStop*>(p);
  }
  return _impl_.target_lane_stop_;
}
inline ::control::planning::MainStop* MainChangeLane::mutable_target_lane_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::planning::MainStop* _msg = _internal_mutable_target_lane_stop();
  // @@protoc_insertion_point(field_mutable:control.planning.MainChangeLane.target_lane_stop)
  return _msg;
}
inline void MainChangeLane::set_allocated_target_lane_stop(::control::planning::MainStop* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.target_lane_stop_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_lane_stop_ = reinterpret_cast<::control::planning::MainStop*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainChangeLane.target_lane_stop)
}

// -------------------------------------------------------------------

// MainMissionComplete

// optional .control.common.PointENU stop_point = 1;
inline bool MainMissionComplete::has_stop_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& MainMissionComplete::_internal_stop_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.stop_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& MainMissionComplete::stop_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainMissionComplete.stop_point)
  return _internal_stop_point();
}
inline void MainMissionComplete::unsafe_arena_set_allocated_stop_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_point_);
  }
  _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainMissionComplete.stop_point)
}
inline ::control::common::PointENU* MainMissionComplete::release_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* released = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* MainMissionComplete::unsafe_arena_release_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainMissionComplete.stop_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* MainMissionComplete::_internal_mutable_stop_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.stop_point_;
}
inline ::control::common::PointENU* MainMissionComplete::mutable_stop_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::common::PointENU* _msg = _internal_mutable_stop_point();
  // @@protoc_insertion_point(field_mutable:control.planning.MainMissionComplete.stop_point)
  return _msg;
}
inline void MainMissionComplete::set_allocated_stop_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stop_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainMissionComplete.stop_point)
}

// optional double stop_heading = 2;
inline bool MainMissionComplete::has_stop_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MainMissionComplete::clear_stop_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MainMissionComplete::stop_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.MainMissionComplete.stop_heading)
  return _internal_stop_heading();
}
inline void MainMissionComplete::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning.MainMissionComplete.stop_heading)
}
inline double MainMissionComplete::_internal_stop_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_heading_;
}
inline void MainMissionComplete::_internal_set_stop_heading(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_heading_ = value;
}

// -------------------------------------------------------------------

// MainNotReady

// optional string reason = 1;
inline bool MainNotReady::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MainNotReady::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MainNotReady::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainNotReady.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MainNotReady::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning.MainNotReady.reason)
}
inline std::string* MainNotReady::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:control.planning.MainNotReady.reason)
  return _s;
}
inline const std::string& MainNotReady::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void MainNotReady::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* MainNotReady::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* MainNotReady::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.MainNotReady.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MainNotReady::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainNotReady.reason)
}

// -------------------------------------------------------------------

// MainParking

// optional .control.planning.MainParking.ParkingStatus status = 1;
inline bool MainParking::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MainParking::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::control::planning::MainParking_ParkingStatus MainParking::status() const {
  // @@protoc_insertion_point(field_get:control.planning.MainParking.status)
  return _internal_status();
}
inline void MainParking::set_status(::control::planning::MainParking_ParkingStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:control.planning.MainParking.status)
}
inline ::control::planning::MainParking_ParkingStatus MainParking::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning::MainParking_ParkingStatus>(_impl_.status_);
}
inline void MainParking::_internal_set_status(::control::planning::MainParking_ParkingStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning::MainParking_ParkingStatus_IsValid(value));
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// MainDecision

// .control.planning.MainCruise cruise = 1;
inline bool MainDecision::has_cruise() const {
  return task_case() == kCruise;
}
inline bool MainDecision::_internal_has_cruise() const {
  return task_case() == kCruise;
}
inline void MainDecision::set_has_cruise() {
  _impl_._oneof_case_[0] = kCruise;
}
inline void MainDecision::clear_cruise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kCruise) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.cruise_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.cruise_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainCruise* MainDecision::release_cruise() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.cruise)
  if (task_case() == kCruise) {
    clear_has_task();
    auto* temp = _impl_.task_.cruise_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.cruise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainCruise& MainDecision::_internal_cruise() const {
  return task_case() == kCruise ? *_impl_.task_.cruise_ : reinterpret_cast<::control::planning::MainCruise&>(::control::planning::_MainCruise_default_instance_);
}
inline const ::control::planning::MainCruise& MainDecision::cruise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.cruise)
  return _internal_cruise();
}
inline ::control::planning::MainCruise* MainDecision::unsafe_arena_release_cruise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.cruise)
  if (task_case() == kCruise) {
    clear_has_task();
    auto* temp = _impl_.task_.cruise_;
    _impl_.task_.cruise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_cruise(::control::planning::MainCruise* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_cruise();
    _impl_.task_.cruise_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.cruise)
}
inline ::control::planning::MainCruise* MainDecision::_internal_mutable_cruise() {
  if (task_case() != kCruise) {
    clear_task();
    set_has_cruise();
    _impl_.task_.cruise_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainCruise>(GetArena());
  }
  return _impl_.task_.cruise_;
}
inline ::control::planning::MainCruise* MainDecision::mutable_cruise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainCruise* _msg = _internal_mutable_cruise();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.cruise)
  return _msg;
}

// .control.planning.MainStop stop = 2;
inline bool MainDecision::has_stop() const {
  return task_case() == kStop;
}
inline bool MainDecision::_internal_has_stop() const {
  return task_case() == kStop;
}
inline void MainDecision::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void MainDecision::clear_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kStop) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.stop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.stop_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainStop* MainDecision::release_stop() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.stop)
  if (task_case() == kStop) {
    clear_has_task();
    auto* temp = _impl_.task_.stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainStop& MainDecision::_internal_stop() const {
  return task_case() == kStop ? *_impl_.task_.stop_ : reinterpret_cast<::control::planning::MainStop&>(::control::planning::_MainStop_default_instance_);
}
inline const ::control::planning::MainStop& MainDecision::stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.stop)
  return _internal_stop();
}
inline ::control::planning::MainStop* MainDecision::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.stop)
  if (task_case() == kStop) {
    clear_has_task();
    auto* temp = _impl_.task_.stop_;
    _impl_.task_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_stop(::control::planning::MainStop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_stop();
    _impl_.task_.stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.stop)
}
inline ::control::planning::MainStop* MainDecision::_internal_mutable_stop() {
  if (task_case() != kStop) {
    clear_task();
    set_has_stop();
    _impl_.task_.stop_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainStop>(GetArena());
  }
  return _impl_.task_.stop_;
}
inline ::control::planning::MainStop* MainDecision::mutable_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainStop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.stop)
  return _msg;
}

// .control.planning.MainEmergencyStop estop = 3;
inline bool MainDecision::has_estop() const {
  return task_case() == kEstop;
}
inline bool MainDecision::_internal_has_estop() const {
  return task_case() == kEstop;
}
inline void MainDecision::set_has_estop() {
  _impl_._oneof_case_[0] = kEstop;
}
inline void MainDecision::clear_estop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kEstop) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.estop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.estop_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainEmergencyStop* MainDecision::release_estop() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.estop)
  if (task_case() == kEstop) {
    clear_has_task();
    auto* temp = _impl_.task_.estop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.estop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainEmergencyStop& MainDecision::_internal_estop() const {
  return task_case() == kEstop ? *_impl_.task_.estop_ : reinterpret_cast<::control::planning::MainEmergencyStop&>(::control::planning::_MainEmergencyStop_default_instance_);
}
inline const ::control::planning::MainEmergencyStop& MainDecision::estop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.estop)
  return _internal_estop();
}
inline ::control::planning::MainEmergencyStop* MainDecision::unsafe_arena_release_estop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.estop)
  if (task_case() == kEstop) {
    clear_has_task();
    auto* temp = _impl_.task_.estop_;
    _impl_.task_.estop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_estop(::control::planning::MainEmergencyStop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_estop();
    _impl_.task_.estop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.estop)
}
inline ::control::planning::MainEmergencyStop* MainDecision::_internal_mutable_estop() {
  if (task_case() != kEstop) {
    clear_task();
    set_has_estop();
    _impl_.task_.estop_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainEmergencyStop>(GetArena());
  }
  return _impl_.task_.estop_;
}
inline ::control::planning::MainEmergencyStop* MainDecision::mutable_estop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainEmergencyStop* _msg = _internal_mutable_estop();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.estop)
  return _msg;
}

// .control.planning.MainChangeLane change_lane = 4 [deprecated = true];
inline bool MainDecision::has_change_lane() const {
  return task_case() == kChangeLane;
}
inline bool MainDecision::_internal_has_change_lane() const {
  return task_case() == kChangeLane;
}
inline void MainDecision::set_has_change_lane() {
  _impl_._oneof_case_[0] = kChangeLane;
}
inline void MainDecision::clear_change_lane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kChangeLane) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.change_lane_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.change_lane_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainChangeLane* MainDecision::release_change_lane() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.change_lane)
  if (task_case() == kChangeLane) {
    clear_has_task();
    auto* temp = _impl_.task_.change_lane_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainChangeLane& MainDecision::_internal_change_lane() const {
  return task_case() == kChangeLane ? *_impl_.task_.change_lane_ : reinterpret_cast<::control::planning::MainChangeLane&>(::control::planning::_MainChangeLane_default_instance_);
}
inline const ::control::planning::MainChangeLane& MainDecision::change_lane() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.change_lane)
  return _internal_change_lane();
}
inline ::control::planning::MainChangeLane* MainDecision::unsafe_arena_release_change_lane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.change_lane)
  if (task_case() == kChangeLane) {
    clear_has_task();
    auto* temp = _impl_.task_.change_lane_;
    _impl_.task_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_change_lane(::control::planning::MainChangeLane* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_change_lane();
    _impl_.task_.change_lane_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.change_lane)
}
inline ::control::planning::MainChangeLane* MainDecision::_internal_mutable_change_lane() {
  if (task_case() != kChangeLane) {
    clear_task();
    set_has_change_lane();
    _impl_.task_.change_lane_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainChangeLane>(GetArena());
  }
  return _impl_.task_.change_lane_;
}
inline ::control::planning::MainChangeLane* MainDecision::mutable_change_lane() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainChangeLane* _msg = _internal_mutable_change_lane();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.change_lane)
  return _msg;
}

// .control.planning.MainMissionComplete mission_complete = 6;
inline bool MainDecision::has_mission_complete() const {
  return task_case() == kMissionComplete;
}
inline bool MainDecision::_internal_has_mission_complete() const {
  return task_case() == kMissionComplete;
}
inline void MainDecision::set_has_mission_complete() {
  _impl_._oneof_case_[0] = kMissionComplete;
}
inline void MainDecision::clear_mission_complete() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kMissionComplete) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.mission_complete_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.mission_complete_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainMissionComplete* MainDecision::release_mission_complete() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.mission_complete)
  if (task_case() == kMissionComplete) {
    clear_has_task();
    auto* temp = _impl_.task_.mission_complete_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.mission_complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainMissionComplete& MainDecision::_internal_mission_complete() const {
  return task_case() == kMissionComplete ? *_impl_.task_.mission_complete_ : reinterpret_cast<::control::planning::MainMissionComplete&>(::control::planning::_MainMissionComplete_default_instance_);
}
inline const ::control::planning::MainMissionComplete& MainDecision::mission_complete() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.mission_complete)
  return _internal_mission_complete();
}
inline ::control::planning::MainMissionComplete* MainDecision::unsafe_arena_release_mission_complete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.mission_complete)
  if (task_case() == kMissionComplete) {
    clear_has_task();
    auto* temp = _impl_.task_.mission_complete_;
    _impl_.task_.mission_complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_mission_complete(::control::planning::MainMissionComplete* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_mission_complete();
    _impl_.task_.mission_complete_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.mission_complete)
}
inline ::control::planning::MainMissionComplete* MainDecision::_internal_mutable_mission_complete() {
  if (task_case() != kMissionComplete) {
    clear_task();
    set_has_mission_complete();
    _impl_.task_.mission_complete_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainMissionComplete>(GetArena());
  }
  return _impl_.task_.mission_complete_;
}
inline ::control::planning::MainMissionComplete* MainDecision::mutable_mission_complete() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainMissionComplete* _msg = _internal_mutable_mission_complete();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.mission_complete)
  return _msg;
}

// .control.planning.MainNotReady not_ready = 7;
inline bool MainDecision::has_not_ready() const {
  return task_case() == kNotReady;
}
inline bool MainDecision::_internal_has_not_ready() const {
  return task_case() == kNotReady;
}
inline void MainDecision::set_has_not_ready() {
  _impl_._oneof_case_[0] = kNotReady;
}
inline void MainDecision::clear_not_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kNotReady) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.not_ready_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.not_ready_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainNotReady* MainDecision::release_not_ready() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.not_ready)
  if (task_case() == kNotReady) {
    clear_has_task();
    auto* temp = _impl_.task_.not_ready_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.not_ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainNotReady& MainDecision::_internal_not_ready() const {
  return task_case() == kNotReady ? *_impl_.task_.not_ready_ : reinterpret_cast<::control::planning::MainNotReady&>(::control::planning::_MainNotReady_default_instance_);
}
inline const ::control::planning::MainNotReady& MainDecision::not_ready() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.not_ready)
  return _internal_not_ready();
}
inline ::control::planning::MainNotReady* MainDecision::unsafe_arena_release_not_ready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.not_ready)
  if (task_case() == kNotReady) {
    clear_has_task();
    auto* temp = _impl_.task_.not_ready_;
    _impl_.task_.not_ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_not_ready(::control::planning::MainNotReady* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_not_ready();
    _impl_.task_.not_ready_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.not_ready)
}
inline ::control::planning::MainNotReady* MainDecision::_internal_mutable_not_ready() {
  if (task_case() != kNotReady) {
    clear_task();
    set_has_not_ready();
    _impl_.task_.not_ready_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainNotReady>(GetArena());
  }
  return _impl_.task_.not_ready_;
}
inline ::control::planning::MainNotReady* MainDecision::mutable_not_ready() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainNotReady* _msg = _internal_mutable_not_ready();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.not_ready)
  return _msg;
}

// .control.planning.MainParking parking = 8;
inline bool MainDecision::has_parking() const {
  return task_case() == kParking;
}
inline bool MainDecision::_internal_has_parking() const {
  return task_case() == kParking;
}
inline void MainDecision::set_has_parking() {
  _impl_._oneof_case_[0] = kParking;
}
inline void MainDecision::clear_parking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (task_case() == kParking) {
    if (GetArena() == nullptr) {
      delete _impl_.task_.parking_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.task_.parking_);
    }
    clear_has_task();
  }
}
inline ::control::planning::MainParking* MainDecision::release_parking() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.parking)
  if (task_case() == kParking) {
    clear_has_task();
    auto* temp = _impl_.task_.parking_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.task_.parking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainParking& MainDecision::_internal_parking() const {
  return task_case() == kParking ? *_impl_.task_.parking_ : reinterpret_cast<::control::planning::MainParking&>(::control::planning::_MainParking_default_instance_);
}
inline const ::control::planning::MainParking& MainDecision::parking() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.parking)
  return _internal_parking();
}
inline ::control::planning::MainParking* MainDecision::unsafe_arena_release_parking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.parking)
  if (task_case() == kParking) {
    clear_has_task();
    auto* temp = _impl_.task_.parking_;
    _impl_.task_.parking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_parking(::control::planning::MainParking* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_task();
  if (value) {
    set_has_parking();
    _impl_.task_.parking_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.parking)
}
inline ::control::planning::MainParking* MainDecision::_internal_mutable_parking() {
  if (task_case() != kParking) {
    clear_task();
    set_has_parking();
    _impl_.task_.parking_ =
        ::google::protobuf::Message::DefaultConstruct<::control::planning::MainParking>(GetArena());
  }
  return _impl_.task_.parking_;
}
inline ::control::planning::MainParking* MainDecision::mutable_parking() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::control::planning::MainParking* _msg = _internal_mutable_parking();
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.parking)
  return _msg;
}

// repeated .control.planning.TargetLane target_lane = 5 [deprecated = true];
inline int MainDecision::_internal_target_lane_size() const {
  return _internal_target_lane().size();
}
inline int MainDecision::target_lane_size() const {
  return _internal_target_lane_size();
}
inline void MainDecision::clear_target_lane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_lane_.Clear();
}
inline ::control::planning::TargetLane* MainDecision::mutable_target_lane(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.target_lane)
  return _internal_mutable_target_lane()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>* MainDecision::mutable_target_lane()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning.MainDecision.target_lane)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_target_lane();
}
inline const ::control::planning::TargetLane& MainDecision::target_lane(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.target_lane)
  return _internal_target_lane().Get(index);
}
inline ::control::planning::TargetLane* MainDecision::add_target_lane() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning::TargetLane* _add = _internal_mutable_target_lane()->Add();
  // @@protoc_insertion_point(field_add:control.planning.MainDecision.target_lane)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>& MainDecision::target_lane() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning.MainDecision.target_lane)
  return _internal_target_lane();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>&
MainDecision::_internal_target_lane() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_lane_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning::TargetLane>*
MainDecision::_internal_mutable_target_lane() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.target_lane_;
}

inline bool MainDecision::has_task() const {
  return task_case() != TASK_NOT_SET;
}
inline void MainDecision::clear_has_task() {
  _impl_._oneof_case_[0] = TASK_NOT_SET;
}
inline MainDecision::TaskCase MainDecision::task_case() const {
  return MainDecision::TaskCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DecisionResult

// optional .control.planning.MainDecision main_decision = 1;
inline bool DecisionResult::has_main_decision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.main_decision_ != nullptr);
  return value;
}
inline void DecisionResult::clear_main_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.main_decision_ != nullptr) _impl_.main_decision_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning::MainDecision& DecisionResult::_internal_main_decision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::MainDecision* p = _impl_.main_decision_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::MainDecision&>(::control::planning::_MainDecision_default_instance_);
}
inline const ::control::planning::MainDecision& DecisionResult::main_decision() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.DecisionResult.main_decision)
  return _internal_main_decision();
}
inline void DecisionResult::unsafe_arena_set_allocated_main_decision(::control::planning::MainDecision* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.main_decision_);
  }
  _impl_.main_decision_ = reinterpret_cast<::control::planning::MainDecision*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.DecisionResult.main_decision)
}
inline ::control::planning::MainDecision* DecisionResult::release_main_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning::MainDecision* released = _impl_.main_decision_;
  _impl_.main_decision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::MainDecision* DecisionResult::unsafe_arena_release_main_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.DecisionResult.main_decision)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning::MainDecision* temp = _impl_.main_decision_;
  _impl_.main_decision_ = nullptr;
  return temp;
}
inline ::control::planning::MainDecision* DecisionResult::_internal_mutable_main_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.main_decision_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::MainDecision>(GetArena());
    _impl_.main_decision_ = reinterpret_cast<::control::planning::MainDecision*>(p);
  }
  return _impl_.main_decision_;
}
inline ::control::planning::MainDecision* DecisionResult::mutable_main_decision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::planning::MainDecision* _msg = _internal_mutable_main_decision();
  // @@protoc_insertion_point(field_mutable:control.planning.DecisionResult.main_decision)
  return _msg;
}
inline void DecisionResult::set_allocated_main_decision(::control::planning::MainDecision* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.main_decision_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.main_decision_ = reinterpret_cast<::control::planning::MainDecision*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.DecisionResult.main_decision)
}

// optional .control.planning.ObjectDecisions object_decision = 2;
inline bool DecisionResult::has_object_decision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_decision_ != nullptr);
  return value;
}
inline void DecisionResult::clear_object_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_decision_ != nullptr) _impl_.object_decision_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning::ObjectDecisions& DecisionResult::_internal_object_decision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::ObjectDecisions* p = _impl_.object_decision_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::ObjectDecisions&>(::control::planning::_ObjectDecisions_default_instance_);
}
inline const ::control::planning::ObjectDecisions& DecisionResult::object_decision() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.DecisionResult.object_decision)
  return _internal_object_decision();
}
inline void DecisionResult::unsafe_arena_set_allocated_object_decision(::control::planning::ObjectDecisions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_decision_);
  }
  _impl_.object_decision_ = reinterpret_cast<::control::planning::ObjectDecisions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.DecisionResult.object_decision)
}
inline ::control::planning::ObjectDecisions* DecisionResult::release_object_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisions* released = _impl_.object_decision_;
  _impl_.object_decision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::ObjectDecisions* DecisionResult::unsafe_arena_release_object_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.DecisionResult.object_decision)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisions* temp = _impl_.object_decision_;
  _impl_.object_decision_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectDecisions* DecisionResult::_internal_mutable_object_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_decision_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectDecisions>(GetArena());
    _impl_.object_decision_ = reinterpret_cast<::control::planning::ObjectDecisions*>(p);
  }
  return _impl_.object_decision_;
}
inline ::control::planning::ObjectDecisions* DecisionResult::mutable_object_decision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::planning::ObjectDecisions* _msg = _internal_mutable_object_decision();
  // @@protoc_insertion_point(field_mutable:control.planning.DecisionResult.object_decision)
  return _msg;
}
inline void DecisionResult::set_allocated_object_decision(::control::planning::ObjectDecisions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.object_decision_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.object_decision_ = reinterpret_cast<::control::planning::ObjectDecisions*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.DecisionResult.object_decision)
}

// optional .control.common.VehicleSignal vehicle_signal = 3;
inline bool DecisionResult::has_vehicle_signal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_signal_ != nullptr);
  return value;
}
inline const ::control::common::VehicleSignal& DecisionResult::_internal_vehicle_signal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::VehicleSignal* p = _impl_.vehicle_signal_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::VehicleSignal&>(::control::common::_VehicleSignal_default_instance_);
}
inline const ::control::common::VehicleSignal& DecisionResult::vehicle_signal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning.DecisionResult.vehicle_signal)
  return _internal_vehicle_signal();
}
inline void DecisionResult::unsafe_arena_set_allocated_vehicle_signal(::control::common::VehicleSignal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehicle_signal_);
  }
  _impl_.vehicle_signal_ = reinterpret_cast<::control::common::VehicleSignal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.DecisionResult.vehicle_signal)
}
inline ::control::common::VehicleSignal* DecisionResult::release_vehicle_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::common::VehicleSignal* released = _impl_.vehicle_signal_;
  _impl_.vehicle_signal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::VehicleSignal* DecisionResult::unsafe_arena_release_vehicle_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning.DecisionResult.vehicle_signal)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::common::VehicleSignal* temp = _impl_.vehicle_signal_;
  _impl_.vehicle_signal_ = nullptr;
  return temp;
}
inline ::control::common::VehicleSignal* DecisionResult::_internal_mutable_vehicle_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_signal_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::VehicleSignal>(GetArena());
    _impl_.vehicle_signal_ = reinterpret_cast<::control::common::VehicleSignal*>(p);
  }
  return _impl_.vehicle_signal_;
}
inline ::control::common::VehicleSignal* DecisionResult::mutable_vehicle_signal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::control::common::VehicleSignal* _msg = _internal_mutable_vehicle_signal();
  // @@protoc_insertion_point(field_mutable:control.planning.DecisionResult.vehicle_signal)
  return _msg;
}
inline void DecisionResult::set_allocated_vehicle_signal(::control::common::VehicleSignal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehicle_signal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.vehicle_signal_ = reinterpret_cast<::control::common::VehicleSignal*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning.DecisionResult.vehicle_signal)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace planning
}  // namespace control


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::control::planning::ObjectNudge_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning::ObjectNudge_Type>() {
  return ::control::planning::ObjectNudge_Type_descriptor();
}
template <>
struct is_proto_enum<::control::planning::ObjectSidePass_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning::ObjectSidePass_Type>() {
  return ::control::planning::ObjectSidePass_Type_descriptor();
}
template <>
struct is_proto_enum<::control::planning::MainEmergencyStop_ReasonCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning::MainEmergencyStop_ReasonCode>() {
  return ::control::planning::MainEmergencyStop_ReasonCode_descriptor();
}
template <>
struct is_proto_enum<::control::planning::MainChangeLane_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning::MainChangeLane_Type>() {
  return ::control::planning::MainChangeLane_Type_descriptor();
}
template <>
struct is_proto_enum<::control::planning::MainParking_ParkingStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning::MainParking_ParkingStatus>() {
  return ::control::planning::MainParking_ParkingStatus_descriptor();
}
template <>
struct is_proto_enum<::control::planning::StopReasonCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning::StopReasonCode>() {
  return ::control::planning::StopReasonCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fdecision_2eproto_2epb_2eh
