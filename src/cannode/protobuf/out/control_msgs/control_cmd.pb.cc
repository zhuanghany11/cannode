// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: control_msgs/control_cmd.proto
// Protobuf C++ Version: 5.28.0-dev

#include "control_msgs/control_cmd.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace control {

inline constexpr MracAdaptiveGain::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : state_adaptive_gain_{},
        input_adaptive_gain_{},
        nonlinear_adaptive_gain_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR MracAdaptiveGain::MracAdaptiveGain(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MracAdaptiveGainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MracAdaptiveGainDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MracAdaptiveGainDefaultTypeInternal() {}
  union {
    MracAdaptiveGain _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MracAdaptiveGainDefaultTypeInternal _MracAdaptiveGain_default_instance_;

inline constexpr LodmcDebug::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        torq_command_{0},
        torq_feed_forward_{0},
        torq_feed_back_{0},
        dmc_f_roll_{0},
        dmc_f_air_{0},
        dmc_f_slope_{0},
        dmc_f_acc_{0},
        acc_error_{0},
        mass_{0},
        target_acc_{0},
        vehilce_acc_{0},
        vehspeed_{0},
        roadslope_{0},
        target_acc_filter_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LodmcDebug::LodmcDebug(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LodmcDebugDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LodmcDebugDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LodmcDebugDefaultTypeInternal() {}
  union {
    LodmcDebug _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LodmcDebugDefaultTypeInternal _LodmcDebug_default_instance_;

inline constexpr LatencyStats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        controller_time_ms_{},
        total_time_ms_{0},
        total_time_exceeded_{false} {}

template <typename>
PROTOBUF_CONSTEXPR LatencyStats::LatencyStats(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LatencyStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LatencyStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LatencyStatsDefaultTypeInternal() {}
  union {
    LatencyStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LatencyStatsDefaultTypeInternal _LatencyStats_default_instance_;

inline constexpr MracDebug::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        mrac_reference_state_{},
        mrac_state_error_{},
        mrac_adaptive_gain_{nullptr},
        mrac_model_order_{0},
        mrac_reference_saturation_status_{0},
        mrac_control_saturation_status_{0} {}

template <typename>
PROTOBUF_CONSTEXPR MracDebug::MracDebug(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MracDebugDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MracDebugDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MracDebugDefaultTypeInternal() {}
  union {
    MracDebug _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MracDebugDefaultTypeInternal _MracDebug_default_instance_;

inline constexpr SimpleMPCDebug::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        matrix_q_updated_{},
        matrix_r_updated_{},
        current_matched_point_{nullptr},
        current_reference_point_{nullptr},
        preview_reference_point_{nullptr},
        lateral_error_{0},
        ref_heading_{0},
        heading_{0},
        heading_error_{0},
        heading_error_rate_{0},
        lateral_error_rate_{0},
        curvature_{0},
        steer_angle_{0},
        steer_angle_feedforward_{0},
        steer_angle_lateral_contribution_{0},
        steer_angle_lateral_rate_contribution_{0},
        steer_angle_heading_contribution_{0},
        steer_angle_heading_rate_contribution_{0},
        steer_angle_feedback_{0},
        steering_position_{0},
        ref_speed_{0},
        steer_angle_limited_{0},
        station_reference_{0},
        station_error_{0},
        speed_reference_{0},
        speed_error_{0},
        acceleration_reference_{0},
        station_feedback_{0},
        speed_feedback_{0},
        acceleration_cmd_closeloop_{0},
        acceleration_cmd_{0},
        acceleration_lookup_{0},
        speed_lookup_{0},
        calibration_value_{0},
        steer_unconstrained_control_diff_{0},
        steer_angle_feedforward_compensation_{0},
        lateral_acceleration_{0},
        lateral_jerk_{0},
        ref_heading_rate_{0},
        heading_rate_{0},
        ref_heading_acceleration_{0},
        heading_acceleration_{0},
        heading_error_acceleration_{0},
        ref_heading_jerk_{0},
        heading_jerk_{0},
        heading_error_jerk_{0},
        acceleration_feedback_{0},
        acceleration_error_{0},
        jerk_reference_{0},
        jerk_feedback_{0},
        jerk_error_{0},
        lateral_error_feedback_{0},
        heading_error_feedback_{0},
        steer_angle_feedback_augment_{0},
        preview_station_error_{0},
        preview_speed_reference_{0},
        preview_speed_error_{0},
        preview_acceleration_reference_{0},
        vehicle_pitch_{0},
        slope_offset_compensation_{0},
        path_remain_{0},
        acceleration_lookup_offset_{0},
        acceleration_vrf_{0},
        is_full_stop_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SimpleMPCDebug::SimpleMPCDebug(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SimpleMPCDebugDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimpleMPCDebugDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimpleMPCDebugDefaultTypeInternal() {}
  union {
    SimpleMPCDebug _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimpleMPCDebugDefaultTypeInternal _SimpleMPCDebug_default_instance_;

inline constexpr SimpleLongitudinalDebug::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        current_matched_point_{nullptr},
        current_reference_point_{nullptr},
        preview_reference_point_{nullptr},
        station_reference_{0},
        station_error_{0},
        station_error_limited_{0},
        preview_station_error_{0},
        speed_reference_{0},
        speed_error_{0},
        speed_controller_input_limited_{0},
        preview_speed_reference_{0},
        preview_speed_error_{0},
        preview_acceleration_reference_{0},
        acceleration_cmd_closeloop_{0},
        acceleration_cmd_{0},
        acceleration_lookup_{0},
        speed_lookup_{0},
        calibration_value_{0},
        throttle_cmd_{0},
        brake_cmd_{0},
        slope_offset_compensation_{0},
        current_station_{0},
        path_remain_{0},
        pid_saturation_status_{0},
        leadlag_saturation_status_{0},
        speed_offset_{0},
        current_speed_{0},
        acceleration_reference_{0},
        current_acceleration_{0},
        acceleration_error_{0},
        jerk_reference_{0},
        current_jerk_{0},
        jerk_error_{0},
        acceleration_lookup_limit_{0},
        vehicle_pitch_{0},
        current_steer_interval_{0},
        is_full_stop_{false},
        is_epb_brake_{false},
        is_wait_steer_{false},
        is_stop_reason_by_destination_{false},
        is_stop_reason_by_prdestrian_{false},
        is_full_stop_soft_{false},
        is_stop_scenario_{false},
        is_take_off_state_{false},
        stop_acc_cmd_{0},
        gear_location_{static_cast< ::control::canbus::Chassis_GearPosition >(0)},
        stopstate_{0u},
        contraposition_x_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SimpleLongitudinalDebug::SimpleLongitudinalDebug(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SimpleLongitudinalDebugDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimpleLongitudinalDebugDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimpleLongitudinalDebugDefaultTypeInternal() {}
  union {
    SimpleLongitudinalDebug _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimpleLongitudinalDebugDefaultTypeInternal _SimpleLongitudinalDebug_default_instance_;

inline constexpr SimpleLateralDebug::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        current_target_point_{nullptr},
        steer_mrac_debug_{nullptr},
        lateral_error_{0},
        ref_heading_{0},
        heading_{0},
        heading_error_{0},
        heading_error_rate_{0},
        lateral_error_rate_{0},
        curvature_{0},
        steer_angle_{0},
        steer_angle_feedforward_{0},
        steer_angle_lateral_contribution_{0},
        steer_angle_lateral_rate_contribution_{0},
        steer_angle_heading_contribution_{0},
        steer_angle_heading_rate_contribution_{0},
        steer_angle_feedback_{0},
        steering_position_{0},
        ref_speed_{0},
        steer_angle_limited_{0},
        lateral_acceleration_{0},
        lateral_jerk_{0},
        ref_heading_rate_{0},
        heading_rate_{0},
        ref_heading_acceleration_{0},
        heading_acceleration_{0},
        heading_error_acceleration_{0},
        ref_heading_jerk_{0},
        heading_jerk_{0},
        heading_error_jerk_{0},
        lateral_error_feedback_{0},
        heading_error_feedback_{0},
        steer_angle_feedback_augment_{0},
        lateral_centripetal_acceleration_{0},
        steer_mrac_enable_status_{false},
        preview_heading_error_{0},
        preview_pos_curvature_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SimpleLateralDebug::SimpleLateralDebug(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SimpleLateralDebugDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimpleLateralDebugDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimpleLateralDebugDefaultTypeInternal() {}
  union {
    SimpleLateralDebug _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimpleLateralDebugDefaultTypeInternal _SimpleLateralDebug_default_instance_;

inline constexpr Debug::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        simple_lon_debug_{nullptr},
        simple_lat_debug_{nullptr},
        input_debug_{nullptr},
        simple_mpc_debug_{nullptr},
        lodmc_debug_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Debug::Debug(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DebugDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugDefaultTypeInternal() {}
  union {
    Debug _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugDefaultTypeInternal _Debug_default_instance_;

inline constexpr ControlCommand::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        header_{nullptr},
        debug_{nullptr},
        signal_{nullptr},
        latency_stats_{nullptr},
        pad_msg_{nullptr},
        engage_advice_{nullptr},
        throttle_{0},
        brake_{0},
        steering_rate_{0},
        steering_target_{0},
        speed_{0},
        acceleration_{0},
        trajectory_fraction_{0},
        parking_brake_{false},
        reset_model_{false},
        engine_on_off_{false},
        is_in_safe_mode_{false},
        driving_mode_{static_cast< ::control::canbus::Chassis_DrivingMode >(0)},
        gear_location_{static_cast< ::control::canbus::Chassis_GearPosition >(0)},
        left_turn_{false},
        right_turn_{false},
        high_beam_{false},
        low_beam_{false},
        turnsignal_{static_cast< ::control::TurnSignal >(0)},
        door_fl_status_{0},
        epb_cmd_{0u},
        horn_{false},
        vehicle_stop_status_{false},
        arm_enable_{false},
        shovel_enable_{false},
        arm_angle_{0},
        shovel_angle_{0},
        pto_cmd_{0u},
        estop_{false},
        rapid_shake_{false} {}

template <typename>
PROTOBUF_CONSTEXPR ControlCommand::ControlCommand(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ControlCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlCommandDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlCommandDefaultTypeInternal() {}
  union {
    ControlCommand _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlCommandDefaultTypeInternal _ControlCommand_default_instance_;
}  // namespace control
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_control_5fmsgs_2fcontrol_5fcmd_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_control_5fmsgs_2fcontrol_5fcmd_2eproto = nullptr;
const ::uint32_t
    TableStruct_control_5fmsgs_2fcontrol_5fcmd_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::control::LatencyStats, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::LatencyStats, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::LatencyStats, _impl_.total_time_ms_),
        PROTOBUF_FIELD_OFFSET(::control::LatencyStats, _impl_.controller_time_ms_),
        PROTOBUF_FIELD_OFFSET(::control::LatencyStats, _impl_.total_time_exceeded_),
        0,
        ~0u,
        1,
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.header_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.throttle_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.brake_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.steering_rate_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.steering_target_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.parking_brake_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.speed_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.reset_model_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.engine_on_off_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.trajectory_fraction_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.driving_mode_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.gear_location_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.debug_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.signal_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.latency_stats_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.pad_msg_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.engage_advice_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.is_in_safe_mode_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.left_turn_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.right_turn_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.high_beam_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.low_beam_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.horn_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.turnsignal_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.door_fl_status_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.vehicle_stop_status_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.epb_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.pto_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.arm_angle_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.arm_enable_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.shovel_angle_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.shovel_enable_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.estop_),
        PROTOBUF_FIELD_OFFSET(::control::ControlCommand, _impl_.rapid_shake_),
        0,
        6,
        7,
        8,
        9,
        13,
        10,
        11,
        14,
        15,
        12,
        17,
        18,
        1,
        2,
        3,
        4,
        5,
        16,
        19,
        20,
        21,
        22,
        26,
        23,
        24,
        27,
        25,
        32,
        30,
        28,
        31,
        29,
        33,
        34,
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.station_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.station_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.station_error_limited_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.preview_station_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.speed_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.speed_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.speed_controller_input_limited_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.preview_speed_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.preview_speed_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.preview_acceleration_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.acceleration_cmd_closeloop_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.acceleration_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.acceleration_lookup_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.speed_lookup_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.calibration_value_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.throttle_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.brake_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_full_stop_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.slope_offset_compensation_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_station_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.path_remain_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.pid_saturation_status_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.leadlag_saturation_status_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.speed_offset_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_speed_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.acceleration_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.acceleration_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.jerk_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.jerk_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_matched_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_reference_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.preview_reference_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.acceleration_lookup_limit_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.vehicle_pitch_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_epb_brake_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.current_steer_interval_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_wait_steer_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_stop_reason_by_destination_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_stop_reason_by_prdestrian_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_full_stop_soft_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.stop_acc_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.gear_location_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_stop_scenario_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.contraposition_x_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.stopstate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLongitudinalDebug, _impl_.is_take_off_state_),
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        36,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        0,
        1,
        2,
        33,
        34,
        37,
        35,
        38,
        39,
        40,
        41,
        44,
        45,
        42,
        47,
        46,
        43,
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.lateral_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.ref_heading_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_error_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.lateral_error_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.curvature_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_feedforward_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_lateral_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_lateral_rate_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_heading_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_heading_rate_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steering_position_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.ref_speed_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_limited_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.lateral_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.lateral_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.ref_heading_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.ref_heading_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_error_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.ref_heading_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_error_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.lateral_error_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.heading_error_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.current_target_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_angle_feedback_augment_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_mrac_debug_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.steer_mrac_enable_status_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.lateral_centripetal_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.preview_pos_curvature_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleLateralDebug, _impl_.preview_heading_error_),
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        0,
        31,
        1,
        33,
        32,
        35,
        34,
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.lateral_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.ref_heading_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_error_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.lateral_error_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.curvature_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_feedforward_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_lateral_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_lateral_rate_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_heading_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_heading_rate_contribution_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steering_position_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.ref_speed_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_limited_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.station_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.station_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.speed_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.speed_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.is_full_stop_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.station_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.speed_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_cmd_closeloop_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_lookup_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.speed_lookup_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.calibration_value_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_unconstrained_control_diff_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_feedforward_compensation_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.matrix_q_updated_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.matrix_r_updated_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.lateral_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.lateral_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.ref_heading_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_rate_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.ref_heading_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_error_acceleration_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.ref_heading_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_error_jerk_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.jerk_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.jerk_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.jerk_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.lateral_error_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.heading_error_feedback_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.steer_angle_feedback_augment_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.current_matched_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.current_reference_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.preview_reference_point_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.preview_station_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.preview_speed_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.preview_speed_error_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.preview_acceleration_reference_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.vehicle_pitch_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.slope_offset_compensation_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.path_remain_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_lookup_offset_),
        PROTOBUF_FIELD_OFFSET(::control::SimpleMPCDebug, _impl_.acceleration_vrf_),
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        61,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        ~0u,
        ~0u,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        0,
        1,
        2,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_.mrac_model_order_),
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_.mrac_reference_state_),
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_.mrac_state_error_),
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_.mrac_adaptive_gain_),
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_.mrac_reference_saturation_status_),
        PROTOBUF_FIELD_OFFSET(::control::MracDebug, _impl_.mrac_control_saturation_status_),
        1,
        ~0u,
        ~0u,
        0,
        2,
        3,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::control::MracAdaptiveGain, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::MracAdaptiveGain, _impl_.state_adaptive_gain_),
        PROTOBUF_FIELD_OFFSET(::control::MracAdaptiveGain, _impl_.input_adaptive_gain_),
        PROTOBUF_FIELD_OFFSET(::control::MracAdaptiveGain, _impl_.nonlinear_adaptive_gain_),
        PROTOBUF_FIELD_OFFSET(::control::Debug, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::Debug, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::Debug, _impl_.simple_lon_debug_),
        PROTOBUF_FIELD_OFFSET(::control::Debug, _impl_.simple_lat_debug_),
        PROTOBUF_FIELD_OFFSET(::control::Debug, _impl_.input_debug_),
        PROTOBUF_FIELD_OFFSET(::control::Debug, _impl_.simple_mpc_debug_),
        PROTOBUF_FIELD_OFFSET(::control::Debug, _impl_.lodmc_debug_),
        0,
        1,
        2,
        3,
        4,
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.torq_command_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.torq_feed_forward_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.torq_feed_back_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.dmc_f_roll_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.dmc_f_air_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.dmc_f_slope_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.dmc_f_acc_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.acc_error_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.mass_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.target_acc_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.vehilce_acc_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.vehspeed_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.roadslope_),
        PROTOBUF_FIELD_OFFSET(::control::LodmcDebug, _impl_.target_acc_filter_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 11, -1, sizeof(::control::LatencyStats)},
        {14, 57, -1, sizeof(::control::ControlCommand)},
        {92, 148, -1, sizeof(::control::SimpleLongitudinalDebug)},
        {196, 240, -1, sizeof(::control::SimpleLateralDebug)},
        {276, 348, -1, sizeof(::control::SimpleMPCDebug)},
        {412, 426, -1, sizeof(::control::MracDebug)},
        {432, -1, -1, sizeof(::control::MracAdaptiveGain)},
        {443, 456, -1, sizeof(::control::Debug)},
        {461, 483, -1, sizeof(::control::LodmcDebug)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::control::_LatencyStats_default_instance_._instance,
    &::control::_ControlCommand_default_instance_._instance,
    &::control::_SimpleLongitudinalDebug_default_instance_._instance,
    &::control::_SimpleLateralDebug_default_instance_._instance,
    &::control::_SimpleMPCDebug_default_instance_._instance,
    &::control::_MracDebug_default_instance_._instance,
    &::control::_MracAdaptiveGain_default_instance_._instance,
    &::control::_Debug_default_instance_._instance,
    &::control::_LodmcDebug_default_instance_._instance,
};
const char descriptor_table_protodef_control_5fmsgs_2fcontrol_5fcmd_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\036control_msgs/control_cmd.proto\022\007contro"
    "l\032(common_msgs/basic_msgs/drive_state.pr"
    "oto\032#common_msgs/basic_msgs/header.proto"
    "\032&common_msgs/basic_msgs/pnc_point.proto"
    "\032+common_msgs/basic_msgs/vehicle_signal."
    "proto\032&common_msgs/chassis_msgs/chassis."
    "proto\032\036control_msgs/input_debug.proto\032\032c"
    "ontrol_msgs/pad_msg.proto\"^\n\014LatencyStat"
    "s\022\025\n\rtotal_time_ms\030\001 \001(\001\022\032\n\022controller_t"
    "ime_ms\030\002 \003(\001\022\033\n\023total_time_exceeded\030\003 \001("
    "\010\"\243\010\n\016ControlCommand\022&\n\006header\030\001 \001(\0132\026.c"
    "ontrol.common.Header\022\023\n\010throttle\030\002 \001(\001:\001"
    "0\022\020\n\005brake\030\003 \001(\001:\0010\022\030\n\rsteering_rate\030\004 \001"
    "(\001:\0010\022\032\n\017steering_target\030\005 \001(\001:\0010\022\025\n\rpar"
    "king_brake\030\006 \001(\010\022\020\n\005speed\030\007 \001(\001:\0010\022\027\n\014ac"
    "celeration\030\010 \001(\001:\0010\022\027\n\013reset_model\030\t \001(\010"
    "B\002\030\001\022\025\n\rengine_on_off\030\n \001(\010\022\033\n\023trajector"
    "y_fraction\030\013 \001(\001\022=\n\014driving_mode\030\014 \001(\0162#"
    ".control.canbus.Chassis.DrivingModeB\002\030\001\022"
    ";\n\rgear_location\030\r \001(\0162$.control.canbus."
    "Chassis.GearPosition\022\035\n\005debug\030\016 \001(\0132\016.co"
    "ntrol.Debug\022-\n\006signal\030\017 \001(\0132\035.control.co"
    "mmon.VehicleSignal\022,\n\rlatency_stats\030\020 \001("
    "\0132\025.control.LatencyStats\022$\n\007pad_msg\030\021 \001("
    "\0132\023.control.PadMessage\0223\n\rengage_advice\030"
    "\022 \001(\0132\034.control.common.EngageAdvice\022\036\n\017i"
    "s_in_safe_mode\030\023 \001(\010:\005false\022\025\n\tleft_turn"
    "\030\024 \001(\010B\002\030\001\022\026\n\nright_turn\030\025 \001(\010B\002\030\001\022\025\n\thi"
    "gh_beam\030\026 \001(\010B\002\030\001\022\024\n\010low_beam\030\027 \001(\010B\002\030\001\022"
    "\020\n\004horn\030\030 \001(\010B\002\030\001\022+\n\nturnsignal\030\031 \001(\0162\023."
    "control.TurnSignalB\002\030\001\022\026\n\016door_fl_status"
    "\030\032 \001(\005\022\033\n\023vehicle_stop_status\030\033 \001(\010\022\017\n\007e"
    "pb_cmd\030\034 \001(\r\022\017\n\007pto_cmd\030\035 \001(\r\022\024\n\tarm_ang"
    "le\030\036 \001(\001:\0010\022\031\n\narm_enable\030\037 \001(\010:\005false\022\027"
    "\n\014shovel_angle\030  \001(\001:\0010\022\034\n\rshovel_enable"
    "\030! \001(\010:\005false\022\024\n\005estop\030\" \001(\010:\005false\022\032\n\013r"
    "apid_shake\030# \001(\010:\005false\"\324\013\n\027SimpleLongit"
    "udinalDebug\022\031\n\021station_reference\030\001 \001(\001\022\025"
    "\n\rstation_error\030\002 \001(\001\022\035\n\025station_error_l"
    "imited\030\003 \001(\001\022\035\n\025preview_station_error\030\004 "
    "\001(\001\022\027\n\017speed_reference\030\005 \001(\001\022\023\n\013speed_er"
    "ror\030\006 \001(\001\022&\n\036speed_controller_input_limi"
    "ted\030\007 \001(\001\022\037\n\027preview_speed_reference\030\010 \001"
    "(\001\022\033\n\023preview_speed_error\030\t \001(\001\022&\n\036previ"
    "ew_acceleration_reference\030\n \001(\001\022\"\n\032accel"
    "eration_cmd_closeloop\030\013 \001(\001\022\030\n\020accelerat"
    "ion_cmd\030\014 \001(\001\022\033\n\023acceleration_lookup\030\r \001"
    "(\001\022\024\n\014speed_lookup\030\016 \001(\001\022\031\n\021calibration_"
    "value\030\017 \001(\001\022\024\n\014throttle_cmd\030\020 \001(\001\022\021\n\tbra"
    "ke_cmd\030\021 \001(\001\022\024\n\014is_full_stop\030\022 \001(\010\022!\n\031sl"
    "ope_offset_compensation\030\023 \001(\001\022\027\n\017current"
    "_station\030\024 \001(\001\022\023\n\013path_remain\030\025 \001(\001\022\035\n\025p"
    "id_saturation_status\030\026 \001(\005\022!\n\031leadlag_sa"
    "turation_status\030\027 \001(\005\022\024\n\014speed_offset\030\030 "
    "\001(\001\022\025\n\rcurrent_speed\030\031 \001(\001\022\036\n\026accelerati"
    "on_reference\030\032 \001(\001\022\034\n\024current_accelerati"
    "on\030\033 \001(\001\022\032\n\022acceleration_error\030\034 \001(\001\022\026\n\016"
    "jerk_reference\030\035 \001(\001\022\024\n\014current_jerk\030\036 \001"
    "(\001\022\022\n\njerk_error\030\037 \001(\001\022>\n\025current_matche"
    "d_point\030  \001(\0132\037.control.common.Trajector"
    "yPoint\022@\n\027current_reference_point\030! \001(\0132"
    "\037.control.common.TrajectoryPoint\022@\n\027prev"
    "iew_reference_point\030\" \001(\0132\037.control.comm"
    "on.TrajectoryPoint\022!\n\031acceleration_looku"
    "p_limit\030# \001(\001\022\025\n\rvehicle_pitch\030$ \001(\001\022\024\n\014"
    "is_epb_brake\030% \001(\010\022\036\n\026current_steer_inte"
    "rval\030& \001(\001\022\025\n\ris_wait_steer\030\' \001(\010\022%\n\035is_"
    "stop_reason_by_destination\030( \001(\010\022$\n\034is_s"
    "top_reason_by_prdestrian\030) \001(\010\022\031\n\021is_ful"
    "l_stop_soft\030* \001(\010\022\024\n\014stop_acc_cmd\0303 \001(\001\022"
    ";\n\rgear_location\0304 \001(\0162$.control.canbus."
    "Chassis.GearPosition\022\030\n\020is_stop_scenario"
    "\0305 \001(\010\022\030\n\020contraposition_x\0306 \001(\001\022\021\n\tstop"
    "state\0307 \001(\r\022\031\n\021is_take_off_state\0308 \001(\010\"\365"
    "\010\n\022SimpleLateralDebug\022\025\n\rlateral_error\030\001"
    " \001(\001\022\023\n\013ref_heading\030\002 \001(\001\022\017\n\007heading\030\003 \001"
    "(\001\022\025\n\rheading_error\030\004 \001(\001\022\032\n\022heading_err"
    "or_rate\030\005 \001(\001\022\032\n\022lateral_error_rate\030\006 \001("
    "\001\022\021\n\tcurvature\030\007 \001(\001\022\023\n\013steer_angle\030\010 \001("
    "\001\022\037\n\027steer_angle_feedforward\030\t \001(\001\022(\n st"
    "eer_angle_lateral_contribution\030\n \001(\001\022-\n%"
    "steer_angle_lateral_rate_contribution\030\013 "
    "\001(\001\022(\n steer_angle_heading_contribution\030"
    "\014 \001(\001\022-\n%steer_angle_heading_rate_contri"
    "bution\030\r \001(\001\022\034\n\024steer_angle_feedback\030\016 \001"
    "(\001\022\031\n\021steering_position\030\017 \001(\001\022\021\n\tref_spe"
    "ed\030\020 \001(\001\022\033\n\023steer_angle_limited\030\021 \001(\001\022\034\n"
    "\024lateral_acceleration\030\022 \001(\001\022\024\n\014lateral_j"
    "erk\030\023 \001(\001\022\030\n\020ref_heading_rate\030\024 \001(\001\022\024\n\014h"
    "eading_rate\030\025 \001(\001\022 \n\030ref_heading_acceler"
    "ation\030\026 \001(\001\022\034\n\024heading_acceleration\030\027 \001("
    "\001\022\"\n\032heading_error_acceleration\030\030 \001(\001\022\030\n"
    "\020ref_heading_jerk\030\031 \001(\001\022\024\n\014heading_jerk\030"
    "\032 \001(\001\022\032\n\022heading_error_jerk\030\033 \001(\001\022\036\n\026lat"
    "eral_error_feedback\030\034 \001(\001\022\036\n\026heading_err"
    "or_feedback\030\035 \001(\001\022=\n\024current_target_poin"
    "t\030\036 \001(\0132\037.control.common.TrajectoryPoint"
    "\022$\n\034steer_angle_feedback_augment\030\037 \001(\001\022,"
    "\n\020steer_mrac_debug\030  \001(\0132\022.control.MracD"
    "ebug\022 \n\030steer_mrac_enable_status\030! \001(\010\022("
    "\n lateral_centripetal_acceleration\030\" \001(\001"
    "\022\035\n\025preview_pos_curvature\030# \001(\001\022\035\n\025previ"
    "ew_heading_error\030$ \001(\002\"\256\017\n\016SimpleMPCDebu"
    "g\022\025\n\rlateral_error\030\001 \001(\001\022\023\n\013ref_heading\030"
    "\002 \001(\001\022\017\n\007heading\030\003 \001(\001\022\025\n\rheading_error\030"
    "\004 \001(\001\022\032\n\022heading_error_rate\030\005 \001(\001\022\032\n\022lat"
    "eral_error_rate\030\006 \001(\001\022\021\n\tcurvature\030\007 \001(\001"
    "\022\023\n\013steer_angle\030\010 \001(\001\022\037\n\027steer_angle_fee"
    "dforward\030\t \001(\001\022(\n steer_angle_lateral_co"
    "ntribution\030\n \001(\001\022-\n%steer_angle_lateral_"
    "rate_contribution\030\013 \001(\001\022(\n steer_angle_h"
    "eading_contribution\030\014 \001(\001\022-\n%steer_angle"
    "_heading_rate_contribution\030\r \001(\001\022\034\n\024stee"
    "r_angle_feedback\030\016 \001(\001\022\031\n\021steering_posit"
    "ion\030\017 \001(\001\022\021\n\tref_speed\030\020 \001(\001\022\033\n\023steer_an"
    "gle_limited\030\021 \001(\001\022\031\n\021station_reference\030\022"
    " \001(\001\022\025\n\rstation_error\030\023 \001(\001\022\027\n\017speed_ref"
    "erence\030\024 \001(\001\022\023\n\013speed_error\030\025 \001(\001\022\036\n\026acc"
    "eleration_reference\030\026 \001(\001\022\024\n\014is_full_sto"
    "p\030\027 \001(\010\022\030\n\020station_feedback\030\030 \001(\001\022\026\n\016spe"
    "ed_feedback\030\031 \001(\001\022\"\n\032acceleration_cmd_cl"
    "oseloop\030\032 \001(\001\022\030\n\020acceleration_cmd\030\033 \001(\001\022"
    "\033\n\023acceleration_lookup\030\034 \001(\001\022\024\n\014speed_lo"
    "okup\030\035 \001(\001\022\031\n\021calibration_value\030\036 \001(\001\022(\n"
    " steer_unconstrained_control_diff\030\037 \001(\001\022"
    ",\n$steer_angle_feedforward_compensation\030"
    "  \001(\001\022\030\n\020matrix_q_updated\030! \003(\001\022\030\n\020matri"
    "x_r_updated\030\" \003(\001\022\034\n\024lateral_acceleratio"
    "n\030# \001(\001\022\024\n\014lateral_jerk\030$ \001(\001\022\030\n\020ref_hea"
    "ding_rate\030% \001(\001\022\024\n\014heading_rate\030& \001(\001\022 \n"
    "\030ref_heading_acceleration\030\' \001(\001\022\034\n\024headi"
    "ng_acceleration\030( \001(\001\022\"\n\032heading_error_a"
    "cceleration\030) \001(\001\022\030\n\020ref_heading_jerk\030* "
    "\001(\001\022\024\n\014heading_jerk\030+ \001(\001\022\032\n\022heading_err"
    "or_jerk\030, \001(\001\022\035\n\025acceleration_feedback\030-"
    " \001(\001\022\032\n\022acceleration_error\030. \001(\001\022\026\n\016jerk"
    "_reference\030/ \001(\001\022\025\n\rjerk_feedback\0300 \001(\001\022"
    "\022\n\njerk_error\0301 \001(\001\022\036\n\026lateral_error_fee"
    "dback\0302 \001(\001\022\036\n\026heading_error_feedback\0303 "
    "\001(\001\022$\n\034steer_angle_feedback_augment\0304 \001("
    "\001\022>\n\025current_matched_point\0305 \001(\0132\037.contr"
    "ol.common.TrajectoryPoint\022@\n\027current_ref"
    "erence_point\0306 \001(\0132\037.control.common.Traj"
    "ectoryPoint\022@\n\027preview_reference_point\0307"
    " \001(\0132\037.control.common.TrajectoryPoint\022\035\n"
    "\025preview_station_error\0308 \001(\001\022\037\n\027preview_"
    "speed_reference\0309 \001(\001\022\033\n\023preview_speed_e"
    "rror\030: \001(\001\022&\n\036preview_acceleration_refer"
    "ence\030; \001(\001\022\025\n\rvehicle_pitch\030< \001(\001\022!\n\031slo"
    "pe_offset_compensation\030= \001(\001\022\023\n\013path_rem"
    "ain\030> \001(\001\022\"\n\032acceleration_lookup_offset\030"
    "\? \001(\001\022\030\n\020acceleration_vrf\030@ \001(\001\"\346\001\n\tMrac"
    "Debug\022\030\n\020mrac_model_order\030\001 \001(\005\022\034\n\024mrac_"
    "reference_state\030\002 \003(\001\022\030\n\020mrac_state_erro"
    "r\030\003 \003(\001\0225\n\022mrac_adaptive_gain\030\004 \001(\0132\031.co"
    "ntrol.MracAdaptiveGain\022(\n mrac_reference"
    "_saturation_status\030\005 \001(\005\022&\n\036mrac_control"
    "_saturation_status\030\006 \001(\005\"m\n\020MracAdaptive"
    "Gain\022\033\n\023state_adaptive_gain\030\001 \003(\001\022\033\n\023inp"
    "ut_adaptive_gain\030\002 \003(\001\022\037\n\027nonlinear_adap"
    "tive_gain\030\003 \003(\001\"\201\002\n\005Debug\022:\n\020simple_lon_"
    "debug\030\001 \001(\0132 .control.SimpleLongitudinal"
    "Debug\0225\n\020simple_lat_debug\030\002 \001(\0132\033.contro"
    "l.SimpleLateralDebug\022(\n\013input_debug\030\003 \001("
    "\0132\023.control.InputDebug\0221\n\020simple_mpc_deb"
    "ug\030\004 \001(\0132\027.control.SimpleMPCDebug\022(\n\013lod"
    "mc_debug\030\005 \001(\0132\023.control.LodmcDebug\"\256\002\n\n"
    "LodmcDebug\022\024\n\014torq_command\030\001 \001(\001\022\031\n\021torq"
    "_feed_forward\030\002 \001(\001\022\026\n\016torq_feed_back\030\003 "
    "\001(\001\022\022\n\ndmc_f_roll\030\004 \001(\001\022\021\n\tdmc_f_air\030\005 \001"
    "(\001\022\023\n\013dmc_f_slope\030\006 \001(\001\022\021\n\tdmc_f_acc\030\007 \001"
    "(\001\022\021\n\tacc_error\030\010 \001(\001\022\014\n\004mass\030\t \001(\001\022\022\n\nt"
    "arget_acc\030\n \001(\001\022\023\n\013vehilce_acc\030\013 \001(\001\022\020\n\010"
    "vehspeed\030\014 \001(\001\022\021\n\troadslope\030\r \001(\001\022\031\n\021tar"
    "get_acc_filter\030\016 \001(\001*:\n\nTurnSignal\022\r\n\tTU"
    "RN_NONE\020\000\022\r\n\tTURN_LEFT\020\001\022\016\n\nTURN_RIGHT\020\002"
};
static const ::_pbi::DescriptorTable* const descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto_deps[7] =
    {
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fdrive_5fstate_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fheader_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fpnc_5fpoint_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fvehicle_5fsignal_2eproto,
        &::descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        &::descriptor_table_control_5fmsgs_2finput_5fdebug_2eproto,
        &::descriptor_table_control_5fmsgs_2fpad_5fmsg_2eproto,
};
static ::absl::once_flag descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto = {
    false,
    false,
    7040,
    descriptor_table_protodef_control_5fmsgs_2fcontrol_5fcmd_2eproto,
    "control_msgs/control_cmd.proto",
    &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto_once,
    descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto_deps,
    7,
    9,
    schemas,
    file_default_instances,
    TableStruct_control_5fmsgs_2fcontrol_5fcmd_2eproto::offsets,
    file_level_enum_descriptors_control_5fmsgs_2fcontrol_5fcmd_2eproto,
    file_level_service_descriptors_control_5fmsgs_2fcontrol_5fcmd_2eproto,
};
namespace control {
const ::google::protobuf::EnumDescriptor* TurnSignal_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto);
  return file_level_enum_descriptors_control_5fmsgs_2fcontrol_5fcmd_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t TurnSignal_internal_data_[] = {
    196608u, 0u, };
bool TurnSignal_IsValid(int value) {
  return 0 <= value && value <= 2;
}
// ===================================================================

class LatencyStats::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LatencyStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_._has_bits_);
};

LatencyStats::LatencyStats(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.LatencyStats)
}
inline PROTOBUF_NDEBUG_INLINE LatencyStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::LatencyStats& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        controller_time_ms_{visibility, arena, from.controller_time_ms_} {}

LatencyStats::LatencyStats(
    ::google::protobuf::Arena* arena,
    const LatencyStats& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LatencyStats* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, total_time_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, total_time_ms_),
           offsetof(Impl_, total_time_exceeded_) -
               offsetof(Impl_, total_time_ms_) +
               sizeof(Impl_::total_time_exceeded_));

  // @@protoc_insertion_point(copy_constructor:control.LatencyStats)
}
inline PROTOBUF_NDEBUG_INLINE LatencyStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        controller_time_ms_{visibility, arena} {}

inline void LatencyStats::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, total_time_ms_),
           0,
           offsetof(Impl_, total_time_exceeded_) -
               offsetof(Impl_, total_time_ms_) +
               sizeof(Impl_::total_time_exceeded_));
}
LatencyStats::~LatencyStats() {
  // @@protoc_insertion_point(destructor:control.LatencyStats)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LatencyStats::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    LatencyStats::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &LatencyStats::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<LatencyStats>(),
            ::google::protobuf::Message::GetNewImpl<LatencyStats>(),
            ::google::protobuf::Message::GetClearImpl<LatencyStats>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<LatencyStats>(),
                ::google::protobuf::Message::GetSerializeImpl<LatencyStats>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_._cached_size_),
            false,
        },
        &LatencyStats::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* LatencyStats::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> LatencyStats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LatencyStats_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::LatencyStats>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double total_time_ms = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.total_time_ms_)}},
    // repeated double controller_time_ms = 2;
    {::_pbi::TcParser::FastF64R1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.controller_time_ms_)}},
    // optional bool total_time_exceeded = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(LatencyStats, _impl_.total_time_exceeded_), 1>(),
     {24, 1, 0, PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.total_time_exceeded_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double total_time_ms = 1;
    {PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.total_time_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // repeated double controller_time_ms = 2;
    {PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.controller_time_ms_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // optional bool total_time_exceeded = 3;
    {PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.total_time_exceeded_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void LatencyStats::Clear() {
// @@protoc_insertion_point(message_clear_start:control.LatencyStats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.controller_time_ms_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.total_time_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.total_time_exceeded_) -
        reinterpret_cast<char*>(&_impl_.total_time_ms_)) + sizeof(_impl_.total_time_exceeded_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* LatencyStats::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.LatencyStats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double total_time_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_total_time_ms(), target);
  }

  // repeated double controller_time_ms = 2;
  for (int i = 0, n = this->_internal_controller_time_ms_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_controller_time_ms().Get(i), target);
  }

  // optional bool total_time_exceeded = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_total_time_exceeded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.LatencyStats)
  return target;
}

::size_t LatencyStats::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.LatencyStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
   {
    // repeated double controller_time_ms = 2;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_controller_time_ms_size())
      ;
      std::size_t tag_size = std::size_t{1} *
          ::_pbi::FromIntSize(this->_internal_controller_time_ms_size());
      ;
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double total_time_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }
    // optional bool total_time_exceeded = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void LatencyStats::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LatencyStats*>(&to_msg);
  auto& from = static_cast<const LatencyStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.LatencyStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_controller_time_ms()->MergeFrom(from._internal_controller_time_ms());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.total_time_ms_ = from._impl_.total_time_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_time_exceeded_ = from._impl_.total_time_exceeded_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LatencyStats::CopyFrom(const LatencyStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.LatencyStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LatencyStats::InternalSwap(LatencyStats* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.controller_time_ms_.InternalSwap(&other->_impl_.controller_time_ms_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.total_time_exceeded_)
      + sizeof(LatencyStats::_impl_.total_time_exceeded_)
      - PROTOBUF_FIELD_OFFSET(LatencyStats, _impl_.total_time_ms_)>(
          reinterpret_cast<char*>(&_impl_.total_time_ms_),
          reinterpret_cast<char*>(&other->_impl_.total_time_ms_));
}

::google::protobuf::Metadata LatencyStats::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ControlCommand::_Internal {
 public:
  using HasBits =
      decltype(std::declval<ControlCommand>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_._has_bits_);
};

void ControlCommand::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ControlCommand::clear_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.signal_ != nullptr) _impl_.signal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ControlCommand::clear_pad_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pad_msg_ != nullptr) _impl_.pad_msg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ControlCommand::clear_engage_advice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.engage_advice_ != nullptr) _impl_.engage_advice_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
ControlCommand::ControlCommand(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.ControlCommand)
}
inline PROTOBUF_NDEBUG_INLINE ControlCommand::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::ControlCommand& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

ControlCommand::ControlCommand(
    ::google::protobuf::Arena* arena,
    const ControlCommand& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ControlCommand* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::common::Header>(
                              arena, *from._impl_.header_)
                        : nullptr;
  _impl_.debug_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::Debug>(
                              arena, *from._impl_.debug_)
                        : nullptr;
  _impl_.signal_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::control::common::VehicleSignal>(
                              arena, *from._impl_.signal_)
                        : nullptr;
  _impl_.latency_stats_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::control::LatencyStats>(
                              arena, *from._impl_.latency_stats_)
                        : nullptr;
  _impl_.pad_msg_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::Message::CopyConstruct<::control::PadMessage>(
                              arena, *from._impl_.pad_msg_)
                        : nullptr;
  _impl_.engage_advice_ = (cached_has_bits & 0x00000020u) ? ::google::protobuf::Message::CopyConstruct<::control::common::EngageAdvice>(
                              arena, *from._impl_.engage_advice_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, throttle_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, throttle_),
           offsetof(Impl_, rapid_shake_) -
               offsetof(Impl_, throttle_) +
               sizeof(Impl_::rapid_shake_));

  // @@protoc_insertion_point(copy_constructor:control.ControlCommand)
}
inline PROTOBUF_NDEBUG_INLINE ControlCommand::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ControlCommand::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_),
           0,
           offsetof(Impl_, rapid_shake_) -
               offsetof(Impl_, header_) +
               sizeof(Impl_::rapid_shake_));
}
ControlCommand::~ControlCommand() {
  // @@protoc_insertion_point(destructor:control.ControlCommand)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ControlCommand::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.header_;
  delete _impl_.debug_;
  delete _impl_.signal_;
  delete _impl_.latency_stats_;
  delete _impl_.pad_msg_;
  delete _impl_.engage_advice_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    ControlCommand::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &ControlCommand::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<ControlCommand>(),
            ::google::protobuf::Message::GetNewImpl<ControlCommand>(),
            ::google::protobuf::Message::GetClearImpl<ControlCommand>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<ControlCommand>(),
                ::google::protobuf::Message::GetSerializeImpl<ControlCommand>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_._cached_size_),
            false,
        },
        &ControlCommand::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* ControlCommand::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 35, 9, 0, 7> ControlCommand::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_._has_bits_),
    0, // no _extensions_
    35, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    35,  // num_field_entries
    9,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_ControlCommand_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::ControlCommand>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .control.common.Header header = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.header_)}},
    // optional double throttle = 2 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {17, 6, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.throttle_)}},
    // optional double brake = 3 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {25, 7, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.brake_)}},
    // optional double steering_rate = 4 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {33, 8, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.steering_rate_)}},
    // optional double steering_target = 5 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {41, 9, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.steering_target_)}},
    // optional bool parking_brake = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ControlCommand, _impl_.parking_brake_), 13>(),
     {48, 13, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.parking_brake_)}},
    // optional double speed = 7 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {57, 10, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.speed_)}},
    // optional double acceleration = 8 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {65, 11, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.acceleration_)}},
    // optional bool reset_model = 9 [deprecated = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ControlCommand, _impl_.reset_model_), 14>(),
     {72, 14, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.reset_model_)}},
    // optional bool engine_on_off = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ControlCommand, _impl_.engine_on_off_), 15>(),
     {80, 15, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.engine_on_off_)}},
    // optional double trajectory_fraction = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 12, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.trajectory_fraction_)}},
    // optional .control.canbus.Chassis.DrivingMode driving_mode = 12 [deprecated = true];
    {::_pbi::TcParser::FastEr0S1,
     {96, 17, 4, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.driving_mode_)}},
    // optional .control.canbus.Chassis.GearPosition gear_location = 13;
    {::_pbi::TcParser::FastEr0S1,
     {104, 18, 6, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.gear_location_)}},
    // optional .control.Debug debug = 14;
    {::_pbi::TcParser::FastMtS1,
     {114, 1, 1, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.debug_)}},
    // optional .control.common.VehicleSignal signal = 15;
    {::_pbi::TcParser::FastMtS1,
     {122, 2, 2, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.signal_)}},
    // optional .control.LatencyStats latency_stats = 16;
    {::_pbi::TcParser::FastMtS2,
     {386, 3, 3, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.latency_stats_)}},
    // optional .control.PadMessage pad_msg = 17;
    {::_pbi::TcParser::FastMtS2,
     {394, 4, 4, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.pad_msg_)}},
    // optional .control.common.EngageAdvice engage_advice = 18;
    {::_pbi::TcParser::FastMtS2,
     {402, 5, 5, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.engage_advice_)}},
    // optional bool is_in_safe_mode = 19 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {408, 16, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.is_in_safe_mode_)}},
    // optional bool left_turn = 20 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {416, 19, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.left_turn_)}},
    // optional bool right_turn = 21 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {424, 20, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.right_turn_)}},
    // optional bool high_beam = 22 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {432, 21, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.high_beam_)}},
    // optional bool low_beam = 23 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {440, 22, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.low_beam_)}},
    // optional bool horn = 24 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {448, 26, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.horn_)}},
    // optional .control.TurnSignal turnsignal = 25 [deprecated = true];
    {::_pbi::TcParser::FastEr0S2,
     {456, 23, 2, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.turnsignal_)}},
    // optional int32 door_fl_status = 26;
    {::_pbi::TcParser::FastV32S2,
     {464, 24, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.door_fl_status_)}},
    // optional bool vehicle_stop_status = 27;
    {::_pbi::TcParser::FastV8S2,
     {472, 27, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.vehicle_stop_status_)}},
    // optional uint32 epb_cmd = 28;
    {::_pbi::TcParser::FastV32S2,
     {480, 25, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.epb_cmd_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional double arm_angle = 30 [default = 0];
    {::_pbi::TcParser::FastF64S2,
     {497, 30, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.arm_angle_)}},
    // optional bool arm_enable = 31 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {504, 28, 0, PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.arm_enable_)}},
  }}, {{
    33, 0, 1,
    65528, 32,
    65535, 65535
  }}, {{
    // optional .control.common.Header header = 1;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double throttle = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.throttle_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double brake = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.brake_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steering_rate = 4 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.steering_rate_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steering_target = 5 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.steering_target_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool parking_brake = 6;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.parking_brake_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double speed = 7 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.speed_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration = 8 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.acceleration_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool reset_model = 9 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.reset_model_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool engine_on_off = 10;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.engine_on_off_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double trajectory_fraction = 11;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.trajectory_fraction_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.canbus.Chassis.DrivingMode driving_mode = 12 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.driving_mode_), _Internal::kHasBitsOffset + 17, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .control.canbus.Chassis.GearPosition gear_location = 13;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.gear_location_), _Internal::kHasBitsOffset + 18, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .control.Debug debug = 14;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.debug_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.VehicleSignal signal = 15;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.signal_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.LatencyStats latency_stats = 16;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.latency_stats_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.PadMessage pad_msg = 17;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.pad_msg_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.EngageAdvice engage_advice = 18;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.engage_advice_), _Internal::kHasBitsOffset + 5, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool is_in_safe_mode = 19 [default = false];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.is_in_safe_mode_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool left_turn = 20 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.left_turn_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool right_turn = 21 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.right_turn_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool high_beam = 22 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.high_beam_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool low_beam = 23 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.low_beam_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool horn = 24 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.horn_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .control.TurnSignal turnsignal = 25 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.turnsignal_), _Internal::kHasBitsOffset + 23, 8,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional int32 door_fl_status = 26;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.door_fl_status_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool vehicle_stop_status = 27;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.vehicle_stop_status_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 epb_cmd = 28;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.epb_cmd_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 pto_cmd = 29;
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.pto_cmd_), _Internal::kHasBitsOffset + 32, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional double arm_angle = 30 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.arm_angle_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool arm_enable = 31 [default = false];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.arm_enable_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double shovel_angle = 32 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.shovel_angle_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool shovel_enable = 33 [default = false];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.shovel_enable_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool estop = 34 [default = false];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.estop_), _Internal::kHasBitsOffset + 33, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool rapid_shake = 35 [default = false];
    {PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.rapid_shake_), _Internal::kHasBitsOffset + 34, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::common::Header>()},
    {::_pbi::TcParser::GetTable<::control::Debug>()},
    {::_pbi::TcParser::GetTable<::control::common::VehicleSignal>()},
    {::_pbi::TcParser::GetTable<::control::LatencyStats>()},
    {::_pbi::TcParser::GetTable<::control::PadMessage>()},
    {::_pbi::TcParser::GetTable<::control::common::EngageAdvice>()},
    {0, 5},
    {0, 7},
    {0, 3},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void ControlCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:control.ControlCommand)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.debug_ != nullptr);
      _impl_.debug_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.signal_ != nullptr);
      _impl_.signal_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.latency_stats_ != nullptr);
      _impl_.latency_stats_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.pad_msg_ != nullptr);
      _impl_.pad_msg_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.engage_advice_ != nullptr);
      _impl_.engage_advice_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.throttle_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.brake_) -
        reinterpret_cast<char*>(&_impl_.throttle_)) + sizeof(_impl_.brake_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.steering_rate_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.engine_on_off_) -
        reinterpret_cast<char*>(&_impl_.steering_rate_)) + sizeof(_impl_.engine_on_off_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.is_in_safe_mode_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.turnsignal_) -
        reinterpret_cast<char*>(&_impl_.is_in_safe_mode_)) + sizeof(_impl_.turnsignal_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.door_fl_status_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.shovel_angle_) -
        reinterpret_cast<char*>(&_impl_.door_fl_status_)) + sizeof(_impl_.shovel_angle_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.pto_cmd_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rapid_shake_) -
        reinterpret_cast<char*>(&_impl_.pto_cmd_)) + sizeof(_impl_.rapid_shake_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* ControlCommand::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.ControlCommand)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .control.common.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *_impl_.header_, _impl_.header_->GetCachedSize(), target, stream);
  }

  // optional double throttle = 2 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_throttle(), target);
  }

  // optional double brake = 3 [default = 0];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_brake(), target);
  }

  // optional double steering_rate = 4 [default = 0];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_steering_rate(), target);
  }

  // optional double steering_target = 5 [default = 0];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_steering_target(), target);
  }

  // optional bool parking_brake = 6;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_parking_brake(), target);
  }

  // optional double speed = 7 [default = 0];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_speed(), target);
  }

  // optional double acceleration = 8 [default = 0];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_acceleration(), target);
  }

  // optional bool reset_model = 9 [deprecated = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_reset_model(), target);
  }

  // optional bool engine_on_off = 10;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_engine_on_off(), target);
  }

  // optional double trajectory_fraction = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_trajectory_fraction(), target);
  }

  // optional .control.canbus.Chassis.DrivingMode driving_mode = 12 [deprecated = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        12, this->_internal_driving_mode(), target);
  }

  // optional .control.canbus.Chassis.GearPosition gear_location = 13;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        13, this->_internal_gear_location(), target);
  }

  // optional .control.Debug debug = 14;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        14, *_impl_.debug_, _impl_.debug_->GetCachedSize(), target, stream);
  }

  // optional .control.common.VehicleSignal signal = 15;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        15, *_impl_.signal_, _impl_.signal_->GetCachedSize(), target, stream);
  }

  // optional .control.LatencyStats latency_stats = 16;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        16, *_impl_.latency_stats_, _impl_.latency_stats_->GetCachedSize(), target, stream);
  }

  // optional .control.PadMessage pad_msg = 17;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        17, *_impl_.pad_msg_, _impl_.pad_msg_->GetCachedSize(), target, stream);
  }

  // optional .control.common.EngageAdvice engage_advice = 18;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        18, *_impl_.engage_advice_, _impl_.engage_advice_->GetCachedSize(), target, stream);
  }

  // optional bool is_in_safe_mode = 19 [default = false];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this->_internal_is_in_safe_mode(), target);
  }

  // optional bool left_turn = 20 [deprecated = true];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        20, this->_internal_left_turn(), target);
  }

  // optional bool right_turn = 21 [deprecated = true];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        21, this->_internal_right_turn(), target);
  }

  // optional bool high_beam = 22 [deprecated = true];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        22, this->_internal_high_beam(), target);
  }

  // optional bool low_beam = 23 [deprecated = true];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        23, this->_internal_low_beam(), target);
  }

  // optional bool horn = 24 [deprecated = true];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        24, this->_internal_horn(), target);
  }

  // optional .control.TurnSignal turnsignal = 25 [deprecated = true];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        25, this->_internal_turnsignal(), target);
  }

  // optional int32 door_fl_status = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        26, this->_internal_door_fl_status(), target);
  }

  // optional bool vehicle_stop_status = 27;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        27, this->_internal_vehicle_stop_status(), target);
  }

  // optional uint32 epb_cmd = 28;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        28, this->_internal_epb_cmd(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 pto_cmd = 29;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        29, this->_internal_pto_cmd(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional double arm_angle = 30 [default = 0];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        30, this->_internal_arm_angle(), target);
  }

  // optional bool arm_enable = 31 [default = false];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        31, this->_internal_arm_enable(), target);
  }

  // optional double shovel_angle = 32 [default = 0];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        32, this->_internal_shovel_angle(), target);
  }

  // optional bool shovel_enable = 33 [default = false];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        33, this->_internal_shovel_enable(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool estop = 34 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        34, this->_internal_estop(), target);
  }

  // optional bool rapid_shake = 35 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        35, this->_internal_rapid_shake(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.ControlCommand)
  return target;
}

::size_t ControlCommand::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.ControlCommand)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .control.common.Header header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_);
    }
    // optional .control.Debug debug = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.debug_);
    }
    // optional .control.common.VehicleSignal signal = 15;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.signal_);
    }
    // optional .control.LatencyStats latency_stats = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.latency_stats_);
    }
    // optional .control.PadMessage pad_msg = 17;
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pad_msg_);
    }
    // optional .control.common.EngageAdvice engage_advice = 18;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.engage_advice_);
    }
    // optional double throttle = 2 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }
    // optional double brake = 3 [default = 0];
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double steering_rate = 4 [default = 0];
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double steering_target = 5 [default = 0];
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional double speed = 7 [default = 0];
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }
    // optional double acceleration = 8 [default = 0];
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }
    // optional double trajectory_fraction = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 9;
    }
    // optional bool parking_brake = 6;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2;
    }
    // optional bool reset_model = 9 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2;
    }
    // optional bool engine_on_off = 10;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool is_in_safe_mode = 19 [default = false];
    if (cached_has_bits & 0x00010000u) {
      total_size += 3;
    }
    // optional .control.canbus.Chassis.DrivingMode driving_mode = 12 [deprecated = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_driving_mode());
    }
    // optional .control.canbus.Chassis.GearPosition gear_location = 13;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_gear_location());
    }
    // optional bool left_turn = 20 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 3;
    }
    // optional bool right_turn = 21 [deprecated = true];
    if (cached_has_bits & 0x00100000u) {
      total_size += 3;
    }
    // optional bool high_beam = 22 [deprecated = true];
    if (cached_has_bits & 0x00200000u) {
      total_size += 3;
    }
    // optional bool low_beam = 23 [deprecated = true];
    if (cached_has_bits & 0x00400000u) {
      total_size += 3;
    }
    // optional .control.TurnSignal turnsignal = 25 [deprecated = true];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_turnsignal());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 door_fl_status = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_door_fl_status());
    }
    // optional uint32 epb_cmd = 28;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_epb_cmd());
    }
    // optional bool horn = 24 [deprecated = true];
    if (cached_has_bits & 0x04000000u) {
      total_size += 3;
    }
    // optional bool vehicle_stop_status = 27;
    if (cached_has_bits & 0x08000000u) {
      total_size += 3;
    }
    // optional bool arm_enable = 31 [default = false];
    if (cached_has_bits & 0x10000000u) {
      total_size += 3;
    }
    // optional bool shovel_enable = 33 [default = false];
    if (cached_has_bits & 0x20000000u) {
      total_size += 3;
    }
    // optional double arm_angle = 30 [default = 0];
    if (cached_has_bits & 0x40000000u) {
      total_size += 10;
    }
    // optional double shovel_angle = 32 [default = 0];
    if (cached_has_bits & 0x80000000u) {
      total_size += 10;
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 pto_cmd = 29;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_pto_cmd());
    }
    // optional bool estop = 34 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 3;
    }
    // optional bool rapid_shake = 35 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 3;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void ControlCommand::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ControlCommand*>(&to_msg);
  auto& from = static_cast<const ControlCommand&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.ControlCommand)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.header_ != nullptr);
      if (_this->_impl_.header_ == nullptr) {
        _this->_impl_.header_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::Header>(arena, *from._impl_.header_);
      } else {
        _this->_impl_.header_->MergeFrom(*from._impl_.header_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.debug_ != nullptr);
      if (_this->_impl_.debug_ == nullptr) {
        _this->_impl_.debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::Debug>(arena, *from._impl_.debug_);
      } else {
        _this->_impl_.debug_->MergeFrom(*from._impl_.debug_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.signal_ != nullptr);
      if (_this->_impl_.signal_ == nullptr) {
        _this->_impl_.signal_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::VehicleSignal>(arena, *from._impl_.signal_);
      } else {
        _this->_impl_.signal_->MergeFrom(*from._impl_.signal_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.latency_stats_ != nullptr);
      if (_this->_impl_.latency_stats_ == nullptr) {
        _this->_impl_.latency_stats_ =
            ::google::protobuf::Message::CopyConstruct<::control::LatencyStats>(arena, *from._impl_.latency_stats_);
      } else {
        _this->_impl_.latency_stats_->MergeFrom(*from._impl_.latency_stats_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.pad_msg_ != nullptr);
      if (_this->_impl_.pad_msg_ == nullptr) {
        _this->_impl_.pad_msg_ =
            ::google::protobuf::Message::CopyConstruct<::control::PadMessage>(arena, *from._impl_.pad_msg_);
      } else {
        _this->_impl_.pad_msg_->MergeFrom(*from._impl_.pad_msg_);
      }
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(from._impl_.engage_advice_ != nullptr);
      if (_this->_impl_.engage_advice_ == nullptr) {
        _this->_impl_.engage_advice_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::EngageAdvice>(arena, *from._impl_.engage_advice_);
      } else {
        _this->_impl_.engage_advice_->MergeFrom(*from._impl_.engage_advice_);
      }
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.throttle_ = from._impl_.throttle_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.brake_ = from._impl_.brake_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.steering_rate_ = from._impl_.steering_rate_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.steering_target_ = from._impl_.steering_target_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.acceleration_ = from._impl_.acceleration_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.trajectory_fraction_ = from._impl_.trajectory_fraction_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.parking_brake_ = from._impl_.parking_brake_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.reset_model_ = from._impl_.reset_model_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.engine_on_off_ = from._impl_.engine_on_off_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.is_in_safe_mode_ = from._impl_.is_in_safe_mode_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.driving_mode_ = from._impl_.driving_mode_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.gear_location_ = from._impl_.gear_location_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.left_turn_ = from._impl_.left_turn_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.right_turn_ = from._impl_.right_turn_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.high_beam_ = from._impl_.high_beam_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.low_beam_ = from._impl_.low_beam_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.turnsignal_ = from._impl_.turnsignal_;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.door_fl_status_ = from._impl_.door_fl_status_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.epb_cmd_ = from._impl_.epb_cmd_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.horn_ = from._impl_.horn_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.vehicle_stop_status_ = from._impl_.vehicle_stop_status_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.arm_enable_ = from._impl_.arm_enable_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.shovel_enable_ = from._impl_.shovel_enable_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.arm_angle_ = from._impl_.arm_angle_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.shovel_angle_ = from._impl_.shovel_angle_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pto_cmd_ = from._impl_.pto_cmd_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.estop_ = from._impl_.estop_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rapid_shake_ = from._impl_.rapid_shake_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ControlCommand::CopyFrom(const ControlCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.ControlCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ControlCommand::InternalSwap(ControlCommand* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.rapid_shake_)
      + sizeof(ControlCommand::_impl_.rapid_shake_)
      - PROTOBUF_FIELD_OFFSET(ControlCommand, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::google::protobuf::Metadata ControlCommand::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SimpleLongitudinalDebug::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SimpleLongitudinalDebug>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_._has_bits_);
};

void SimpleLongitudinalDebug::clear_current_matched_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_matched_point_ != nullptr) _impl_.current_matched_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SimpleLongitudinalDebug::clear_current_reference_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_reference_point_ != nullptr) _impl_.current_reference_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SimpleLongitudinalDebug::clear_preview_reference_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.preview_reference_point_ != nullptr) _impl_.preview_reference_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
SimpleLongitudinalDebug::SimpleLongitudinalDebug(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.SimpleLongitudinalDebug)
}
inline PROTOBUF_NDEBUG_INLINE SimpleLongitudinalDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::SimpleLongitudinalDebug& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

SimpleLongitudinalDebug::SimpleLongitudinalDebug(
    ::google::protobuf::Arena* arena,
    const SimpleLongitudinalDebug& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SimpleLongitudinalDebug* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.current_matched_point_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.current_matched_point_)
                        : nullptr;
  _impl_.current_reference_point_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.current_reference_point_)
                        : nullptr;
  _impl_.preview_reference_point_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.preview_reference_point_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, station_reference_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, station_reference_),
           offsetof(Impl_, contraposition_x_) -
               offsetof(Impl_, station_reference_) +
               sizeof(Impl_::contraposition_x_));

  // @@protoc_insertion_point(copy_constructor:control.SimpleLongitudinalDebug)
}
inline PROTOBUF_NDEBUG_INLINE SimpleLongitudinalDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SimpleLongitudinalDebug::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, current_matched_point_),
           0,
           offsetof(Impl_, contraposition_x_) -
               offsetof(Impl_, current_matched_point_) +
               sizeof(Impl_::contraposition_x_));
}
SimpleLongitudinalDebug::~SimpleLongitudinalDebug() {
  // @@protoc_insertion_point(destructor:control.SimpleLongitudinalDebug)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SimpleLongitudinalDebug::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.current_matched_point_;
  delete _impl_.current_reference_point_;
  delete _impl_.preview_reference_point_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    SimpleLongitudinalDebug::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &SimpleLongitudinalDebug::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<SimpleLongitudinalDebug>(),
            ::google::protobuf::Message::GetNewImpl<SimpleLongitudinalDebug>(),
            ::google::protobuf::Message::GetClearImpl<SimpleLongitudinalDebug>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<SimpleLongitudinalDebug>(),
                ::google::protobuf::Message::GetSerializeImpl<SimpleLongitudinalDebug>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_._cached_size_),
            false,
        },
        &SimpleLongitudinalDebug::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* SimpleLongitudinalDebug::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 48, 4, 0, 9> SimpleLongitudinalDebug::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_._has_bits_),
    0, // no _extensions_
    56, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    48,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SimpleLongitudinalDebug_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::SimpleLongitudinalDebug>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double station_reference = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 3, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.station_reference_)}},
    // optional double station_error = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 4, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.station_error_)}},
    // optional double station_error_limited = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 5, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.station_error_limited_)}},
    // optional double preview_station_error = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 6, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_station_error_)}},
    // optional double speed_reference = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 7, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_reference_)}},
    // optional double speed_error = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 8, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_error_)}},
    // optional double speed_controller_input_limited = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 9, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_controller_input_limited_)}},
    // optional double preview_speed_reference = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 10, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_speed_reference_)}},
    // optional double preview_speed_error = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 11, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_speed_error_)}},
    // optional double preview_acceleration_reference = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 12, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_acceleration_reference_)}},
    // optional double acceleration_cmd_closeloop = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 13, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_cmd_closeloop_)}},
    // optional double acceleration_cmd = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 14, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_cmd_)}},
    // optional double acceleration_lookup = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 15, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_lookup_)}},
    // optional double speed_lookup = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 16, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_lookup_)}},
    // optional double calibration_value = 15;
    {::_pbi::TcParser::FastF64S1,
     {121, 17, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.calibration_value_)}},
    // optional double throttle_cmd = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 18, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.throttle_cmd_)}},
    // optional double brake_cmd = 17;
    {::_pbi::TcParser::FastF64S2,
     {393, 19, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.brake_cmd_)}},
    // optional .control.common.TrajectoryPoint preview_reference_point = 34;
    {::_pbi::TcParser::FastMtS2,
     {658, 2, 2, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_reference_point_)}},
    // optional double slope_offset_compensation = 19;
    {::_pbi::TcParser::FastF64S2,
     {409, 20, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.slope_offset_compensation_)}},
    // optional double current_station = 20;
    {::_pbi::TcParser::FastF64S2,
     {417, 21, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_station_)}},
    // optional double path_remain = 21;
    {::_pbi::TcParser::FastF64S2,
     {425, 22, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.path_remain_)}},
    // optional int32 pid_saturation_status = 22;
    {::_pbi::TcParser::FastV32S2,
     {432, 23, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.pid_saturation_status_)}},
    // optional int32 leadlag_saturation_status = 23;
    {::_pbi::TcParser::FastV32S2,
     {440, 24, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.leadlag_saturation_status_)}},
    // optional double speed_offset = 24;
    {::_pbi::TcParser::FastF64S2,
     {449, 25, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_offset_)}},
    // optional double current_speed = 25;
    {::_pbi::TcParser::FastF64S2,
     {457, 26, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_speed_)}},
    // optional double acceleration_reference = 26;
    {::_pbi::TcParser::FastF64S2,
     {465, 27, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_reference_)}},
    // optional double current_acceleration = 27;
    {::_pbi::TcParser::FastF64S2,
     {473, 28, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_acceleration_)}},
    // optional double acceleration_error = 28;
    {::_pbi::TcParser::FastF64S2,
     {481, 29, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_error_)}},
    // optional double jerk_reference = 29;
    {::_pbi::TcParser::FastF64S2,
     {489, 30, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.jerk_reference_)}},
    // optional double current_jerk = 30;
    {::_pbi::TcParser::FastF64S2,
     {497, 31, 0, PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_jerk_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    33, 0, 2,
    64512, 32, 65283, 42,
    65535, 65535
  }}, {{
    // optional double station_reference = 1;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.station_reference_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double station_error = 2;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.station_error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double station_error_limited = 3;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.station_error_limited_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_station_error = 4;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_station_error_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_reference = 5;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_reference_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_error = 6;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_error_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_controller_input_limited = 7;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_controller_input_limited_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_speed_reference = 8;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_speed_reference_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_speed_error = 9;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_speed_error_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_acceleration_reference = 10;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_acceleration_reference_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_cmd_closeloop = 11;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_cmd_closeloop_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_cmd = 12;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_cmd_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_lookup = 13;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_lookup_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_lookup = 14;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_lookup_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double calibration_value = 15;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.calibration_value_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double throttle_cmd = 16;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.throttle_cmd_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double brake_cmd = 17;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.brake_cmd_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_full_stop = 18;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_full_stop_), _Internal::kHasBitsOffset + 36, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double slope_offset_compensation = 19;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.slope_offset_compensation_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double current_station = 20;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_station_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double path_remain = 21;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.path_remain_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional int32 pid_saturation_status = 22;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.pid_saturation_status_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 leadlag_saturation_status = 23;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.leadlag_saturation_status_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional double speed_offset = 24;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.speed_offset_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double current_speed = 25;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_speed_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_reference = 26;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_reference_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double current_acceleration = 27;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_acceleration_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_error = 28;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_error_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double jerk_reference = 29;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.jerk_reference_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double current_jerk = 30;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_jerk_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double jerk_error = 31;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.jerk_error_), _Internal::kHasBitsOffset + 32, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.common.TrajectoryPoint current_matched_point = 32;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_matched_point_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.TrajectoryPoint current_reference_point = 33;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_reference_point_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.TrajectoryPoint preview_reference_point = 34;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.preview_reference_point_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double acceleration_lookup_limit = 35;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.acceleration_lookup_limit_), _Internal::kHasBitsOffset + 33, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double vehicle_pitch = 36;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.vehicle_pitch_), _Internal::kHasBitsOffset + 34, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_epb_brake = 37;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_epb_brake_), _Internal::kHasBitsOffset + 37, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double current_steer_interval = 38;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_steer_interval_), _Internal::kHasBitsOffset + 35, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_wait_steer = 39;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_wait_steer_), _Internal::kHasBitsOffset + 38, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_stop_reason_by_destination = 40;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_stop_reason_by_destination_), _Internal::kHasBitsOffset + 39, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_stop_reason_by_prdestrian = 41;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_stop_reason_by_prdestrian_), _Internal::kHasBitsOffset + 40, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_full_stop_soft = 42;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_full_stop_soft_), _Internal::kHasBitsOffset + 41, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double stop_acc_cmd = 51;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.stop_acc_cmd_), _Internal::kHasBitsOffset + 44, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.canbus.Chassis.GearPosition gear_location = 52;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.gear_location_), _Internal::kHasBitsOffset + 45, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool is_stop_scenario = 53;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_stop_scenario_), _Internal::kHasBitsOffset + 42, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double contraposition_x = 54;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.contraposition_x_), _Internal::kHasBitsOffset + 47, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional uint32 stopstate = 55;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.stopstate_), _Internal::kHasBitsOffset + 46, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool is_take_off_state = 56;
    {PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.is_take_off_state_), _Internal::kHasBitsOffset + 43, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
    {0, 7},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void SimpleLongitudinalDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:control.SimpleLongitudinalDebug)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.current_matched_point_ != nullptr);
      _impl_.current_matched_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.current_reference_point_ != nullptr);
      _impl_.current_reference_point_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.preview_reference_point_ != nullptr);
      _impl_.preview_reference_point_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.station_reference_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.speed_reference_) -
        reinterpret_cast<char*>(&_impl_.station_reference_)) + sizeof(_impl_.speed_reference_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.speed_error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.acceleration_lookup_) -
        reinterpret_cast<char*>(&_impl_.speed_error_)) + sizeof(_impl_.acceleration_lookup_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.speed_lookup_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pid_saturation_status_) -
        reinterpret_cast<char*>(&_impl_.speed_lookup_)) + sizeof(_impl_.pid_saturation_status_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.leadlag_saturation_status_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.current_jerk_) -
        reinterpret_cast<char*>(&_impl_.leadlag_saturation_status_)) + sizeof(_impl_.current_jerk_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.jerk_error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_stop_reason_by_destination_) -
        reinterpret_cast<char*>(&_impl_.jerk_error_)) + sizeof(_impl_.is_stop_reason_by_destination_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.is_stop_reason_by_prdestrian_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.contraposition_x_) -
        reinterpret_cast<char*>(&_impl_.is_stop_reason_by_prdestrian_)) + sizeof(_impl_.contraposition_x_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SimpleLongitudinalDebug::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.SimpleLongitudinalDebug)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double station_reference = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_station_reference(), target);
  }

  // optional double station_error = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_station_error(), target);
  }

  // optional double station_error_limited = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_station_error_limited(), target);
  }

  // optional double preview_station_error = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_preview_station_error(), target);
  }

  // optional double speed_reference = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_speed_reference(), target);
  }

  // optional double speed_error = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_speed_error(), target);
  }

  // optional double speed_controller_input_limited = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_speed_controller_input_limited(), target);
  }

  // optional double preview_speed_reference = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_preview_speed_reference(), target);
  }

  // optional double preview_speed_error = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_preview_speed_error(), target);
  }

  // optional double preview_acceleration_reference = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_preview_acceleration_reference(), target);
  }

  // optional double acceleration_cmd_closeloop = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_acceleration_cmd_closeloop(), target);
  }

  // optional double acceleration_cmd = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_acceleration_cmd(), target);
  }

  // optional double acceleration_lookup = 13;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_acceleration_lookup(), target);
  }

  // optional double speed_lookup = 14;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_speed_lookup(), target);
  }

  // optional double calibration_value = 15;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_calibration_value(), target);
  }

  // optional double throttle_cmd = 16;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_throttle_cmd(), target);
  }

  // optional double brake_cmd = 17;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_brake_cmd(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool is_full_stop = 18;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this->_internal_is_full_stop(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional double slope_offset_compensation = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        19, this->_internal_slope_offset_compensation(), target);
  }

  // optional double current_station = 20;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_current_station(), target);
  }

  // optional double path_remain = 21;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        21, this->_internal_path_remain(), target);
  }

  // optional int32 pid_saturation_status = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        22, this->_internal_pid_saturation_status(), target);
  }

  // optional int32 leadlag_saturation_status = 23;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        23, this->_internal_leadlag_saturation_status(), target);
  }

  // optional double speed_offset = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        24, this->_internal_speed_offset(), target);
  }

  // optional double current_speed = 25;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        25, this->_internal_current_speed(), target);
  }

  // optional double acceleration_reference = 26;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        26, this->_internal_acceleration_reference(), target);
  }

  // optional double current_acceleration = 27;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        27, this->_internal_current_acceleration(), target);
  }

  // optional double acceleration_error = 28;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        28, this->_internal_acceleration_error(), target);
  }

  // optional double jerk_reference = 29;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        29, this->_internal_jerk_reference(), target);
  }

  // optional double current_jerk = 30;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        30, this->_internal_current_jerk(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double jerk_error = 31;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        31, this->_internal_jerk_error(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .control.common.TrajectoryPoint current_matched_point = 32;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        32, *_impl_.current_matched_point_, _impl_.current_matched_point_->GetCachedSize(), target, stream);
  }

  // optional .control.common.TrajectoryPoint current_reference_point = 33;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        33, *_impl_.current_reference_point_, _impl_.current_reference_point_->GetCachedSize(), target, stream);
  }

  // optional .control.common.TrajectoryPoint preview_reference_point = 34;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        34, *_impl_.preview_reference_point_, _impl_.preview_reference_point_->GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double acceleration_lookup_limit = 35;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        35, this->_internal_acceleration_lookup_limit(), target);
  }

  // optional double vehicle_pitch = 36;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        36, this->_internal_vehicle_pitch(), target);
  }

  // optional bool is_epb_brake = 37;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        37, this->_internal_is_epb_brake(), target);
  }

  // optional double current_steer_interval = 38;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        38, this->_internal_current_steer_interval(), target);
  }

  // optional bool is_wait_steer = 39;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        39, this->_internal_is_wait_steer(), target);
  }

  // optional bool is_stop_reason_by_destination = 40;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        40, this->_internal_is_stop_reason_by_destination(), target);
  }

  // optional bool is_stop_reason_by_prdestrian = 41;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        41, this->_internal_is_stop_reason_by_prdestrian(), target);
  }

  // optional bool is_full_stop_soft = 42;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        42, this->_internal_is_full_stop_soft(), target);
  }

  // optional double stop_acc_cmd = 51;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        51, this->_internal_stop_acc_cmd(), target);
  }

  // optional .control.canbus.Chassis.GearPosition gear_location = 52;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        52, this->_internal_gear_location(), target);
  }

  // optional bool is_stop_scenario = 53;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        53, this->_internal_is_stop_scenario(), target);
  }

  // optional double contraposition_x = 54;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        54, this->_internal_contraposition_x(), target);
  }

  // optional uint32 stopstate = 55;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        55, this->_internal_stopstate(), target);
  }

  // optional bool is_take_off_state = 56;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        56, this->_internal_is_take_off_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.SimpleLongitudinalDebug)
  return target;
}

::size_t SimpleLongitudinalDebug::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.SimpleLongitudinalDebug)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .control.common.TrajectoryPoint current_matched_point = 32;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.current_matched_point_);
    }
    // optional .control.common.TrajectoryPoint current_reference_point = 33;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.current_reference_point_);
    }
    // optional .control.common.TrajectoryPoint preview_reference_point = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.preview_reference_point_);
    }
    // optional double station_reference = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }
    // optional double station_error = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }
    // optional double station_error_limited = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }
    // optional double preview_station_error = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }
    // optional double speed_reference = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double speed_error = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double speed_controller_input_limited = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional double preview_speed_reference = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }
    // optional double preview_speed_error = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }
    // optional double preview_acceleration_reference = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 9;
    }
    // optional double acceleration_cmd_closeloop = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 9;
    }
    // optional double acceleration_cmd = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += 9;
    }
    // optional double acceleration_lookup = 13;
    if (cached_has_bits & 0x00008000u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double speed_lookup = 14;
    if (cached_has_bits & 0x00010000u) {
      total_size += 9;
    }
    // optional double calibration_value = 15;
    if (cached_has_bits & 0x00020000u) {
      total_size += 9;
    }
    // optional double throttle_cmd = 16;
    if (cached_has_bits & 0x00040000u) {
      total_size += 10;
    }
    // optional double brake_cmd = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 10;
    }
    // optional double slope_offset_compensation = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 10;
    }
    // optional double current_station = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 10;
    }
    // optional double path_remain = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 10;
    }
    // optional int32 pid_saturation_status = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_pid_saturation_status());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 leadlag_saturation_status = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_leadlag_saturation_status());
    }
    // optional double speed_offset = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 10;
    }
    // optional double current_speed = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 10;
    }
    // optional double acceleration_reference = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 10;
    }
    // optional double current_acceleration = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 10;
    }
    // optional double acceleration_error = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 10;
    }
    // optional double jerk_reference = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 10;
    }
    // optional double current_jerk = 30;
    if (cached_has_bits & 0x80000000u) {
      total_size += 10;
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional double jerk_error = 31;
    if (cached_has_bits & 0x00000001u) {
      total_size += 10;
    }
    // optional double acceleration_lookup_limit = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 10;
    }
    // optional double vehicle_pitch = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size += 10;
    }
    // optional double current_steer_interval = 38;
    if (cached_has_bits & 0x00000008u) {
      total_size += 10;
    }
    // optional bool is_full_stop = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 3;
    }
    // optional bool is_epb_brake = 37;
    if (cached_has_bits & 0x00000020u) {
      total_size += 3;
    }
    // optional bool is_wait_steer = 39;
    if (cached_has_bits & 0x00000040u) {
      total_size += 3;
    }
    // optional bool is_stop_reason_by_destination = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 3;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_stop_reason_by_prdestrian = 41;
    if (cached_has_bits & 0x00000100u) {
      total_size += 3;
    }
    // optional bool is_full_stop_soft = 42;
    if (cached_has_bits & 0x00000200u) {
      total_size += 3;
    }
    // optional bool is_stop_scenario = 53;
    if (cached_has_bits & 0x00000400u) {
      total_size += 3;
    }
    // optional bool is_take_off_state = 56;
    if (cached_has_bits & 0x00000800u) {
      total_size += 3;
    }
    // optional double stop_acc_cmd = 51;
    if (cached_has_bits & 0x00001000u) {
      total_size += 10;
    }
    // optional .control.canbus.Chassis.GearPosition gear_location = 52;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_gear_location());
    }
    // optional uint32 stopstate = 55;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_stopstate());
    }
    // optional double contraposition_x = 54;
    if (cached_has_bits & 0x00008000u) {
      total_size += 10;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void SimpleLongitudinalDebug::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SimpleLongitudinalDebug*>(&to_msg);
  auto& from = static_cast<const SimpleLongitudinalDebug&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.SimpleLongitudinalDebug)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.current_matched_point_ != nullptr);
      if (_this->_impl_.current_matched_point_ == nullptr) {
        _this->_impl_.current_matched_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.current_matched_point_);
      } else {
        _this->_impl_.current_matched_point_->MergeFrom(*from._impl_.current_matched_point_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.current_reference_point_ != nullptr);
      if (_this->_impl_.current_reference_point_ == nullptr) {
        _this->_impl_.current_reference_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.current_reference_point_);
      } else {
        _this->_impl_.current_reference_point_->MergeFrom(*from._impl_.current_reference_point_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.preview_reference_point_ != nullptr);
      if (_this->_impl_.preview_reference_point_ == nullptr) {
        _this->_impl_.preview_reference_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.preview_reference_point_);
      } else {
        _this->_impl_.preview_reference_point_->MergeFrom(*from._impl_.preview_reference_point_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.station_reference_ = from._impl_.station_reference_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.station_error_ = from._impl_.station_error_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.station_error_limited_ = from._impl_.station_error_limited_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.preview_station_error_ = from._impl_.preview_station_error_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.speed_reference_ = from._impl_.speed_reference_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.speed_error_ = from._impl_.speed_error_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.speed_controller_input_limited_ = from._impl_.speed_controller_input_limited_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.preview_speed_reference_ = from._impl_.preview_speed_reference_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.preview_speed_error_ = from._impl_.preview_speed_error_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.preview_acceleration_reference_ = from._impl_.preview_acceleration_reference_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.acceleration_cmd_closeloop_ = from._impl_.acceleration_cmd_closeloop_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.acceleration_cmd_ = from._impl_.acceleration_cmd_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.acceleration_lookup_ = from._impl_.acceleration_lookup_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.speed_lookup_ = from._impl_.speed_lookup_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.calibration_value_ = from._impl_.calibration_value_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.throttle_cmd_ = from._impl_.throttle_cmd_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.brake_cmd_ = from._impl_.brake_cmd_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.slope_offset_compensation_ = from._impl_.slope_offset_compensation_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.current_station_ = from._impl_.current_station_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.path_remain_ = from._impl_.path_remain_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.pid_saturation_status_ = from._impl_.pid_saturation_status_;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.leadlag_saturation_status_ = from._impl_.leadlag_saturation_status_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.speed_offset_ = from._impl_.speed_offset_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.current_speed_ = from._impl_.current_speed_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.acceleration_reference_ = from._impl_.acceleration_reference_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.current_acceleration_ = from._impl_.current_acceleration_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.acceleration_error_ = from._impl_.acceleration_error_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.jerk_reference_ = from._impl_.jerk_reference_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.current_jerk_ = from._impl_.current_jerk_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.jerk_error_ = from._impl_.jerk_error_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.acceleration_lookup_limit_ = from._impl_.acceleration_lookup_limit_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vehicle_pitch_ = from._impl_.vehicle_pitch_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.current_steer_interval_ = from._impl_.current_steer_interval_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_full_stop_ = from._impl_.is_full_stop_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_epb_brake_ = from._impl_.is_epb_brake_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_wait_steer_ = from._impl_.is_wait_steer_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_stop_reason_by_destination_ = from._impl_.is_stop_reason_by_destination_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.is_stop_reason_by_prdestrian_ = from._impl_.is_stop_reason_by_prdestrian_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_full_stop_soft_ = from._impl_.is_full_stop_soft_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_stop_scenario_ = from._impl_.is_stop_scenario_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_take_off_state_ = from._impl_.is_take_off_state_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.stop_acc_cmd_ = from._impl_.stop_acc_cmd_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.gear_location_ = from._impl_.gear_location_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.stopstate_ = from._impl_.stopstate_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.contraposition_x_ = from._impl_.contraposition_x_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SimpleLongitudinalDebug::CopyFrom(const SimpleLongitudinalDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.SimpleLongitudinalDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SimpleLongitudinalDebug::InternalSwap(SimpleLongitudinalDebug* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.contraposition_x_)
      + sizeof(SimpleLongitudinalDebug::_impl_.contraposition_x_)
      - PROTOBUF_FIELD_OFFSET(SimpleLongitudinalDebug, _impl_.current_matched_point_)>(
          reinterpret_cast<char*>(&_impl_.current_matched_point_),
          reinterpret_cast<char*>(&other->_impl_.current_matched_point_));
}

::google::protobuf::Metadata SimpleLongitudinalDebug::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SimpleLateralDebug::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SimpleLateralDebug>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_._has_bits_);
};

void SimpleLateralDebug::clear_current_target_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_target_point_ != nullptr) _impl_.current_target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SimpleLateralDebug::SimpleLateralDebug(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.SimpleLateralDebug)
}
inline PROTOBUF_NDEBUG_INLINE SimpleLateralDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::SimpleLateralDebug& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

SimpleLateralDebug::SimpleLateralDebug(
    ::google::protobuf::Arena* arena,
    const SimpleLateralDebug& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SimpleLateralDebug* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.current_target_point_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.current_target_point_)
                        : nullptr;
  _impl_.steer_mrac_debug_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::MracDebug>(
                              arena, *from._impl_.steer_mrac_debug_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, lateral_error_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, lateral_error_),
           offsetof(Impl_, preview_pos_curvature_) -
               offsetof(Impl_, lateral_error_) +
               sizeof(Impl_::preview_pos_curvature_));

  // @@protoc_insertion_point(copy_constructor:control.SimpleLateralDebug)
}
inline PROTOBUF_NDEBUG_INLINE SimpleLateralDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SimpleLateralDebug::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, current_target_point_),
           0,
           offsetof(Impl_, preview_pos_curvature_) -
               offsetof(Impl_, current_target_point_) +
               sizeof(Impl_::preview_pos_curvature_));
}
SimpleLateralDebug::~SimpleLateralDebug() {
  // @@protoc_insertion_point(destructor:control.SimpleLateralDebug)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SimpleLateralDebug::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.current_target_point_;
  delete _impl_.steer_mrac_debug_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    SimpleLateralDebug::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &SimpleLateralDebug::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<SimpleLateralDebug>(),
            ::google::protobuf::Message::GetNewImpl<SimpleLateralDebug>(),
            ::google::protobuf::Message::GetClearImpl<SimpleLateralDebug>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<SimpleLateralDebug>(),
                ::google::protobuf::Message::GetSerializeImpl<SimpleLateralDebug>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_._cached_size_),
            false,
        },
        &SimpleLateralDebug::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* SimpleLateralDebug::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 36, 2, 0, 7> SimpleLateralDebug::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_._has_bits_),
    0, // no _extensions_
    36, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    36,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SimpleLateralDebug_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::SimpleLateralDebug>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double lateral_error = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 2, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_error_)}},
    // optional double ref_heading = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 3, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_)}},
    // optional double heading = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 4, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_)}},
    // optional double heading_error = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 5, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_)}},
    // optional double heading_error_rate = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 6, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_rate_)}},
    // optional double lateral_error_rate = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 7, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_error_rate_)}},
    // optional double curvature = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 8, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.curvature_)}},
    // optional double steer_angle = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 9, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_)}},
    // optional double steer_angle_feedforward = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 10, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_feedforward_)}},
    // optional double steer_angle_lateral_contribution = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 11, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_lateral_contribution_)}},
    // optional double steer_angle_lateral_rate_contribution = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 12, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_lateral_rate_contribution_)}},
    // optional double steer_angle_heading_contribution = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 13, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_heading_contribution_)}},
    // optional double steer_angle_heading_rate_contribution = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 14, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_heading_rate_contribution_)}},
    // optional double steer_angle_feedback = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 15, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_feedback_)}},
    // optional double steering_position = 15;
    {::_pbi::TcParser::FastF64S1,
     {121, 16, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steering_position_)}},
    // optional double ref_speed = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 17, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_speed_)}},
    // optional double steer_angle_limited = 17;
    {::_pbi::TcParser::FastF64S2,
     {393, 18, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_limited_)}},
    // optional double lateral_acceleration = 18;
    {::_pbi::TcParser::FastF64S2,
     {401, 19, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_acceleration_)}},
    // optional double lateral_jerk = 19;
    {::_pbi::TcParser::FastF64S2,
     {409, 20, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_jerk_)}},
    // optional double ref_heading_rate = 20;
    {::_pbi::TcParser::FastF64S2,
     {417, 21, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_rate_)}},
    // optional double heading_rate = 21;
    {::_pbi::TcParser::FastF64S2,
     {425, 22, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_rate_)}},
    // optional double ref_heading_acceleration = 22;
    {::_pbi::TcParser::FastF64S2,
     {433, 23, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_acceleration_)}},
    // optional double heading_acceleration = 23;
    {::_pbi::TcParser::FastF64S2,
     {441, 24, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_acceleration_)}},
    // optional double heading_error_acceleration = 24;
    {::_pbi::TcParser::FastF64S2,
     {449, 25, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_acceleration_)}},
    // optional double ref_heading_jerk = 25;
    {::_pbi::TcParser::FastF64S2,
     {457, 26, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_jerk_)}},
    // optional double heading_jerk = 26;
    {::_pbi::TcParser::FastF64S2,
     {465, 27, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_jerk_)}},
    // optional double heading_error_jerk = 27;
    {::_pbi::TcParser::FastF64S2,
     {473, 28, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_jerk_)}},
    // optional double lateral_error_feedback = 28;
    {::_pbi::TcParser::FastF64S2,
     {481, 29, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_error_feedback_)}},
    // optional double heading_error_feedback = 29;
    {::_pbi::TcParser::FastF64S2,
     {489, 30, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_feedback_)}},
    // optional .control.common.TrajectoryPoint current_target_point = 30;
    {::_pbi::TcParser::FastMtS2,
     {498, 0, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.current_target_point_)}},
    // optional double steer_angle_feedback_augment = 31;
    {::_pbi::TcParser::FastF64S2,
     {505, 31, 0, PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_feedback_augment_)}},
  }}, {{
    33, 0, 1,
    65520, 32,
    65535, 65535
  }}, {{
    // optional double lateral_error = 1;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_error_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading = 2;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading = 3;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error = 4;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_rate = 5;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_rate_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_error_rate = 6;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_error_rate_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double curvature = 7;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.curvature_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle = 8;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_feedforward = 9;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_feedforward_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_lateral_contribution = 10;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_lateral_contribution_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_lateral_rate_contribution = 11;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_lateral_rate_contribution_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_heading_contribution = 12;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_heading_contribution_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_heading_rate_contribution = 13;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_heading_rate_contribution_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_feedback = 14;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_feedback_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steering_position = 15;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steering_position_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_speed = 16;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_speed_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_limited = 17;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_limited_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_acceleration = 18;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_acceleration_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_jerk = 19;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_jerk_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading_rate = 20;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_rate_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_rate = 21;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_rate_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading_acceleration = 22;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_acceleration_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_acceleration = 23;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_acceleration_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_acceleration = 24;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_acceleration_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading_jerk = 25;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.ref_heading_jerk_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_jerk = 26;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_jerk_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_jerk = 27;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_jerk_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_error_feedback = 28;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_error_feedback_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_feedback = 29;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.heading_error_feedback_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.common.TrajectoryPoint current_target_point = 30;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.current_target_point_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double steer_angle_feedback_augment = 31;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_angle_feedback_augment_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.MracDebug steer_mrac_debug = 32;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_mrac_debug_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool steer_mrac_enable_status = 33;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.steer_mrac_enable_status_), _Internal::kHasBitsOffset + 33, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double lateral_centripetal_acceleration = 34;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.lateral_centripetal_acceleration_), _Internal::kHasBitsOffset + 32, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_pos_curvature = 35;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.preview_pos_curvature_), _Internal::kHasBitsOffset + 35, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional float preview_heading_error = 36;
    {PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.preview_heading_error_), _Internal::kHasBitsOffset + 34, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
    {::_pbi::TcParser::GetTable<::control::MracDebug>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void SimpleLateralDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:control.SimpleLateralDebug)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.current_target_point_ != nullptr);
      _impl_.current_target_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.steer_mrac_debug_ != nullptr);
      _impl_.steer_mrac_debug_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.lateral_error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.lateral_error_rate_) -
        reinterpret_cast<char*>(&_impl_.lateral_error_)) + sizeof(_impl_.lateral_error_rate_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.curvature_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.steer_angle_feedback_) -
        reinterpret_cast<char*>(&_impl_.curvature_)) + sizeof(_impl_.steer_angle_feedback_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.steering_position_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ref_heading_acceleration_) -
        reinterpret_cast<char*>(&_impl_.steering_position_)) + sizeof(_impl_.ref_heading_acceleration_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.heading_acceleration_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.steer_angle_feedback_augment_) -
        reinterpret_cast<char*>(&_impl_.heading_acceleration_)) + sizeof(_impl_.steer_angle_feedback_augment_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.lateral_centripetal_acceleration_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.preview_pos_curvature_) -
        reinterpret_cast<char*>(&_impl_.lateral_centripetal_acceleration_)) + sizeof(_impl_.preview_pos_curvature_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SimpleLateralDebug::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.SimpleLateralDebug)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double lateral_error = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_lateral_error(), target);
  }

  // optional double ref_heading = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_ref_heading(), target);
  }

  // optional double heading = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_heading(), target);
  }

  // optional double heading_error = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_heading_error(), target);
  }

  // optional double heading_error_rate = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_heading_error_rate(), target);
  }

  // optional double lateral_error_rate = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_lateral_error_rate(), target);
  }

  // optional double curvature = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_curvature(), target);
  }

  // optional double steer_angle = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_steer_angle(), target);
  }

  // optional double steer_angle_feedforward = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_steer_angle_feedforward(), target);
  }

  // optional double steer_angle_lateral_contribution = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_steer_angle_lateral_contribution(), target);
  }

  // optional double steer_angle_lateral_rate_contribution = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_steer_angle_lateral_rate_contribution(), target);
  }

  // optional double steer_angle_heading_contribution = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_steer_angle_heading_contribution(), target);
  }

  // optional double steer_angle_heading_rate_contribution = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_steer_angle_heading_rate_contribution(), target);
  }

  // optional double steer_angle_feedback = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_steer_angle_feedback(), target);
  }

  // optional double steering_position = 15;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_steering_position(), target);
  }

  // optional double ref_speed = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_ref_speed(), target);
  }

  // optional double steer_angle_limited = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_steer_angle_limited(), target);
  }

  // optional double lateral_acceleration = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        18, this->_internal_lateral_acceleration(), target);
  }

  // optional double lateral_jerk = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        19, this->_internal_lateral_jerk(), target);
  }

  // optional double ref_heading_rate = 20;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_ref_heading_rate(), target);
  }

  // optional double heading_rate = 21;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        21, this->_internal_heading_rate(), target);
  }

  // optional double ref_heading_acceleration = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this->_internal_ref_heading_acceleration(), target);
  }

  // optional double heading_acceleration = 23;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        23, this->_internal_heading_acceleration(), target);
  }

  // optional double heading_error_acceleration = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        24, this->_internal_heading_error_acceleration(), target);
  }

  // optional double ref_heading_jerk = 25;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        25, this->_internal_ref_heading_jerk(), target);
  }

  // optional double heading_jerk = 26;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        26, this->_internal_heading_jerk(), target);
  }

  // optional double heading_error_jerk = 27;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        27, this->_internal_heading_error_jerk(), target);
  }

  // optional double lateral_error_feedback = 28;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        28, this->_internal_lateral_error_feedback(), target);
  }

  // optional double heading_error_feedback = 29;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        29, this->_internal_heading_error_feedback(), target);
  }

  // optional .control.common.TrajectoryPoint current_target_point = 30;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        30, *_impl_.current_target_point_, _impl_.current_target_point_->GetCachedSize(), target, stream);
  }

  // optional double steer_angle_feedback_augment = 31;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        31, this->_internal_steer_angle_feedback_augment(), target);
  }

  // optional .control.MracDebug steer_mrac_debug = 32;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        32, *_impl_.steer_mrac_debug_, _impl_.steer_mrac_debug_->GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool steer_mrac_enable_status = 33;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        33, this->_internal_steer_mrac_enable_status(), target);
  }

  // optional double lateral_centripetal_acceleration = 34;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        34, this->_internal_lateral_centripetal_acceleration(), target);
  }

  // optional double preview_pos_curvature = 35;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        35, this->_internal_preview_pos_curvature(), target);
  }

  // optional float preview_heading_error = 36;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        36, this->_internal_preview_heading_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.SimpleLateralDebug)
  return target;
}

::size_t SimpleLateralDebug::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.SimpleLateralDebug)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .control.common.TrajectoryPoint current_target_point = 30;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.current_target_point_);
    }
    // optional .control.MracDebug steer_mrac_debug = 32;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.steer_mrac_debug_);
    }
    // optional double lateral_error = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }
    // optional double ref_heading = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }
    // optional double heading = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }
    // optional double heading_error = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }
    // optional double heading_error_rate = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }
    // optional double lateral_error_rate = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double curvature = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double steer_angle = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional double steer_angle_feedforward = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }
    // optional double steer_angle_lateral_contribution = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }
    // optional double steer_angle_lateral_rate_contribution = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 9;
    }
    // optional double steer_angle_heading_contribution = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 9;
    }
    // optional double steer_angle_heading_rate_contribution = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 9;
    }
    // optional double steer_angle_feedback = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double steering_position = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 9;
    }
    // optional double ref_speed = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 10;
    }
    // optional double steer_angle_limited = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 10;
    }
    // optional double lateral_acceleration = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 10;
    }
    // optional double lateral_jerk = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 10;
    }
    // optional double ref_heading_rate = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 10;
    }
    // optional double heading_rate = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 10;
    }
    // optional double ref_heading_acceleration = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 10;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    // optional double heading_acceleration = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 10;
    }
    // optional double heading_error_acceleration = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 10;
    }
    // optional double ref_heading_jerk = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 10;
    }
    // optional double heading_jerk = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 10;
    }
    // optional double heading_error_jerk = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 10;
    }
    // optional double lateral_error_feedback = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 10;
    }
    // optional double heading_error_feedback = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 10;
    }
    // optional double steer_angle_feedback_augment = 31;
    if (cached_has_bits & 0x80000000u) {
      total_size += 10;
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    // optional double lateral_centripetal_acceleration = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size += 10;
    }
    // optional bool steer_mrac_enable_status = 33;
    if (cached_has_bits & 0x00000002u) {
      total_size += 3;
    }
    // optional float preview_heading_error = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size += 6;
    }
    // optional double preview_pos_curvature = 35;
    if (cached_has_bits & 0x00000008u) {
      total_size += 10;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void SimpleLateralDebug::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SimpleLateralDebug*>(&to_msg);
  auto& from = static_cast<const SimpleLateralDebug&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.SimpleLateralDebug)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.current_target_point_ != nullptr);
      if (_this->_impl_.current_target_point_ == nullptr) {
        _this->_impl_.current_target_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.current_target_point_);
      } else {
        _this->_impl_.current_target_point_->MergeFrom(*from._impl_.current_target_point_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.steer_mrac_debug_ != nullptr);
      if (_this->_impl_.steer_mrac_debug_ == nullptr) {
        _this->_impl_.steer_mrac_debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::MracDebug>(arena, *from._impl_.steer_mrac_debug_);
      } else {
        _this->_impl_.steer_mrac_debug_->MergeFrom(*from._impl_.steer_mrac_debug_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lateral_error_ = from._impl_.lateral_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ref_heading_ = from._impl_.ref_heading_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.heading_ = from._impl_.heading_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.heading_error_ = from._impl_.heading_error_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.heading_error_rate_ = from._impl_.heading_error_rate_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.lateral_error_rate_ = from._impl_.lateral_error_rate_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.curvature_ = from._impl_.curvature_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.steer_angle_ = from._impl_.steer_angle_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.steer_angle_feedforward_ = from._impl_.steer_angle_feedforward_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.steer_angle_lateral_contribution_ = from._impl_.steer_angle_lateral_contribution_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.steer_angle_lateral_rate_contribution_ = from._impl_.steer_angle_lateral_rate_contribution_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.steer_angle_heading_contribution_ = from._impl_.steer_angle_heading_contribution_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.steer_angle_heading_rate_contribution_ = from._impl_.steer_angle_heading_rate_contribution_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.steer_angle_feedback_ = from._impl_.steer_angle_feedback_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.steering_position_ = from._impl_.steering_position_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.ref_speed_ = from._impl_.ref_speed_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.steer_angle_limited_ = from._impl_.steer_angle_limited_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.lateral_acceleration_ = from._impl_.lateral_acceleration_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.lateral_jerk_ = from._impl_.lateral_jerk_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.ref_heading_rate_ = from._impl_.ref_heading_rate_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.heading_rate_ = from._impl_.heading_rate_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.ref_heading_acceleration_ = from._impl_.ref_heading_acceleration_;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.heading_acceleration_ = from._impl_.heading_acceleration_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.heading_error_acceleration_ = from._impl_.heading_error_acceleration_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.ref_heading_jerk_ = from._impl_.ref_heading_jerk_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.heading_jerk_ = from._impl_.heading_jerk_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.heading_error_jerk_ = from._impl_.heading_error_jerk_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.lateral_error_feedback_ = from._impl_.lateral_error_feedback_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.heading_error_feedback_ = from._impl_.heading_error_feedback_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.steer_angle_feedback_augment_ = from._impl_.steer_angle_feedback_augment_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.lateral_centripetal_acceleration_ = from._impl_.lateral_centripetal_acceleration_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steer_mrac_enable_status_ = from._impl_.steer_mrac_enable_status_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.preview_heading_error_ = from._impl_.preview_heading_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.preview_pos_curvature_ = from._impl_.preview_pos_curvature_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SimpleLateralDebug::CopyFrom(const SimpleLateralDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.SimpleLateralDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SimpleLateralDebug::InternalSwap(SimpleLateralDebug* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.preview_pos_curvature_)
      + sizeof(SimpleLateralDebug::_impl_.preview_pos_curvature_)
      - PROTOBUF_FIELD_OFFSET(SimpleLateralDebug, _impl_.current_target_point_)>(
          reinterpret_cast<char*>(&_impl_.current_target_point_),
          reinterpret_cast<char*>(&other->_impl_.current_target_point_));
}

::google::protobuf::Metadata SimpleLateralDebug::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SimpleMPCDebug::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SimpleMPCDebug>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_._has_bits_);
};

void SimpleMPCDebug::clear_current_matched_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_matched_point_ != nullptr) _impl_.current_matched_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SimpleMPCDebug::clear_current_reference_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_reference_point_ != nullptr) _impl_.current_reference_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SimpleMPCDebug::clear_preview_reference_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.preview_reference_point_ != nullptr) _impl_.preview_reference_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
SimpleMPCDebug::SimpleMPCDebug(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.SimpleMPCDebug)
}
inline PROTOBUF_NDEBUG_INLINE SimpleMPCDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::SimpleMPCDebug& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        matrix_q_updated_{visibility, arena, from.matrix_q_updated_},
        matrix_r_updated_{visibility, arena, from.matrix_r_updated_} {}

SimpleMPCDebug::SimpleMPCDebug(
    ::google::protobuf::Arena* arena,
    const SimpleMPCDebug& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SimpleMPCDebug* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.current_matched_point_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.current_matched_point_)
                        : nullptr;
  _impl_.current_reference_point_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.current_reference_point_)
                        : nullptr;
  _impl_.preview_reference_point_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(
                              arena, *from._impl_.preview_reference_point_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, lateral_error_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, lateral_error_),
           offsetof(Impl_, is_full_stop_) -
               offsetof(Impl_, lateral_error_) +
               sizeof(Impl_::is_full_stop_));

  // @@protoc_insertion_point(copy_constructor:control.SimpleMPCDebug)
}
inline PROTOBUF_NDEBUG_INLINE SimpleMPCDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        matrix_q_updated_{visibility, arena},
        matrix_r_updated_{visibility, arena} {}

inline void SimpleMPCDebug::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, current_matched_point_),
           0,
           offsetof(Impl_, is_full_stop_) -
               offsetof(Impl_, current_matched_point_) +
               sizeof(Impl_::is_full_stop_));
}
SimpleMPCDebug::~SimpleMPCDebug() {
  // @@protoc_insertion_point(destructor:control.SimpleMPCDebug)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SimpleMPCDebug::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.current_matched_point_;
  delete _impl_.current_reference_point_;
  delete _impl_.preview_reference_point_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    SimpleMPCDebug::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &SimpleMPCDebug::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<SimpleMPCDebug>(),
            ::google::protobuf::Message::GetNewImpl<SimpleMPCDebug>(),
            ::google::protobuf::Message::GetClearImpl<SimpleMPCDebug>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<SimpleMPCDebug>(),
                ::google::protobuf::Message::GetSerializeImpl<SimpleMPCDebug>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_._cached_size_),
            false,
        },
        &SimpleMPCDebug::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* SimpleMPCDebug::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 64, 3, 0, 9> SimpleMPCDebug::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_._has_bits_),
    0, // no _extensions_
    64, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    64,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SimpleMPCDebug_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::SimpleMPCDebug>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double lateral_error = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 3, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_error_)}},
    // optional double ref_heading = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 4, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_heading_)}},
    // optional double heading = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 5, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_)}},
    // optional double heading_error = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 6, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_)}},
    // optional double heading_error_rate = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 7, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_rate_)}},
    // optional double lateral_error_rate = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 8, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_error_rate_)}},
    // optional double curvature = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 9, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.curvature_)}},
    // optional double steer_angle = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 10, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_)}},
    // optional double steer_angle_feedforward = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 11, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_feedforward_)}},
    // optional double steer_angle_lateral_contribution = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 12, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_lateral_contribution_)}},
    // optional double steer_angle_lateral_rate_contribution = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 13, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_lateral_rate_contribution_)}},
    // optional double steer_angle_heading_contribution = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 14, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_heading_contribution_)}},
    // optional double steer_angle_heading_rate_contribution = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 15, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_heading_rate_contribution_)}},
    // optional double steer_angle_feedback = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 16, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_feedback_)}},
    // optional double steering_position = 15;
    {::_pbi::TcParser::FastF64S1,
     {121, 17, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steering_position_)}},
    // optional double ref_speed = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 18, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_speed_)}},
    // optional double steer_angle_limited = 17;
    {::_pbi::TcParser::FastF64S2,
     {393, 19, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_limited_)}},
    // optional double station_reference = 18;
    {::_pbi::TcParser::FastF64S2,
     {401, 20, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.station_reference_)}},
    // optional double station_error = 19;
    {::_pbi::TcParser::FastF64S2,
     {409, 21, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.station_error_)}},
    // optional double speed_reference = 20;
    {::_pbi::TcParser::FastF64S2,
     {417, 22, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_reference_)}},
    // optional double speed_error = 21;
    {::_pbi::TcParser::FastF64S2,
     {425, 23, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_error_)}},
    // optional double acceleration_reference = 22;
    {::_pbi::TcParser::FastF64S2,
     {433, 24, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_reference_)}},
    // optional .control.common.TrajectoryPoint preview_reference_point = 55;
    {::_pbi::TcParser::FastMtS2,
     {954, 2, 2, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.preview_reference_point_)}},
    // optional double station_feedback = 24;
    {::_pbi::TcParser::FastF64S2,
     {449, 25, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.station_feedback_)}},
    // optional double speed_feedback = 25;
    {::_pbi::TcParser::FastF64S2,
     {457, 26, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_feedback_)}},
    // optional double acceleration_cmd_closeloop = 26;
    {::_pbi::TcParser::FastF64S2,
     {465, 27, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_cmd_closeloop_)}},
    // optional double acceleration_cmd = 27;
    {::_pbi::TcParser::FastF64S2,
     {473, 28, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_cmd_)}},
    // optional double acceleration_lookup = 28;
    {::_pbi::TcParser::FastF64S2,
     {481, 29, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_lookup_)}},
    // optional double speed_lookup = 29;
    {::_pbi::TcParser::FastF64S2,
     {489, 30, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_lookup_)}},
    // optional double calibration_value = 30;
    {::_pbi::TcParser::FastF64S2,
     {497, 31, 0, PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.calibration_value_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    33, 0, 2,
    0, 32, 0, 48,
    65535, 65535
  }}, {{
    // optional double lateral_error = 1;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_error_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading = 2;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_heading_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading = 3;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error = 4;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_rate = 5;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_rate_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_error_rate = 6;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_error_rate_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double curvature = 7;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.curvature_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle = 8;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_feedforward = 9;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_feedforward_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_lateral_contribution = 10;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_lateral_contribution_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_lateral_rate_contribution = 11;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_lateral_rate_contribution_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_heading_contribution = 12;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_heading_contribution_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_heading_rate_contribution = 13;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_heading_rate_contribution_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_feedback = 14;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_feedback_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steering_position = 15;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steering_position_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_speed = 16;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_speed_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_limited = 17;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_limited_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double station_reference = 18;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.station_reference_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double station_error = 19;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.station_error_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_reference = 20;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_reference_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_error = 21;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_error_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_reference = 22;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_reference_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_full_stop = 23;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.is_full_stop_), _Internal::kHasBitsOffset + 61, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double station_feedback = 24;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.station_feedback_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_feedback = 25;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_feedback_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_cmd_closeloop = 26;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_cmd_closeloop_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_cmd = 27;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_cmd_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_lookup = 28;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_lookup_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double speed_lookup = 29;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.speed_lookup_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double calibration_value = 30;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.calibration_value_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_unconstrained_control_diff = 31;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_unconstrained_control_diff_), _Internal::kHasBitsOffset + 32, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_feedforward_compensation = 32;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_feedforward_compensation_), _Internal::kHasBitsOffset + 33, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // repeated double matrix_q_updated = 33;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.matrix_q_updated_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated double matrix_r_updated = 34;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.matrix_r_updated_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // optional double lateral_acceleration = 35;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_acceleration_), _Internal::kHasBitsOffset + 34, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_jerk = 36;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_jerk_), _Internal::kHasBitsOffset + 35, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading_rate = 37;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_heading_rate_), _Internal::kHasBitsOffset + 36, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_rate = 38;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_rate_), _Internal::kHasBitsOffset + 37, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading_acceleration = 39;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_heading_acceleration_), _Internal::kHasBitsOffset + 38, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_acceleration = 40;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_acceleration_), _Internal::kHasBitsOffset + 39, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_acceleration = 41;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_acceleration_), _Internal::kHasBitsOffset + 40, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ref_heading_jerk = 42;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.ref_heading_jerk_), _Internal::kHasBitsOffset + 41, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_jerk = 43;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_jerk_), _Internal::kHasBitsOffset + 42, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_jerk = 44;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_jerk_), _Internal::kHasBitsOffset + 43, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_feedback = 45;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_feedback_), _Internal::kHasBitsOffset + 44, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_error = 46;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_error_), _Internal::kHasBitsOffset + 45, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double jerk_reference = 47;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.jerk_reference_), _Internal::kHasBitsOffset + 46, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double jerk_feedback = 48;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.jerk_feedback_), _Internal::kHasBitsOffset + 47, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double jerk_error = 49;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.jerk_error_), _Internal::kHasBitsOffset + 48, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lateral_error_feedback = 50;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.lateral_error_feedback_), _Internal::kHasBitsOffset + 49, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading_error_feedback = 51;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.heading_error_feedback_), _Internal::kHasBitsOffset + 50, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double steer_angle_feedback_augment = 52;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.steer_angle_feedback_augment_), _Internal::kHasBitsOffset + 51, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.common.TrajectoryPoint current_matched_point = 53;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.current_matched_point_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.TrajectoryPoint current_reference_point = 54;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.current_reference_point_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.TrajectoryPoint preview_reference_point = 55;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.preview_reference_point_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double preview_station_error = 56;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.preview_station_error_), _Internal::kHasBitsOffset + 52, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_speed_reference = 57;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.preview_speed_reference_), _Internal::kHasBitsOffset + 53, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_speed_error = 58;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.preview_speed_error_), _Internal::kHasBitsOffset + 54, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preview_acceleration_reference = 59;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.preview_acceleration_reference_), _Internal::kHasBitsOffset + 55, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double vehicle_pitch = 60;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.vehicle_pitch_), _Internal::kHasBitsOffset + 56, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double slope_offset_compensation = 61;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.slope_offset_compensation_), _Internal::kHasBitsOffset + 57, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double path_remain = 62;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.path_remain_), _Internal::kHasBitsOffset + 58, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_lookup_offset = 63;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_lookup_offset_), _Internal::kHasBitsOffset + 59, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acceleration_vrf = 64;
    {PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.acceleration_vrf_), _Internal::kHasBitsOffset + 60, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
    {::_pbi::TcParser::GetTable<::control::common::TrajectoryPoint>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void SimpleMPCDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:control.SimpleMPCDebug)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matrix_q_updated_.Clear();
  _impl_.matrix_r_updated_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.current_matched_point_ != nullptr);
      _impl_.current_matched_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.current_reference_point_ != nullptr);
      _impl_.current_reference_point_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.preview_reference_point_ != nullptr);
      _impl_.preview_reference_point_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.lateral_error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.heading_error_rate_) -
        reinterpret_cast<char*>(&_impl_.lateral_error_)) + sizeof(_impl_.heading_error_rate_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.lateral_error_rate_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.steer_angle_heading_rate_contribution_) -
        reinterpret_cast<char*>(&_impl_.lateral_error_rate_)) + sizeof(_impl_.steer_angle_heading_rate_contribution_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.steer_angle_feedback_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.speed_error_) -
        reinterpret_cast<char*>(&_impl_.steer_angle_feedback_)) + sizeof(_impl_.speed_error_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.acceleration_reference_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.calibration_value_) -
        reinterpret_cast<char*>(&_impl_.acceleration_reference_)) + sizeof(_impl_.calibration_value_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.steer_unconstrained_control_diff_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.heading_acceleration_) -
        reinterpret_cast<char*>(&_impl_.steer_unconstrained_control_diff_)) + sizeof(_impl_.heading_acceleration_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.heading_error_acceleration_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.jerk_feedback_) -
        reinterpret_cast<char*>(&_impl_.heading_error_acceleration_)) + sizeof(_impl_.jerk_feedback_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.jerk_error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.preview_acceleration_reference_) -
        reinterpret_cast<char*>(&_impl_.jerk_error_)) + sizeof(_impl_.preview_acceleration_reference_));
  }
  if (cached_has_bits & 0x3f000000u) {
    ::memset(&_impl_.vehicle_pitch_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_full_stop_) -
        reinterpret_cast<char*>(&_impl_.vehicle_pitch_)) + sizeof(_impl_.is_full_stop_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SimpleMPCDebug::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.SimpleMPCDebug)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double lateral_error = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_lateral_error(), target);
  }

  // optional double ref_heading = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_ref_heading(), target);
  }

  // optional double heading = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_heading(), target);
  }

  // optional double heading_error = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_heading_error(), target);
  }

  // optional double heading_error_rate = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_heading_error_rate(), target);
  }

  // optional double lateral_error_rate = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_lateral_error_rate(), target);
  }

  // optional double curvature = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_curvature(), target);
  }

  // optional double steer_angle = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_steer_angle(), target);
  }

  // optional double steer_angle_feedforward = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_steer_angle_feedforward(), target);
  }

  // optional double steer_angle_lateral_contribution = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_steer_angle_lateral_contribution(), target);
  }

  // optional double steer_angle_lateral_rate_contribution = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_steer_angle_lateral_rate_contribution(), target);
  }

  // optional double steer_angle_heading_contribution = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_steer_angle_heading_contribution(), target);
  }

  // optional double steer_angle_heading_rate_contribution = 13;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_steer_angle_heading_rate_contribution(), target);
  }

  // optional double steer_angle_feedback = 14;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_steer_angle_feedback(), target);
  }

  // optional double steering_position = 15;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_steering_position(), target);
  }

  // optional double ref_speed = 16;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_ref_speed(), target);
  }

  // optional double steer_angle_limited = 17;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_steer_angle_limited(), target);
  }

  // optional double station_reference = 18;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        18, this->_internal_station_reference(), target);
  }

  // optional double station_error = 19;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        19, this->_internal_station_error(), target);
  }

  // optional double speed_reference = 20;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_speed_reference(), target);
  }

  // optional double speed_error = 21;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        21, this->_internal_speed_error(), target);
  }

  // optional double acceleration_reference = 22;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this->_internal_acceleration_reference(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool is_full_stop = 23;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        23, this->_internal_is_full_stop(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional double station_feedback = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        24, this->_internal_station_feedback(), target);
  }

  // optional double speed_feedback = 25;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        25, this->_internal_speed_feedback(), target);
  }

  // optional double acceleration_cmd_closeloop = 26;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        26, this->_internal_acceleration_cmd_closeloop(), target);
  }

  // optional double acceleration_cmd = 27;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        27, this->_internal_acceleration_cmd(), target);
  }

  // optional double acceleration_lookup = 28;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        28, this->_internal_acceleration_lookup(), target);
  }

  // optional double speed_lookup = 29;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        29, this->_internal_speed_lookup(), target);
  }

  // optional double calibration_value = 30;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        30, this->_internal_calibration_value(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double steer_unconstrained_control_diff = 31;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        31, this->_internal_steer_unconstrained_control_diff(), target);
  }

  // optional double steer_angle_feedforward_compensation = 32;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        32, this->_internal_steer_angle_feedforward_compensation(), target);
  }

  // repeated double matrix_q_updated = 33;
  for (int i = 0, n = this->_internal_matrix_q_updated_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        33, this->_internal_matrix_q_updated().Get(i), target);
  }

  // repeated double matrix_r_updated = 34;
  for (int i = 0, n = this->_internal_matrix_r_updated_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        34, this->_internal_matrix_r_updated().Get(i), target);
  }

  // optional double lateral_acceleration = 35;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        35, this->_internal_lateral_acceleration(), target);
  }

  // optional double lateral_jerk = 36;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        36, this->_internal_lateral_jerk(), target);
  }

  // optional double ref_heading_rate = 37;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        37, this->_internal_ref_heading_rate(), target);
  }

  // optional double heading_rate = 38;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        38, this->_internal_heading_rate(), target);
  }

  // optional double ref_heading_acceleration = 39;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        39, this->_internal_ref_heading_acceleration(), target);
  }

  // optional double heading_acceleration = 40;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        40, this->_internal_heading_acceleration(), target);
  }

  // optional double heading_error_acceleration = 41;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        41, this->_internal_heading_error_acceleration(), target);
  }

  // optional double ref_heading_jerk = 42;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        42, this->_internal_ref_heading_jerk(), target);
  }

  // optional double heading_jerk = 43;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        43, this->_internal_heading_jerk(), target);
  }

  // optional double heading_error_jerk = 44;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        44, this->_internal_heading_error_jerk(), target);
  }

  // optional double acceleration_feedback = 45;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        45, this->_internal_acceleration_feedback(), target);
  }

  // optional double acceleration_error = 46;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        46, this->_internal_acceleration_error(), target);
  }

  // optional double jerk_reference = 47;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        47, this->_internal_jerk_reference(), target);
  }

  // optional double jerk_feedback = 48;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        48, this->_internal_jerk_feedback(), target);
  }

  // optional double jerk_error = 49;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        49, this->_internal_jerk_error(), target);
  }

  // optional double lateral_error_feedback = 50;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        50, this->_internal_lateral_error_feedback(), target);
  }

  // optional double heading_error_feedback = 51;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        51, this->_internal_heading_error_feedback(), target);
  }

  // optional double steer_angle_feedback_augment = 52;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        52, this->_internal_steer_angle_feedback_augment(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .control.common.TrajectoryPoint current_matched_point = 53;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        53, *_impl_.current_matched_point_, _impl_.current_matched_point_->GetCachedSize(), target, stream);
  }

  // optional .control.common.TrajectoryPoint current_reference_point = 54;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        54, *_impl_.current_reference_point_, _impl_.current_reference_point_->GetCachedSize(), target, stream);
  }

  // optional .control.common.TrajectoryPoint preview_reference_point = 55;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        55, *_impl_.preview_reference_point_, _impl_.preview_reference_point_->GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double preview_station_error = 56;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        56, this->_internal_preview_station_error(), target);
  }

  // optional double preview_speed_reference = 57;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        57, this->_internal_preview_speed_reference(), target);
  }

  // optional double preview_speed_error = 58;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        58, this->_internal_preview_speed_error(), target);
  }

  // optional double preview_acceleration_reference = 59;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        59, this->_internal_preview_acceleration_reference(), target);
  }

  // optional double vehicle_pitch = 60;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        60, this->_internal_vehicle_pitch(), target);
  }

  // optional double slope_offset_compensation = 61;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        61, this->_internal_slope_offset_compensation(), target);
  }

  // optional double path_remain = 62;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        62, this->_internal_path_remain(), target);
  }

  // optional double acceleration_lookup_offset = 63;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        63, this->_internal_acceleration_lookup_offset(), target);
  }

  // optional double acceleration_vrf = 64;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        64, this->_internal_acceleration_vrf(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.SimpleMPCDebug)
  return target;
}

::size_t SimpleMPCDebug::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.SimpleMPCDebug)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
   {
    // repeated double matrix_q_updated = 33;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_matrix_q_updated_size())
      ;
      std::size_t tag_size = std::size_t{2} *
          ::_pbi::FromIntSize(this->_internal_matrix_q_updated_size());
      ;
      total_size += tag_size + data_size;
    }
    // repeated double matrix_r_updated = 34;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_matrix_r_updated_size())
      ;
      std::size_t tag_size = std::size_t{2} *
          ::_pbi::FromIntSize(this->_internal_matrix_r_updated_size());
      ;
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .control.common.TrajectoryPoint current_matched_point = 53;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.current_matched_point_);
    }
    // optional .control.common.TrajectoryPoint current_reference_point = 54;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.current_reference_point_);
    }
    // optional .control.common.TrajectoryPoint preview_reference_point = 55;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.preview_reference_point_);
    }
    // optional double lateral_error = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }
    // optional double ref_heading = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }
    // optional double heading = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }
    // optional double heading_error = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }
    // optional double heading_error_rate = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double lateral_error_rate = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double curvature = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional double steer_angle = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }
    // optional double steer_angle_feedforward = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }
    // optional double steer_angle_lateral_contribution = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 9;
    }
    // optional double steer_angle_lateral_rate_contribution = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 9;
    }
    // optional double steer_angle_heading_contribution = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += 9;
    }
    // optional double steer_angle_heading_rate_contribution = 13;
    if (cached_has_bits & 0x00008000u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double steer_angle_feedback = 14;
    if (cached_has_bits & 0x00010000u) {
      total_size += 9;
    }
    // optional double steering_position = 15;
    if (cached_has_bits & 0x00020000u) {
      total_size += 9;
    }
    // optional double ref_speed = 16;
    if (cached_has_bits & 0x00040000u) {
      total_size += 10;
    }
    // optional double steer_angle_limited = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 10;
    }
    // optional double station_reference = 18;
    if (cached_has_bits & 0x00100000u) {
      total_size += 10;
    }
    // optional double station_error = 19;
    if (cached_has_bits & 0x00200000u) {
      total_size += 10;
    }
    // optional double speed_reference = 20;
    if (cached_has_bits & 0x00400000u) {
      total_size += 10;
    }
    // optional double speed_error = 21;
    if (cached_has_bits & 0x00800000u) {
      total_size += 10;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    // optional double acceleration_reference = 22;
    if (cached_has_bits & 0x01000000u) {
      total_size += 10;
    }
    // optional double station_feedback = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 10;
    }
    // optional double speed_feedback = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 10;
    }
    // optional double acceleration_cmd_closeloop = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 10;
    }
    // optional double acceleration_cmd = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 10;
    }
    // optional double acceleration_lookup = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 10;
    }
    // optional double speed_lookup = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 10;
    }
    // optional double calibration_value = 30;
    if (cached_has_bits & 0x80000000u) {
      total_size += 10;
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional double steer_unconstrained_control_diff = 31;
    if (cached_has_bits & 0x00000001u) {
      total_size += 10;
    }
    // optional double steer_angle_feedforward_compensation = 32;
    if (cached_has_bits & 0x00000002u) {
      total_size += 10;
    }
    // optional double lateral_acceleration = 35;
    if (cached_has_bits & 0x00000004u) {
      total_size += 10;
    }
    // optional double lateral_jerk = 36;
    if (cached_has_bits & 0x00000008u) {
      total_size += 10;
    }
    // optional double ref_heading_rate = 37;
    if (cached_has_bits & 0x00000010u) {
      total_size += 10;
    }
    // optional double heading_rate = 38;
    if (cached_has_bits & 0x00000020u) {
      total_size += 10;
    }
    // optional double ref_heading_acceleration = 39;
    if (cached_has_bits & 0x00000040u) {
      total_size += 10;
    }
    // optional double heading_acceleration = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 10;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double heading_error_acceleration = 41;
    if (cached_has_bits & 0x00000100u) {
      total_size += 10;
    }
    // optional double ref_heading_jerk = 42;
    if (cached_has_bits & 0x00000200u) {
      total_size += 10;
    }
    // optional double heading_jerk = 43;
    if (cached_has_bits & 0x00000400u) {
      total_size += 10;
    }
    // optional double heading_error_jerk = 44;
    if (cached_has_bits & 0x00000800u) {
      total_size += 10;
    }
    // optional double acceleration_feedback = 45;
    if (cached_has_bits & 0x00001000u) {
      total_size += 10;
    }
    // optional double acceleration_error = 46;
    if (cached_has_bits & 0x00002000u) {
      total_size += 10;
    }
    // optional double jerk_reference = 47;
    if (cached_has_bits & 0x00004000u) {
      total_size += 10;
    }
    // optional double jerk_feedback = 48;
    if (cached_has_bits & 0x00008000u) {
      total_size += 10;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double jerk_error = 49;
    if (cached_has_bits & 0x00010000u) {
      total_size += 10;
    }
    // optional double lateral_error_feedback = 50;
    if (cached_has_bits & 0x00020000u) {
      total_size += 10;
    }
    // optional double heading_error_feedback = 51;
    if (cached_has_bits & 0x00040000u) {
      total_size += 10;
    }
    // optional double steer_angle_feedback_augment = 52;
    if (cached_has_bits & 0x00080000u) {
      total_size += 10;
    }
    // optional double preview_station_error = 56;
    if (cached_has_bits & 0x00100000u) {
      total_size += 10;
    }
    // optional double preview_speed_reference = 57;
    if (cached_has_bits & 0x00200000u) {
      total_size += 10;
    }
    // optional double preview_speed_error = 58;
    if (cached_has_bits & 0x00400000u) {
      total_size += 10;
    }
    // optional double preview_acceleration_reference = 59;
    if (cached_has_bits & 0x00800000u) {
      total_size += 10;
    }
  }
  if (cached_has_bits & 0x3f000000u) {
    // optional double vehicle_pitch = 60;
    if (cached_has_bits & 0x01000000u) {
      total_size += 10;
    }
    // optional double slope_offset_compensation = 61;
    if (cached_has_bits & 0x02000000u) {
      total_size += 10;
    }
    // optional double path_remain = 62;
    if (cached_has_bits & 0x04000000u) {
      total_size += 10;
    }
    // optional double acceleration_lookup_offset = 63;
    if (cached_has_bits & 0x08000000u) {
      total_size += 10;
    }
    // optional double acceleration_vrf = 64;
    if (cached_has_bits & 0x10000000u) {
      total_size += 10;
    }
    // optional bool is_full_stop = 23;
    if (cached_has_bits & 0x20000000u) {
      total_size += 3;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void SimpleMPCDebug::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SimpleMPCDebug*>(&to_msg);
  auto& from = static_cast<const SimpleMPCDebug&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.SimpleMPCDebug)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_matrix_q_updated()->MergeFrom(from._internal_matrix_q_updated());
  _this->_internal_mutable_matrix_r_updated()->MergeFrom(from._internal_matrix_r_updated());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.current_matched_point_ != nullptr);
      if (_this->_impl_.current_matched_point_ == nullptr) {
        _this->_impl_.current_matched_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.current_matched_point_);
      } else {
        _this->_impl_.current_matched_point_->MergeFrom(*from._impl_.current_matched_point_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.current_reference_point_ != nullptr);
      if (_this->_impl_.current_reference_point_ == nullptr) {
        _this->_impl_.current_reference_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.current_reference_point_);
      } else {
        _this->_impl_.current_reference_point_->MergeFrom(*from._impl_.current_reference_point_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.preview_reference_point_ != nullptr);
      if (_this->_impl_.preview_reference_point_ == nullptr) {
        _this->_impl_.preview_reference_point_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::TrajectoryPoint>(arena, *from._impl_.preview_reference_point_);
      } else {
        _this->_impl_.preview_reference_point_->MergeFrom(*from._impl_.preview_reference_point_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lateral_error_ = from._impl_.lateral_error_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ref_heading_ = from._impl_.ref_heading_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.heading_ = from._impl_.heading_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.heading_error_ = from._impl_.heading_error_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.heading_error_rate_ = from._impl_.heading_error_rate_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.lateral_error_rate_ = from._impl_.lateral_error_rate_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.curvature_ = from._impl_.curvature_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.steer_angle_ = from._impl_.steer_angle_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.steer_angle_feedforward_ = from._impl_.steer_angle_feedforward_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.steer_angle_lateral_contribution_ = from._impl_.steer_angle_lateral_contribution_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.steer_angle_lateral_rate_contribution_ = from._impl_.steer_angle_lateral_rate_contribution_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.steer_angle_heading_contribution_ = from._impl_.steer_angle_heading_contribution_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.steer_angle_heading_rate_contribution_ = from._impl_.steer_angle_heading_rate_contribution_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.steer_angle_feedback_ = from._impl_.steer_angle_feedback_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.steering_position_ = from._impl_.steering_position_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.ref_speed_ = from._impl_.ref_speed_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.steer_angle_limited_ = from._impl_.steer_angle_limited_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.station_reference_ = from._impl_.station_reference_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.station_error_ = from._impl_.station_error_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.speed_reference_ = from._impl_.speed_reference_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.speed_error_ = from._impl_.speed_error_;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.acceleration_reference_ = from._impl_.acceleration_reference_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.station_feedback_ = from._impl_.station_feedback_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.speed_feedback_ = from._impl_.speed_feedback_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.acceleration_cmd_closeloop_ = from._impl_.acceleration_cmd_closeloop_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.acceleration_cmd_ = from._impl_.acceleration_cmd_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.acceleration_lookup_ = from._impl_.acceleration_lookup_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.speed_lookup_ = from._impl_.speed_lookup_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.calibration_value_ = from._impl_.calibration_value_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steer_unconstrained_control_diff_ = from._impl_.steer_unconstrained_control_diff_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steer_angle_feedforward_compensation_ = from._impl_.steer_angle_feedforward_compensation_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lateral_acceleration_ = from._impl_.lateral_acceleration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lateral_jerk_ = from._impl_.lateral_jerk_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ref_heading_rate_ = from._impl_.ref_heading_rate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.heading_rate_ = from._impl_.heading_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ref_heading_acceleration_ = from._impl_.ref_heading_acceleration_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.heading_acceleration_ = from._impl_.heading_acceleration_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.heading_error_acceleration_ = from._impl_.heading_error_acceleration_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ref_heading_jerk_ = from._impl_.ref_heading_jerk_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.heading_jerk_ = from._impl_.heading_jerk_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.heading_error_jerk_ = from._impl_.heading_error_jerk_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.acceleration_feedback_ = from._impl_.acceleration_feedback_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.acceleration_error_ = from._impl_.acceleration_error_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.jerk_reference_ = from._impl_.jerk_reference_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.jerk_feedback_ = from._impl_.jerk_feedback_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.jerk_error_ = from._impl_.jerk_error_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.lateral_error_feedback_ = from._impl_.lateral_error_feedback_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.heading_error_feedback_ = from._impl_.heading_error_feedback_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.steer_angle_feedback_augment_ = from._impl_.steer_angle_feedback_augment_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.preview_station_error_ = from._impl_.preview_station_error_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.preview_speed_reference_ = from._impl_.preview_speed_reference_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.preview_speed_error_ = from._impl_.preview_speed_error_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.preview_acceleration_reference_ = from._impl_.preview_acceleration_reference_;
    }
  }
  if (cached_has_bits & 0x3f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.vehicle_pitch_ = from._impl_.vehicle_pitch_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.slope_offset_compensation_ = from._impl_.slope_offset_compensation_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.path_remain_ = from._impl_.path_remain_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.acceleration_lookup_offset_ = from._impl_.acceleration_lookup_offset_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.acceleration_vrf_ = from._impl_.acceleration_vrf_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.is_full_stop_ = from._impl_.is_full_stop_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SimpleMPCDebug::CopyFrom(const SimpleMPCDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.SimpleMPCDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SimpleMPCDebug::InternalSwap(SimpleMPCDebug* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.matrix_q_updated_.InternalSwap(&other->_impl_.matrix_q_updated_);
  _impl_.matrix_r_updated_.InternalSwap(&other->_impl_.matrix_r_updated_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.is_full_stop_)
      + sizeof(SimpleMPCDebug::_impl_.is_full_stop_)
      - PROTOBUF_FIELD_OFFSET(SimpleMPCDebug, _impl_.current_matched_point_)>(
          reinterpret_cast<char*>(&_impl_.current_matched_point_),
          reinterpret_cast<char*>(&other->_impl_.current_matched_point_));
}

::google::protobuf::Metadata SimpleMPCDebug::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MracDebug::_Internal {
 public:
  using HasBits =
      decltype(std::declval<MracDebug>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MracDebug, _impl_._has_bits_);
};

MracDebug::MracDebug(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.MracDebug)
}
inline PROTOBUF_NDEBUG_INLINE MracDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::MracDebug& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        mrac_reference_state_{visibility, arena, from.mrac_reference_state_},
        mrac_state_error_{visibility, arena, from.mrac_state_error_} {}

MracDebug::MracDebug(
    ::google::protobuf::Arena* arena,
    const MracDebug& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MracDebug* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.mrac_adaptive_gain_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::MracAdaptiveGain>(
                              arena, *from._impl_.mrac_adaptive_gain_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, mrac_model_order_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, mrac_model_order_),
           offsetof(Impl_, mrac_control_saturation_status_) -
               offsetof(Impl_, mrac_model_order_) +
               sizeof(Impl_::mrac_control_saturation_status_));

  // @@protoc_insertion_point(copy_constructor:control.MracDebug)
}
inline PROTOBUF_NDEBUG_INLINE MracDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        mrac_reference_state_{visibility, arena},
        mrac_state_error_{visibility, arena} {}

inline void MracDebug::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, mrac_adaptive_gain_),
           0,
           offsetof(Impl_, mrac_control_saturation_status_) -
               offsetof(Impl_, mrac_adaptive_gain_) +
               sizeof(Impl_::mrac_control_saturation_status_));
}
MracDebug::~MracDebug() {
  // @@protoc_insertion_point(destructor:control.MracDebug)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MracDebug::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.mrac_adaptive_gain_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    MracDebug::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &MracDebug::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<MracDebug>(),
            ::google::protobuf::Message::GetNewImpl<MracDebug>(),
            ::google::protobuf::Message::GetClearImpl<MracDebug>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<MracDebug>(),
                ::google::protobuf::Message::GetSerializeImpl<MracDebug>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(MracDebug, _impl_._cached_size_),
            false,
        },
        &MracDebug::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* MracDebug::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2> MracDebug::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MracDebug, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MracDebug_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::MracDebug>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 mrac_model_order = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MracDebug, _impl_.mrac_model_order_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_model_order_)}},
    // repeated double mrac_reference_state = 2;
    {::_pbi::TcParser::FastF64R1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_reference_state_)}},
    // repeated double mrac_state_error = 3;
    {::_pbi::TcParser::FastF64R1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_state_error_)}},
    // optional .control.MracAdaptiveGain mrac_adaptive_gain = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_adaptive_gain_)}},
    // optional int32 mrac_reference_saturation_status = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MracDebug, _impl_.mrac_reference_saturation_status_), 2>(),
     {40, 2, 0, PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_reference_saturation_status_)}},
    // optional int32 mrac_control_saturation_status = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MracDebug, _impl_.mrac_control_saturation_status_), 3>(),
     {48, 3, 0, PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_control_saturation_status_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 mrac_model_order = 1;
    {PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_model_order_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated double mrac_reference_state = 2;
    {PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_reference_state_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated double mrac_state_error = 3;
    {PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_state_error_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // optional .control.MracAdaptiveGain mrac_adaptive_gain = 4;
    {PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_adaptive_gain_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 mrac_reference_saturation_status = 5;
    {PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_reference_saturation_status_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 mrac_control_saturation_status = 6;
    {PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_control_saturation_status_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::MracAdaptiveGain>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void MracDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:control.MracDebug)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mrac_reference_state_.Clear();
  _impl_.mrac_state_error_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.mrac_adaptive_gain_ != nullptr);
    _impl_.mrac_adaptive_gain_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.mrac_model_order_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mrac_control_saturation_status_) -
        reinterpret_cast<char*>(&_impl_.mrac_model_order_)) + sizeof(_impl_.mrac_control_saturation_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* MracDebug::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.MracDebug)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 mrac_model_order = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_mrac_model_order(), target);
  }

  // repeated double mrac_reference_state = 2;
  for (int i = 0, n = this->_internal_mrac_reference_state_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_mrac_reference_state().Get(i), target);
  }

  // repeated double mrac_state_error = 3;
  for (int i = 0, n = this->_internal_mrac_state_error_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_mrac_state_error().Get(i), target);
  }

  // optional .control.MracAdaptiveGain mrac_adaptive_gain = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *_impl_.mrac_adaptive_gain_, _impl_.mrac_adaptive_gain_->GetCachedSize(), target, stream);
  }

  // optional int32 mrac_reference_saturation_status = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_mrac_reference_saturation_status(), target);
  }

  // optional int32 mrac_control_saturation_status = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_mrac_control_saturation_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.MracDebug)
  return target;
}

::size_t MracDebug::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.MracDebug)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
   {
    // repeated double mrac_reference_state = 2;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_mrac_reference_state_size())
      ;
      std::size_t tag_size = std::size_t{1} *
          ::_pbi::FromIntSize(this->_internal_mrac_reference_state_size());
      ;
      total_size += tag_size + data_size;
    }
    // repeated double mrac_state_error = 3;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_mrac_state_error_size())
      ;
      std::size_t tag_size = std::size_t{1} *
          ::_pbi::FromIntSize(this->_internal_mrac_state_error_size());
      ;
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .control.MracAdaptiveGain mrac_adaptive_gain = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.mrac_adaptive_gain_);
    }
    // optional int32 mrac_model_order = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_mrac_model_order());
    }
    // optional int32 mrac_reference_saturation_status = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_mrac_reference_saturation_status());
    }
    // optional int32 mrac_control_saturation_status = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_mrac_control_saturation_status());
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void MracDebug::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MracDebug*>(&to_msg);
  auto& from = static_cast<const MracDebug&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.MracDebug)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_mrac_reference_state()->MergeFrom(from._internal_mrac_reference_state());
  _this->_internal_mutable_mrac_state_error()->MergeFrom(from._internal_mrac_state_error());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.mrac_adaptive_gain_ != nullptr);
      if (_this->_impl_.mrac_adaptive_gain_ == nullptr) {
        _this->_impl_.mrac_adaptive_gain_ =
            ::google::protobuf::Message::CopyConstruct<::control::MracAdaptiveGain>(arena, *from._impl_.mrac_adaptive_gain_);
      } else {
        _this->_impl_.mrac_adaptive_gain_->MergeFrom(*from._impl_.mrac_adaptive_gain_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mrac_model_order_ = from._impl_.mrac_model_order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mrac_reference_saturation_status_ = from._impl_.mrac_reference_saturation_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mrac_control_saturation_status_ = from._impl_.mrac_control_saturation_status_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MracDebug::CopyFrom(const MracDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.MracDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MracDebug::InternalSwap(MracDebug* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mrac_reference_state_.InternalSwap(&other->_impl_.mrac_reference_state_);
  _impl_.mrac_state_error_.InternalSwap(&other->_impl_.mrac_state_error_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_control_saturation_status_)
      + sizeof(MracDebug::_impl_.mrac_control_saturation_status_)
      - PROTOBUF_FIELD_OFFSET(MracDebug, _impl_.mrac_adaptive_gain_)>(
          reinterpret_cast<char*>(&_impl_.mrac_adaptive_gain_),
          reinterpret_cast<char*>(&other->_impl_.mrac_adaptive_gain_));
}

::google::protobuf::Metadata MracDebug::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MracAdaptiveGain::_Internal {
 public:
};

MracAdaptiveGain::MracAdaptiveGain(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.MracAdaptiveGain)
}
inline PROTOBUF_NDEBUG_INLINE MracAdaptiveGain::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::MracAdaptiveGain& from_msg)
      : state_adaptive_gain_{visibility, arena, from.state_adaptive_gain_},
        input_adaptive_gain_{visibility, arena, from.input_adaptive_gain_},
        nonlinear_adaptive_gain_{visibility, arena, from.nonlinear_adaptive_gain_},
        _cached_size_{0} {}

MracAdaptiveGain::MracAdaptiveGain(
    ::google::protobuf::Arena* arena,
    const MracAdaptiveGain& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MracAdaptiveGain* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:control.MracAdaptiveGain)
}
inline PROTOBUF_NDEBUG_INLINE MracAdaptiveGain::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : state_adaptive_gain_{visibility, arena},
        input_adaptive_gain_{visibility, arena},
        nonlinear_adaptive_gain_{visibility, arena},
        _cached_size_{0} {}

inline void MracAdaptiveGain::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
MracAdaptiveGain::~MracAdaptiveGain() {
  // @@protoc_insertion_point(destructor:control.MracAdaptiveGain)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MracAdaptiveGain::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    MracAdaptiveGain::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &MracAdaptiveGain::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<MracAdaptiveGain>(),
            ::google::protobuf::Message::GetNewImpl<MracAdaptiveGain>(),
            ::google::protobuf::Message::GetClearImpl<MracAdaptiveGain>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<MracAdaptiveGain>(),
                ::google::protobuf::Message::GetSerializeImpl<MracAdaptiveGain>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_._cached_size_),
            false,
        },
        &MracAdaptiveGain::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* MracAdaptiveGain::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> MracAdaptiveGain::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_MracAdaptiveGain_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::MracAdaptiveGain>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated double state_adaptive_gain = 1;
    {::_pbi::TcParser::FastF64R1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_.state_adaptive_gain_)}},
    // repeated double input_adaptive_gain = 2;
    {::_pbi::TcParser::FastF64R1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_.input_adaptive_gain_)}},
    // repeated double nonlinear_adaptive_gain = 3;
    {::_pbi::TcParser::FastF64R1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_.nonlinear_adaptive_gain_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated double state_adaptive_gain = 1;
    {PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_.state_adaptive_gain_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated double input_adaptive_gain = 2;
    {PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_.input_adaptive_gain_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated double nonlinear_adaptive_gain = 3;
    {PROTOBUF_FIELD_OFFSET(MracAdaptiveGain, _impl_.nonlinear_adaptive_gain_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void MracAdaptiveGain::Clear() {
// @@protoc_insertion_point(message_clear_start:control.MracAdaptiveGain)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_adaptive_gain_.Clear();
  _impl_.input_adaptive_gain_.Clear();
  _impl_.nonlinear_adaptive_gain_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* MracAdaptiveGain::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.MracAdaptiveGain)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated double state_adaptive_gain = 1;
  for (int i = 0, n = this->_internal_state_adaptive_gain_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_state_adaptive_gain().Get(i), target);
  }

  // repeated double input_adaptive_gain = 2;
  for (int i = 0, n = this->_internal_input_adaptive_gain_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_input_adaptive_gain().Get(i), target);
  }

  // repeated double nonlinear_adaptive_gain = 3;
  for (int i = 0, n = this->_internal_nonlinear_adaptive_gain_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_nonlinear_adaptive_gain().Get(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.MracAdaptiveGain)
  return target;
}

::size_t MracAdaptiveGain::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.MracAdaptiveGain)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
   {
    // repeated double state_adaptive_gain = 1;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_state_adaptive_gain_size())
      ;
      std::size_t tag_size = std::size_t{1} *
          ::_pbi::FromIntSize(this->_internal_state_adaptive_gain_size());
      ;
      total_size += tag_size + data_size;
    }
    // repeated double input_adaptive_gain = 2;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_input_adaptive_gain_size())
      ;
      std::size_t tag_size = std::size_t{1} *
          ::_pbi::FromIntSize(this->_internal_input_adaptive_gain_size());
      ;
      total_size += tag_size + data_size;
    }
    // repeated double nonlinear_adaptive_gain = 3;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_nonlinear_adaptive_gain_size())
      ;
      std::size_t tag_size = std::size_t{1} *
          ::_pbi::FromIntSize(this->_internal_nonlinear_adaptive_gain_size());
      ;
      total_size += tag_size + data_size;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void MracAdaptiveGain::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MracAdaptiveGain*>(&to_msg);
  auto& from = static_cast<const MracAdaptiveGain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.MracAdaptiveGain)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_state_adaptive_gain()->MergeFrom(from._internal_state_adaptive_gain());
  _this->_internal_mutable_input_adaptive_gain()->MergeFrom(from._internal_input_adaptive_gain());
  _this->_internal_mutable_nonlinear_adaptive_gain()->MergeFrom(from._internal_nonlinear_adaptive_gain());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MracAdaptiveGain::CopyFrom(const MracAdaptiveGain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.MracAdaptiveGain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MracAdaptiveGain::InternalSwap(MracAdaptiveGain* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.state_adaptive_gain_.InternalSwap(&other->_impl_.state_adaptive_gain_);
  _impl_.input_adaptive_gain_.InternalSwap(&other->_impl_.input_adaptive_gain_);
  _impl_.nonlinear_adaptive_gain_.InternalSwap(&other->_impl_.nonlinear_adaptive_gain_);
}

::google::protobuf::Metadata MracAdaptiveGain::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Debug::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Debug>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Debug, _impl_._has_bits_);
};

void Debug::clear_input_debug() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_debug_ != nullptr) _impl_.input_debug_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
Debug::Debug(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.Debug)
}
inline PROTOBUF_NDEBUG_INLINE Debug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::Debug& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Debug::Debug(
    ::google::protobuf::Arena* arena,
    const Debug& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Debug* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.simple_lon_debug_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::SimpleLongitudinalDebug>(
                              arena, *from._impl_.simple_lon_debug_)
                        : nullptr;
  _impl_.simple_lat_debug_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::SimpleLateralDebug>(
                              arena, *from._impl_.simple_lat_debug_)
                        : nullptr;
  _impl_.input_debug_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::control::InputDebug>(
                              arena, *from._impl_.input_debug_)
                        : nullptr;
  _impl_.simple_mpc_debug_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::control::SimpleMPCDebug>(
                              arena, *from._impl_.simple_mpc_debug_)
                        : nullptr;
  _impl_.lodmc_debug_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::Message::CopyConstruct<::control::LodmcDebug>(
                              arena, *from._impl_.lodmc_debug_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:control.Debug)
}
inline PROTOBUF_NDEBUG_INLINE Debug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Debug::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, simple_lon_debug_),
           0,
           offsetof(Impl_, lodmc_debug_) -
               offsetof(Impl_, simple_lon_debug_) +
               sizeof(Impl_::lodmc_debug_));
}
Debug::~Debug() {
  // @@protoc_insertion_point(destructor:control.Debug)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Debug::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.simple_lon_debug_;
  delete _impl_.simple_lat_debug_;
  delete _impl_.input_debug_;
  delete _impl_.simple_mpc_debug_;
  delete _impl_.lodmc_debug_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Debug::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Debug::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Debug>(),
            ::google::protobuf::Message::GetNewImpl<Debug>(),
            ::google::protobuf::Message::GetClearImpl<Debug>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<Debug>(),
                ::google::protobuf::Message::GetSerializeImpl<Debug>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Debug, _impl_._cached_size_),
            false,
        },
        &Debug::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Debug::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> Debug::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Debug, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Debug_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::Debug>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .control.SimpleLongitudinalDebug simple_lon_debug = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_lon_debug_)}},
    // optional .control.SimpleLateralDebug simple_lat_debug = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_lat_debug_)}},
    // optional .control.InputDebug input_debug = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(Debug, _impl_.input_debug_)}},
    // optional .control.SimpleMPCDebug simple_mpc_debug = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_mpc_debug_)}},
    // optional .control.LodmcDebug lodmc_debug = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 4, 4, PROTOBUF_FIELD_OFFSET(Debug, _impl_.lodmc_debug_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .control.SimpleLongitudinalDebug simple_lon_debug = 1;
    {PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_lon_debug_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.SimpleLateralDebug simple_lat_debug = 2;
    {PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_lat_debug_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.InputDebug input_debug = 3;
    {PROTOBUF_FIELD_OFFSET(Debug, _impl_.input_debug_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.SimpleMPCDebug simple_mpc_debug = 4;
    {PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_mpc_debug_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.LodmcDebug lodmc_debug = 5;
    {PROTOBUF_FIELD_OFFSET(Debug, _impl_.lodmc_debug_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::SimpleLongitudinalDebug>()},
    {::_pbi::TcParser::GetTable<::control::SimpleLateralDebug>()},
    {::_pbi::TcParser::GetTable<::control::InputDebug>()},
    {::_pbi::TcParser::GetTable<::control::SimpleMPCDebug>()},
    {::_pbi::TcParser::GetTable<::control::LodmcDebug>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Debug::Clear() {
// @@protoc_insertion_point(message_clear_start:control.Debug)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.simple_lon_debug_ != nullptr);
      _impl_.simple_lon_debug_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.simple_lat_debug_ != nullptr);
      _impl_.simple_lat_debug_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.input_debug_ != nullptr);
      _impl_.input_debug_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.simple_mpc_debug_ != nullptr);
      _impl_.simple_mpc_debug_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.lodmc_debug_ != nullptr);
      _impl_.lodmc_debug_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Debug::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.Debug)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .control.SimpleLongitudinalDebug simple_lon_debug = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *_impl_.simple_lon_debug_, _impl_.simple_lon_debug_->GetCachedSize(), target, stream);
  }

  // optional .control.SimpleLateralDebug simple_lat_debug = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *_impl_.simple_lat_debug_, _impl_.simple_lat_debug_->GetCachedSize(), target, stream);
  }

  // optional .control.InputDebug input_debug = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *_impl_.input_debug_, _impl_.input_debug_->GetCachedSize(), target, stream);
  }

  // optional .control.SimpleMPCDebug simple_mpc_debug = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *_impl_.simple_mpc_debug_, _impl_.simple_mpc_debug_->GetCachedSize(), target, stream);
  }

  // optional .control.LodmcDebug lodmc_debug = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *_impl_.lodmc_debug_, _impl_.lodmc_debug_->GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.Debug)
  return target;
}

::size_t Debug::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.Debug)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .control.SimpleLongitudinalDebug simple_lon_debug = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.simple_lon_debug_);
    }
    // optional .control.SimpleLateralDebug simple_lat_debug = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.simple_lat_debug_);
    }
    // optional .control.InputDebug input_debug = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.input_debug_);
    }
    // optional .control.SimpleMPCDebug simple_mpc_debug = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.simple_mpc_debug_);
    }
    // optional .control.LodmcDebug lodmc_debug = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.lodmc_debug_);
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void Debug::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Debug*>(&to_msg);
  auto& from = static_cast<const Debug&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.Debug)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.simple_lon_debug_ != nullptr);
      if (_this->_impl_.simple_lon_debug_ == nullptr) {
        _this->_impl_.simple_lon_debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::SimpleLongitudinalDebug>(arena, *from._impl_.simple_lon_debug_);
      } else {
        _this->_impl_.simple_lon_debug_->MergeFrom(*from._impl_.simple_lon_debug_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.simple_lat_debug_ != nullptr);
      if (_this->_impl_.simple_lat_debug_ == nullptr) {
        _this->_impl_.simple_lat_debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::SimpleLateralDebug>(arena, *from._impl_.simple_lat_debug_);
      } else {
        _this->_impl_.simple_lat_debug_->MergeFrom(*from._impl_.simple_lat_debug_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.input_debug_ != nullptr);
      if (_this->_impl_.input_debug_ == nullptr) {
        _this->_impl_.input_debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::InputDebug>(arena, *from._impl_.input_debug_);
      } else {
        _this->_impl_.input_debug_->MergeFrom(*from._impl_.input_debug_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.simple_mpc_debug_ != nullptr);
      if (_this->_impl_.simple_mpc_debug_ == nullptr) {
        _this->_impl_.simple_mpc_debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::SimpleMPCDebug>(arena, *from._impl_.simple_mpc_debug_);
      } else {
        _this->_impl_.simple_mpc_debug_->MergeFrom(*from._impl_.simple_mpc_debug_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.lodmc_debug_ != nullptr);
      if (_this->_impl_.lodmc_debug_ == nullptr) {
        _this->_impl_.lodmc_debug_ =
            ::google::protobuf::Message::CopyConstruct<::control::LodmcDebug>(arena, *from._impl_.lodmc_debug_);
      } else {
        _this->_impl_.lodmc_debug_->MergeFrom(*from._impl_.lodmc_debug_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Debug::CopyFrom(const Debug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.Debug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Debug::InternalSwap(Debug* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Debug, _impl_.lodmc_debug_)
      + sizeof(Debug::_impl_.lodmc_debug_)
      - PROTOBUF_FIELD_OFFSET(Debug, _impl_.simple_lon_debug_)>(
          reinterpret_cast<char*>(&_impl_.simple_lon_debug_),
          reinterpret_cast<char*>(&other->_impl_.simple_lon_debug_));
}

::google::protobuf::Metadata Debug::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LodmcDebug::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LodmcDebug>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_._has_bits_);
};

LodmcDebug::LodmcDebug(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.LodmcDebug)
}
LodmcDebug::LodmcDebug(
    ::google::protobuf::Arena* arena, const LodmcDebug& from)
    : LodmcDebug(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE LodmcDebug::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LodmcDebug::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, torq_command_),
           0,
           offsetof(Impl_, target_acc_filter_) -
               offsetof(Impl_, torq_command_) +
               sizeof(Impl_::target_acc_filter_));
}
LodmcDebug::~LodmcDebug() {
  // @@protoc_insertion_point(destructor:control.LodmcDebug)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LodmcDebug::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    LodmcDebug::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &LodmcDebug::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<LodmcDebug>(),
            ::google::protobuf::Message::GetNewImpl<LodmcDebug>(),
            ::google::protobuf::Message::GetClearImpl<LodmcDebug>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<LodmcDebug>(),
                ::google::protobuf::Message::GetSerializeImpl<LodmcDebug>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_._cached_size_),
            false,
        },
        &LodmcDebug::kDescriptorMethods,
        &descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* LodmcDebug::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 0, 0, 2> LodmcDebug::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_._has_bits_),
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LodmcDebug_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::LodmcDebug>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double torq_command = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_command_)}},
    // optional double torq_feed_forward = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_feed_forward_)}},
    // optional double torq_feed_back = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_feed_back_)}},
    // optional double dmc_f_roll = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 3, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_roll_)}},
    // optional double dmc_f_air = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_air_)}},
    // optional double dmc_f_slope = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 5, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_slope_)}},
    // optional double dmc_f_acc = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 6, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_acc_)}},
    // optional double acc_error = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 7, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.acc_error_)}},
    // optional double mass = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 8, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.mass_)}},
    // optional double target_acc = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 9, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.target_acc_)}},
    // optional double vehilce_acc = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 10, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.vehilce_acc_)}},
    // optional double vehspeed = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 11, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.vehspeed_)}},
    // optional double roadslope = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 12, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.roadslope_)}},
    // optional double target_acc_filter = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 13, 0, PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.target_acc_filter_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double torq_command = 1;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_command_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double torq_feed_forward = 2;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_feed_forward_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double torq_feed_back = 3;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_feed_back_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double dmc_f_roll = 4;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_roll_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double dmc_f_air = 5;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_air_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double dmc_f_slope = 6;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_slope_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double dmc_f_acc = 7;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.dmc_f_acc_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double acc_error = 8;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.acc_error_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double mass = 9;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.mass_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double target_acc = 10;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.target_acc_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double vehilce_acc = 11;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.vehilce_acc_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double vehspeed = 12;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.vehspeed_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double roadslope = 13;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.roadslope_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double target_acc_filter = 14;
    {PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.target_acc_filter_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void LodmcDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:control.LodmcDebug)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.torq_command_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.acc_error_) -
        reinterpret_cast<char*>(&_impl_.torq_command_)) + sizeof(_impl_.acc_error_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.mass_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.target_acc_filter_) -
        reinterpret_cast<char*>(&_impl_.mass_)) + sizeof(_impl_.target_acc_filter_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* LodmcDebug::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.LodmcDebug)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double torq_command = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_torq_command(), target);
  }

  // optional double torq_feed_forward = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_torq_feed_forward(), target);
  }

  // optional double torq_feed_back = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_torq_feed_back(), target);
  }

  // optional double dmc_f_roll = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_dmc_f_roll(), target);
  }

  // optional double dmc_f_air = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_dmc_f_air(), target);
  }

  // optional double dmc_f_slope = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_dmc_f_slope(), target);
  }

  // optional double dmc_f_acc = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_dmc_f_acc(), target);
  }

  // optional double acc_error = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_acc_error(), target);
  }

  // optional double mass = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_mass(), target);
  }

  // optional double target_acc = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_target_acc(), target);
  }

  // optional double vehilce_acc = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_vehilce_acc(), target);
  }

  // optional double vehspeed = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_vehspeed(), target);
  }

  // optional double roadslope = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_roadslope(), target);
  }

  // optional double target_acc_filter = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_target_acc_filter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.LodmcDebug)
  return target;
}

::size_t LodmcDebug::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.LodmcDebug)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double torq_command = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }
    // optional double torq_feed_forward = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }
    // optional double torq_feed_back = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }
    // optional double dmc_f_roll = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }
    // optional double dmc_f_air = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }
    // optional double dmc_f_slope = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }
    // optional double dmc_f_acc = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }
    // optional double acc_error = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    // optional double mass = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double target_acc = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional double vehilce_acc = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }
    // optional double vehspeed = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }
    // optional double roadslope = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 9;
    }
    // optional double target_acc_filter = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 9;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void LodmcDebug::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LodmcDebug*>(&to_msg);
  auto& from = static_cast<const LodmcDebug&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.LodmcDebug)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.torq_command_ = from._impl_.torq_command_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.torq_feed_forward_ = from._impl_.torq_feed_forward_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.torq_feed_back_ = from._impl_.torq_feed_back_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dmc_f_roll_ = from._impl_.dmc_f_roll_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dmc_f_air_ = from._impl_.dmc_f_air_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dmc_f_slope_ = from._impl_.dmc_f_slope_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.dmc_f_acc_ = from._impl_.dmc_f_acc_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.acc_error_ = from._impl_.acc_error_;
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.mass_ = from._impl_.mass_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.target_acc_ = from._impl_.target_acc_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.vehilce_acc_ = from._impl_.vehilce_acc_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.vehspeed_ = from._impl_.vehspeed_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.roadslope_ = from._impl_.roadslope_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.target_acc_filter_ = from._impl_.target_acc_filter_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LodmcDebug::CopyFrom(const LodmcDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.LodmcDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LodmcDebug::InternalSwap(LodmcDebug* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.target_acc_filter_)
      + sizeof(LodmcDebug::_impl_.target_acc_filter_)
      - PROTOBUF_FIELD_OFFSET(LodmcDebug, _impl_.torq_command_)>(
          reinterpret_cast<char*>(&_impl_.torq_command_),
          reinterpret_cast<char*>(&other->_impl_.torq_command_));
}

::google::protobuf::Metadata LodmcDebug::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace control
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_control_5fmsgs_2fcontrol_5fcmd_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
