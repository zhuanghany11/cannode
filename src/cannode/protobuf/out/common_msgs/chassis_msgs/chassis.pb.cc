// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common_msgs/chassis_msgs/chassis.proto
// Protobuf C++ Version: 5.28.0-dev

#include "common_msgs/chassis_msgs/chassis.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace control {
namespace canbus {

inline constexpr WheelSpeed::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        wheel_spd_rr_{0},
        wheel_spd_rl_{0},
        wheel_spd_fr_{0},
        wheel_spd_fl_{0},
        is_wheel_spd_rr_valid_{false},
        is_wheel_spd_rl_valid_{false},
        is_wheel_spd_fr_valid_{false},
        is_wheel_spd_fl_valid_{false},
        wheel_direction_rr_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)},
        wheel_direction_rl_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)},
        wheel_direction_fr_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)},
        wheel_direction_fl_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)} {}

template <typename>
PROTOBUF_CONSTEXPR WheelSpeed::WheelSpeed(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct WheelSpeedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WheelSpeedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WheelSpeedDefaultTypeInternal() {}
  union {
    WheelSpeed _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WheelSpeedDefaultTypeInternal _WheelSpeed_default_instance_;

inline constexpr License::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vin_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR License::License(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LicenseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicenseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicenseDefaultTypeInternal() {}
  union {
    License _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicenseDefaultTypeInternal _License_default_instance_;

inline constexpr CheckResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        is_eps_online_{false},
        is_epb_online_{false},
        is_esp_online_{false},
        is_vtog_online_{false},
        is_scu_online_{false},
        is_switch_online_{false},
        is_vcu_online_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CheckResponse::CheckResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CheckResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckResponseDefaultTypeInternal() {}
  union {
    CheckResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckResponseDefaultTypeInternal _CheckResponse_default_instance_;

inline constexpr ChassisGPS::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        latitude_{0},
        longitude_{0},
        year_{0},
        month_{0},
        day_{0},
        hours_{0},
        minutes_{0},
        seconds_{0},
        compass_direction_{0},
        pdop_{0},
        gps_valid_{false},
        is_gps_fault_{false},
        is_inferred_{false},
        quality_{static_cast< ::control::canbus::GpsQuality >(0)},
        altitude_{0},
        heading_{0},
        hdop_{0},
        vdop_{0},
        gps_speed_{0},
        num_satellites_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ChassisGPS::ChassisGPS(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChassisGPSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChassisGPSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChassisGPSDefaultTypeInternal() {}
  union {
    ChassisGPS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChassisGPSDefaultTypeInternal _ChassisGPS_default_instance_;

inline constexpr Sonar::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        translation_{nullptr},
        rotation_{nullptr},
        range_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Sonar::Sonar(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SonarDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SonarDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SonarDefaultTypeInternal() {}
  union {
    Sonar _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SonarDefaultTypeInternal _Sonar_default_instance_;

inline constexpr Surround::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        sonar_range_{},
        sonar_{},
        cross_traffic_alert_left_{false},
        cross_traffic_alert_left_enabled_{false},
        blind_spot_left_alert_{false},
        blind_spot_left_alert_enabled_{false},
        cross_traffic_alert_right_{false},
        cross_traffic_alert_right_enabled_{false},
        blind_spot_right_alert_{false},
        blind_spot_right_alert_enabled_{false},
        sonar00_{0},
        sonar01_{0},
        sonar02_{0},
        sonar03_{0},
        sonar04_{0},
        sonar05_{0},
        sonar06_{0},
        sonar07_{0},
        sonar08_{0},
        sonar09_{0},
        sonar10_{0},
        sonar11_{0},
        sonar_enabled_{false},
        sonar_fault_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Surround::Surround(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SurroundDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SurroundDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SurroundDefaultTypeInternal() {}
  union {
    Surround _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SurroundDefaultTypeInternal _Surround_default_instance_;

inline constexpr Chassis::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        header_{nullptr},
        signal_{nullptr},
        chassis_gps_{nullptr},
        engage_advice_{nullptr},
        wheel_speed_{nullptr},
        surround_{nullptr},
        license_{nullptr},
        vehicle_id_{nullptr},
        check_response_{nullptr},
        custom_status_{nullptr},
        fuel_range_m_{0},
        engine_started_{false},
        parking_brake_{false},
        high_beam_signal_{false},
        low_beam_signal_{false},
        left_turn_signal_{false},
        right_turn_signal_{false},
        horn_{false},
        wiper_{false},
        disengage_status_{false},
        driving_mode_{static_cast< ::control::canbus::Chassis_DrivingMode >(0)},
        error_code_{static_cast< ::control::canbus::Chassis_ErrorCode >(0)},
        steering_timestamp_{0},
        gear_location_{static_cast< ::control::canbus::Chassis_GearPosition >(0)},
        chassis_error_mask_{0},
        front_bumper_event_{static_cast< ::control::canbus::Chassis_BumperEvent >(0)},
        back_bumper_event_{static_cast< ::control::canbus::Chassis_BumperEvent >(0)},
        steer_mode_{static_cast< ::control::canbus::Chassis_SteerMode >(0)},
        door_fl_status_{0},
        switch_status_{0},
        epb_status_{0u},
        mtr_trq_{0},
        container_position_{0u},
        container_status_{0u},
        pto_status_{0u},
        arm_angle_{0},
        shovel_angle_{0},
        steering_percentage_cmd_{std::numeric_limits<float>::quiet_NaN()},
        engine_rpm_{std::numeric_limits<float>::quiet_NaN()},
        speed_mps_{std::numeric_limits<float>::quiet_NaN()},
        odometer_m_{std::numeric_limits<float>::quiet_NaN()},
        throttle_percentage_{std::numeric_limits<float>::quiet_NaN()},
        brake_percentage_{std::numeric_limits<float>::quiet_NaN()},
        steering_percentage_{std::numeric_limits<float>::quiet_NaN()},
        steering_torque_nm_{std::numeric_limits<float>::quiet_NaN()},
        battery_soc_percentage_{-1},
        throttle_percentage_cmd_{std::numeric_limits<float>::quiet_NaN()},
        brake_percentage_cmd_{std::numeric_limits<float>::quiet_NaN()} {}

template <typename>
PROTOBUF_CONSTEXPR Chassis::Chassis(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChassisDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChassisDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChassisDefaultTypeInternal() {}
  union {
    Chassis _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChassisDefaultTypeInternal _Chassis_default_instance_;
}  // namespace canbus
}  // namespace control
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[7];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto = nullptr;
const ::uint32_t
    TableStruct_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.engine_started_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.engine_rpm_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.speed_mps_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.odometer_m_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.fuel_range_m_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.throttle_percentage_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.brake_percentage_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.steering_percentage_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.steering_torque_nm_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.parking_brake_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.high_beam_signal_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.low_beam_signal_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.left_turn_signal_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.right_turn_signal_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.horn_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.wiper_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.disengage_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.driving_mode_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.error_code_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.gear_location_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.steering_timestamp_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.header_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.chassis_error_mask_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.signal_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.chassis_gps_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.engage_advice_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.wheel_speed_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.surround_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.license_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.vehicle_id_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.battery_soc_percentage_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.throttle_percentage_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.brake_percentage_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.steering_percentage_cmd_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.front_bumper_event_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.back_bumper_event_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.check_response_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.custom_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.steer_mode_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.door_fl_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.switch_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.epb_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.mtr_trq_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.container_position_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.container_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.pto_status_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.arm_angle_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Chassis, _impl_.shovel_angle_),
        11,
        38,
        39,
        40,
        10,
        41,
        42,
        43,
        44,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        23,
        22,
        0,
        24,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        45,
        46,
        47,
        37,
        25,
        26,
        8,
        9,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.latitude_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.longitude_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.gps_valid_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.year_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.month_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.day_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.hours_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.minutes_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.seconds_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.compass_direction_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.pdop_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.is_gps_fault_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.is_inferred_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.altitude_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.heading_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.hdop_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.vdop_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.quality_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.num_satellites_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::ChassisGPS, _impl_.gps_speed_),
        0,
        1,
        10,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        14,
        15,
        16,
        17,
        13,
        19,
        18,
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.is_wheel_spd_rr_valid_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_direction_rr_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_spd_rr_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.is_wheel_spd_rl_valid_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_direction_rl_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_spd_rl_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.is_wheel_spd_fr_valid_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_direction_fr_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_spd_fr_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.is_wheel_spd_fl_valid_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_direction_fl_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::WheelSpeed, _impl_.wheel_spd_fl_),
        4,
        8,
        0,
        5,
        9,
        1,
        6,
        10,
        2,
        7,
        11,
        3,
        PROTOBUF_FIELD_OFFSET(::control::canbus::Sonar, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Sonar, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::Sonar, _impl_.range_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Sonar, _impl_.translation_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Sonar, _impl_.rotation_),
        2,
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.cross_traffic_alert_left_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.cross_traffic_alert_left_enabled_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.blind_spot_left_alert_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.blind_spot_left_alert_enabled_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.cross_traffic_alert_right_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.cross_traffic_alert_right_enabled_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.blind_spot_right_alert_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.blind_spot_right_alert_enabled_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar00_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar01_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar02_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar03_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar04_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar05_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar06_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar07_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar08_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar09_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar10_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar11_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar_enabled_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar_fault_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar_range_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::Surround, _impl_.sonar_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::control::canbus::License, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::License, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::License, _impl_.vin_),
        0,
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_eps_online_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_epb_online_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_esp_online_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_vtog_online_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_scu_online_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_switch_online_),
        PROTOBUF_FIELD_OFFSET(::control::canbus::CheckResponse, _impl_.is_vcu_online_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 56, -1, sizeof(::control::canbus::Chassis)},
        {104, 132, -1, sizeof(::control::canbus::ChassisGPS)},
        {152, 172, -1, sizeof(::control::canbus::WheelSpeed)},
        {184, 195, -1, sizeof(::control::canbus::Sonar)},
        {198, 230, -1, sizeof(::control::canbus::Surround)},
        {254, 263, -1, sizeof(::control::canbus::License)},
        {264, 279, -1, sizeof(::control::canbus::CheckResponse)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::control::canbus::_Chassis_default_instance_._instance,
    &::control::canbus::_ChassisGPS_default_instance_._instance,
    &::control::canbus::_WheelSpeed_default_instance_._instance,
    &::control::canbus::_Sonar_default_instance_._instance,
    &::control::canbus::_Surround_default_instance_._instance,
    &::control::canbus::_License_default_instance_._instance,
    &::control::canbus::_CheckResponse_default_instance_._instance,
};
const char descriptor_table_protodef_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n&common_msgs/chassis_msgs/chassis.proto"
    "\022\016control.canbus\032\031google/protobuf/any.pr"
    "oto\032(common_msgs/basic_msgs/drive_state."
    "proto\032%common_msgs/basic_msgs/geometry.p"
    "roto\032#common_msgs/basic_msgs/header.prot"
    "o\032\'common_msgs/basic_msgs/vehicle_id.pro"
    "to\032+common_msgs/basic_msgs/vehicle_signa"
    "l.proto\"\343\022\n\007Chassis\022\026\n\016engine_started\030\003 "
    "\001(\010\022\027\n\nengine_rpm\030\004 \001(\002:\003nan\022\026\n\tspeed_mp"
    "s\030\005 \001(\002:\003nan\022\027\n\nodometer_m\030\006 \001(\002:\003nan\022\024\n"
    "\014fuel_range_m\030\007 \001(\005\022 \n\023throttle_percenta"
    "ge\030\010 \001(\002:\003nan\022\035\n\020brake_percentage\030\t \001(\002:"
    "\003nan\022 \n\023steering_percentage\030\013 \001(\002:\003nan\022\037"
    "\n\022steering_torque_nm\030\014 \001(\002:\003nan\022\025\n\rparki"
    "ng_brake\030\r \001(\010\022\034\n\020high_beam_signal\030\016 \001(\010"
    "B\002\030\001\022\033\n\017low_beam_signal\030\017 \001(\010B\002\030\001\022\034\n\020lef"
    "t_turn_signal\030\020 \001(\010B\002\030\001\022\035\n\021right_turn_si"
    "gnal\030\021 \001(\010B\002\030\001\022\020\n\004horn\030\022 \001(\010B\002\030\001\022\r\n\005wipe"
    "r\030\023 \001(\010\022\034\n\020disengage_status\030\024 \001(\010B\002\030\001\022J\n"
    "\014driving_mode\030\025 \001(\0162#.control.canbus.Cha"
    "ssis.DrivingMode:\017COMPLETE_MANUAL\022\?\n\nerr"
    "or_code\030\026 \001(\0162!.control.canbus.Chassis.E"
    "rrorCode:\010NO_ERROR\022;\n\rgear_location\030\027 \001("
    "\0162$.control.canbus.Chassis.GearPosition\022"
    "\032\n\022steering_timestamp\030\030 \001(\001\022&\n\006header\030\031 "
    "\001(\0132\026.control.common.Header\022\035\n\022chassis_e"
    "rror_mask\030\032 \001(\005:\0010\022-\n\006signal\030\033 \001(\0132\035.con"
    "trol.common.VehicleSignal\022/\n\013chassis_gps"
    "\030\034 \001(\0132\032.control.canbus.ChassisGPS\0223\n\ren"
    "gage_advice\030\035 \001(\0132\034.control.common.Engag"
    "eAdvice\022/\n\013wheel_speed\030\036 \001(\0132\032.control.c"
    "anbus.WheelSpeed\022*\n\010surround\030\037 \001(\0132\030.con"
    "trol.canbus.Surround\022,\n\007license\030  \001(\0132\027."
    "control.canbus.LicenseB\002\030\001\022-\n\nvehicle_id"
    "\030! \001(\0132\031.control.common.VehicleID\022\"\n\026bat"
    "tery_soc_percentage\030\" \001(\005:\002-1\022$\n\027throttl"
    "e_percentage_cmd\030# \001(\002:\003nan\022!\n\024brake_per"
    "centage_cmd\030$ \001(\002:\003nan\022$\n\027steering_perce"
    "ntage_cmd\030% \001(\002:\003nan\022\?\n\022front_bumper_eve"
    "nt\030& \001(\0162#.control.canbus.Chassis.Bumper"
    "Event\022>\n\021back_bumper_event\030\' \001(\0162#.contr"
    "ol.canbus.Chassis.BumperEvent\0225\n\016check_r"
    "esponse\030( \001(\0132\035.control.canbus.CheckResp"
    "onse\022+\n\rcustom_status\030) \001(\0132\024.google.pro"
    "tobuf.Any\0225\n\nsteer_mode\030* \001(\0162!.control."
    "canbus.Chassis.SteerMode\022\026\n\016door_fl_stat"
    "us\030+ \001(\005\022\025\n\rswitch_status\030, \001(\005\022\022\n\nepb_s"
    "tatus\030- \001(\r\022\017\n\007mtr_trq\030. \001(\005\022\032\n\022containe"
    "r_position\030/ \001(\r\022\030\n\020container_status\0300 \001"
    "(\r\022\022\n\npto_status\0301 \001(\r\022\024\n\tarm_angle\0302 \001("
    "\001:\0010\022\027\n\014shovel_angle\0303 \001(\001:\0010\"y\n\013Driving"
    "Mode\022\023\n\017COMPLETE_MANUAL\020\000\022\027\n\023COMPLETE_AU"
    "TO_DRIVE\020\001\022\023\n\017AUTO_STEER_ONLY\020\002\022\023\n\017AUTO_"
    "SPEED_ONLY\020\003\022\022\n\016EMERGENCY_MODE\020\004\"\200\002\n\tErr"
    "orCode\022\014\n\010NO_ERROR\020\000\022\025\n\021CMD_NOT_IN_PERIO"
    "D\020\001\022\021\n\rCHASSIS_ERROR\020\002\022\032\n\026CHASSIS_ERROR_"
    "ON_STEER\020\006\022\032\n\026CHASSIS_ERROR_ON_BRAKE\020\007\022\035"
    "\n\031CHASSIS_ERROR_ON_THROTTLE\020\010\022\031\n\025CHASSIS"
    "_ERROR_ON_GEAR\020\t\022\027\n\023MANUAL_INTERVENTION\020"
    "\003\022\035\n\031CHASSIS_CAN_NOT_IN_PERIOD\020\004\022\021\n\rUNKN"
    "OWN_ERROR\020\005\"\203\001\n\014GearPosition\022\020\n\014GEAR_INV"
    "ALID\020\000\022\016\n\nGEAR_DRIVE\020\001\022\020\n\014GEAR_NEUTRAL\020\002"
    "\022\020\n\014GEAR_REVERSE\020\003\022\020\n\014GEAR_PARKING\020\004\022\014\n\010"
    "GEAR_LOW\020\005\022\r\n\tGEAR_NONE\020\006\"H\n\013BumperEvent"
    "\022\022\n\016BUMPER_INVALID\020\000\022\021\n\rBUMPER_NORMAL\020\001\022"
    "\022\n\016BUMPER_PRESSED\020\002\"H\n\tSteerMode\022\014\n\010STRA"
    "IGHT\020\000\022\r\n\tFULLWHEEL\020\001\022\014\n\010DIAGONAL\020\002\022\020\n\014F"
    "ORWARDWHEEL\020\003\"\212\003\n\nChassisGPS\022\020\n\010latitude"
    "\030\001 \001(\001\022\021\n\tlongitude\030\002 \001(\001\022\021\n\tgps_valid\030\003"
    " \001(\010\022\014\n\004year\030\004 \001(\005\022\r\n\005month\030\005 \001(\005\022\013\n\003day"
    "\030\006 \001(\005\022\r\n\005hours\030\007 \001(\005\022\017\n\007minutes\030\010 \001(\005\022\017"
    "\n\007seconds\030\t \001(\005\022\031\n\021compass_direction\030\n \001"
    "(\001\022\014\n\004pdop\030\013 \001(\001\022\024\n\014is_gps_fault\030\014 \001(\010\022\023"
    "\n\013is_inferred\030\r \001(\010\022\020\n\010altitude\030\016 \001(\001\022\017\n"
    "\007heading\030\017 \001(\001\022\014\n\004hdop\030\020 \001(\001\022\014\n\004vdop\030\021 \001"
    "(\001\022+\n\007quality\030\022 \001(\0162\032.control.canbus.Gps"
    "Quality\022\026\n\016num_satellites\030\023 \001(\005\022\021\n\tgps_s"
    "peed\030\024 \001(\001\"\222\005\n\nWheelSpeed\022$\n\025is_wheel_sp"
    "d_rr_valid\030\001 \001(\010:\005false\022N\n\022wheel_directi"
    "on_rr\030\002 \001(\0162).control.canbus.WheelSpeed."
    "WheelSpeedType:\007INVALID\022\027\n\014wheel_spd_rr\030"
    "\003 \001(\001:\0010\022$\n\025is_wheel_spd_rl_valid\030\004 \001(\010:"
    "\005false\022N\n\022wheel_direction_rl\030\005 \001(\0162).con"
    "trol.canbus.WheelSpeed.WheelSpeedType:\007I"
    "NVALID\022\027\n\014wheel_spd_rl\030\006 \001(\001:\0010\022$\n\025is_wh"
    "eel_spd_fr_valid\030\007 \001(\010:\005false\022N\n\022wheel_d"
    "irection_fr\030\010 \001(\0162).control.canbus.Wheel"
    "Speed.WheelSpeedType:\007INVALID\022\027\n\014wheel_s"
    "pd_fr\030\t \001(\001:\0010\022$\n\025is_wheel_spd_fl_valid\030"
    "\n \001(\010:\005false\022N\n\022wheel_direction_fl\030\013 \001(\016"
    "2).control.canbus.WheelSpeed.WheelSpeedT"
    "ype:\007INVALID\022\027\n\014wheel_spd_fl\030\014 \001(\001:\0010\"H\n"
    "\016WheelSpeedType\022\013\n\007FORWARD\020\000\022\014\n\010BACKWARD"
    "\020\001\022\016\n\nSTANDSTILL\020\002\022\013\n\007INVALID\020\003\"r\n\005Sonar"
    "\022\r\n\005range\030\001 \001(\001\022,\n\013translation\030\002 \001(\0132\027.c"
    "ontrol.common.Point3D\022,\n\010rotation\030\003 \001(\0132"
    "\032.control.common.Quaternion\"\345\004\n\010Surround"
    "\022 \n\030cross_traffic_alert_left\030\001 \001(\010\022(\n cr"
    "oss_traffic_alert_left_enabled\030\002 \001(\010\022\035\n\025"
    "blind_spot_left_alert\030\003 \001(\010\022%\n\035blind_spo"
    "t_left_alert_enabled\030\004 \001(\010\022!\n\031cross_traf"
    "fic_alert_right\030\005 \001(\010\022)\n!cross_traffic_a"
    "lert_right_enabled\030\006 \001(\010\022\036\n\026blind_spot_r"
    "ight_alert\030\007 \001(\010\022&\n\036blind_spot_right_ale"
    "rt_enabled\030\010 \001(\010\022\017\n\007sonar00\030\t \001(\001\022\017\n\007son"
    "ar01\030\n \001(\001\022\017\n\007sonar02\030\013 \001(\001\022\017\n\007sonar03\030\014"
    " \001(\001\022\017\n\007sonar04\030\r \001(\001\022\017\n\007sonar05\030\016 \001(\001\022\017"
    "\n\007sonar06\030\017 \001(\001\022\017\n\007sonar07\030\020 \001(\001\022\017\n\007sona"
    "r08\030\021 \001(\001\022\017\n\007sonar09\030\022 \001(\001\022\017\n\007sonar10\030\023 "
    "\001(\001\022\017\n\007sonar11\030\024 \001(\001\022\025\n\rsonar_enabled\030\025 "
    "\001(\010\022\023\n\013sonar_fault\030\026 \001(\010\022\023\n\013sonar_range\030"
    "\027 \003(\001\022$\n\005sonar\030\030 \003(\0132\025.control.canbus.So"
    "nar\"\032\n\007License\022\017\n\003vin\030\001 \001(\tB\002\030\001\"\345\001\n\rChec"
    "kResponse\022\034\n\ris_eps_online\030\001 \001(\010:\005false\022"
    "\034\n\ris_epb_online\030\002 \001(\010:\005false\022\034\n\ris_esp_"
    "online\030\003 \001(\010:\005false\022\035\n\016is_vtog_online\030\004 "
    "\001(\010:\005false\022\034\n\ris_scu_online\030\005 \001(\010:\005false"
    "\022\037\n\020is_switch_online\030\006 \001(\010:\005false\022\034\n\ris_"
    "vcu_online\030\007 \001(\010:\005false*A\n\nGpsQuality\022\n\n"
    "\006FIX_NO\020\000\022\n\n\006FIX_2D\020\001\022\n\n\006FIX_3D\020\002\022\017\n\013FIX"
    "_INVALID\020\003"
};
static const ::_pbi::DescriptorTable* const descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto_deps[6] =
    {
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fdrive_5fstate_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fgeometry_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fheader_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fvehicle_5fid_2eproto,
        &::descriptor_table_common_5fmsgs_2fbasic_5fmsgs_2fvehicle_5fsignal_2eproto,
        &::descriptor_table_google_2fprotobuf_2fany_2eproto,
};
static ::absl::once_flag descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto = {
    false,
    false,
    4810,
    descriptor_table_protodef_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
    "common_msgs/chassis_msgs/chassis.proto",
    &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto_once,
    descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto_deps,
    6,
    7,
    schemas,
    file_default_instances,
    TableStruct_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto::offsets,
    file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
    file_level_service_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
};
namespace control {
namespace canbus {
const ::google::protobuf::EnumDescriptor* Chassis_DrivingMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Chassis_DrivingMode_internal_data_[] = {
    327680u, 0u, };
bool Chassis_DrivingMode_IsValid(int value) {
  return 0 <= value && value <= 4;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Chassis_DrivingMode Chassis::COMPLETE_MANUAL;
constexpr Chassis_DrivingMode Chassis::COMPLETE_AUTO_DRIVE;
constexpr Chassis_DrivingMode Chassis::AUTO_STEER_ONLY;
constexpr Chassis_DrivingMode Chassis::AUTO_SPEED_ONLY;
constexpr Chassis_DrivingMode Chassis::EMERGENCY_MODE;
constexpr Chassis_DrivingMode Chassis::DrivingMode_MIN;
constexpr Chassis_DrivingMode Chassis::DrivingMode_MAX;
constexpr int Chassis::DrivingMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Chassis_ErrorCode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t Chassis_ErrorCode_internal_data_[] = {
    655360u, 0u, };
bool Chassis_ErrorCode_IsValid(int value) {
  return 0 <= value && value <= 9;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Chassis_ErrorCode Chassis::NO_ERROR;
constexpr Chassis_ErrorCode Chassis::CMD_NOT_IN_PERIOD;
constexpr Chassis_ErrorCode Chassis::CHASSIS_ERROR;
constexpr Chassis_ErrorCode Chassis::CHASSIS_ERROR_ON_STEER;
constexpr Chassis_ErrorCode Chassis::CHASSIS_ERROR_ON_BRAKE;
constexpr Chassis_ErrorCode Chassis::CHASSIS_ERROR_ON_THROTTLE;
constexpr Chassis_ErrorCode Chassis::CHASSIS_ERROR_ON_GEAR;
constexpr Chassis_ErrorCode Chassis::MANUAL_INTERVENTION;
constexpr Chassis_ErrorCode Chassis::CHASSIS_CAN_NOT_IN_PERIOD;
constexpr Chassis_ErrorCode Chassis::UNKNOWN_ERROR;
constexpr Chassis_ErrorCode Chassis::ErrorCode_MIN;
constexpr Chassis_ErrorCode Chassis::ErrorCode_MAX;
constexpr int Chassis::ErrorCode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Chassis_GearPosition_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t Chassis_GearPosition_internal_data_[] = {
    458752u, 0u, };
bool Chassis_GearPosition_IsValid(int value) {
  return 0 <= value && value <= 6;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Chassis_GearPosition Chassis::GEAR_INVALID;
constexpr Chassis_GearPosition Chassis::GEAR_DRIVE;
constexpr Chassis_GearPosition Chassis::GEAR_NEUTRAL;
constexpr Chassis_GearPosition Chassis::GEAR_REVERSE;
constexpr Chassis_GearPosition Chassis::GEAR_PARKING;
constexpr Chassis_GearPosition Chassis::GEAR_LOW;
constexpr Chassis_GearPosition Chassis::GEAR_NONE;
constexpr Chassis_GearPosition Chassis::GearPosition_MIN;
constexpr Chassis_GearPosition Chassis::GearPosition_MAX;
constexpr int Chassis::GearPosition_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Chassis_BumperEvent_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t Chassis_BumperEvent_internal_data_[] = {
    196608u, 0u, };
bool Chassis_BumperEvent_IsValid(int value) {
  return 0 <= value && value <= 2;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Chassis_BumperEvent Chassis::BUMPER_INVALID;
constexpr Chassis_BumperEvent Chassis::BUMPER_NORMAL;
constexpr Chassis_BumperEvent Chassis::BUMPER_PRESSED;
constexpr Chassis_BumperEvent Chassis::BumperEvent_MIN;
constexpr Chassis_BumperEvent Chassis::BumperEvent_MAX;
constexpr int Chassis::BumperEvent_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Chassis_SteerMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t Chassis_SteerMode_internal_data_[] = {
    262144u, 0u, };
bool Chassis_SteerMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Chassis_SteerMode Chassis::STRAIGHT;
constexpr Chassis_SteerMode Chassis::FULLWHEEL;
constexpr Chassis_SteerMode Chassis::DIAGONAL;
constexpr Chassis_SteerMode Chassis::FORWARDWHEEL;
constexpr Chassis_SteerMode Chassis::SteerMode_MIN;
constexpr Chassis_SteerMode Chassis::SteerMode_MAX;
constexpr int Chassis::SteerMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* WheelSpeed_WheelSpeedType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[5];
}
PROTOBUF_CONSTINIT const uint32_t WheelSpeed_WheelSpeedType_internal_data_[] = {
    262144u, 0u, };
bool WheelSpeed_WheelSpeedType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr WheelSpeed_WheelSpeedType WheelSpeed::FORWARD;
constexpr WheelSpeed_WheelSpeedType WheelSpeed::BACKWARD;
constexpr WheelSpeed_WheelSpeedType WheelSpeed::STANDSTILL;
constexpr WheelSpeed_WheelSpeedType WheelSpeed::INVALID;
constexpr WheelSpeed_WheelSpeedType WheelSpeed::WheelSpeedType_MIN;
constexpr WheelSpeed_WheelSpeedType WheelSpeed::WheelSpeedType_MAX;
constexpr int WheelSpeed::WheelSpeedType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* GpsQuality_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto);
  return file_level_enum_descriptors_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto[6];
}
PROTOBUF_CONSTINIT const uint32_t GpsQuality_internal_data_[] = {
    262144u, 0u, };
bool GpsQuality_IsValid(int value) {
  return 0 <= value && value <= 3;
}
// ===================================================================

class Chassis::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Chassis>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Chassis, _impl_._has_bits_);
};

void Chassis::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Chassis::clear_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.signal_ != nullptr) _impl_.signal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void Chassis::clear_engage_advice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.engage_advice_ != nullptr) _impl_.engage_advice_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void Chassis::clear_vehicle_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_id_ != nullptr) _impl_.vehicle_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void Chassis::clear_custom_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.custom_status_ != nullptr) _impl_.custom_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
Chassis::Chassis(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.Chassis)
}
inline PROTOBUF_NDEBUG_INLINE Chassis::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::canbus::Chassis& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Chassis::Chassis(
    ::google::protobuf::Arena* arena,
    const Chassis& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Chassis* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::common::Header>(
                              arena, *from._impl_.header_)
                        : nullptr;
  _impl_.signal_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::common::VehicleSignal>(
                              arena, *from._impl_.signal_)
                        : nullptr;
  _impl_.chassis_gps_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::control::canbus::ChassisGPS>(
                              arena, *from._impl_.chassis_gps_)
                        : nullptr;
  _impl_.engage_advice_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::control::common::EngageAdvice>(
                              arena, *from._impl_.engage_advice_)
                        : nullptr;
  _impl_.wheel_speed_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::Message::CopyConstruct<::control::canbus::WheelSpeed>(
                              arena, *from._impl_.wheel_speed_)
                        : nullptr;
  _impl_.surround_ = (cached_has_bits & 0x00000020u) ? ::google::protobuf::Message::CopyConstruct<::control::canbus::Surround>(
                              arena, *from._impl_.surround_)
                        : nullptr;
  _impl_.license_ = (cached_has_bits & 0x00000040u) ? ::google::protobuf::Message::CopyConstruct<::control::canbus::License>(
                              arena, *from._impl_.license_)
                        : nullptr;
  _impl_.vehicle_id_ = (cached_has_bits & 0x00000080u) ? ::google::protobuf::Message::CopyConstruct<::control::common::VehicleID>(
                              arena, *from._impl_.vehicle_id_)
                        : nullptr;
  _impl_.check_response_ = (cached_has_bits & 0x00000100u) ? ::google::protobuf::Message::CopyConstruct<::control::canbus::CheckResponse>(
                              arena, *from._impl_.check_response_)
                        : nullptr;
  _impl_.custom_status_ = (cached_has_bits & 0x00000200u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Any>(
                              arena, *from._impl_.custom_status_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, fuel_range_m_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, fuel_range_m_),
           offsetof(Impl_, brake_percentage_cmd_) -
               offsetof(Impl_, fuel_range_m_) +
               sizeof(Impl_::brake_percentage_cmd_));

  // @@protoc_insertion_point(copy_constructor:control.canbus.Chassis)
}
inline PROTOBUF_NDEBUG_INLINE Chassis::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        steering_percentage_cmd_{std::numeric_limits<float>::quiet_NaN()},
        engine_rpm_{std::numeric_limits<float>::quiet_NaN()},
        speed_mps_{std::numeric_limits<float>::quiet_NaN()},
        odometer_m_{std::numeric_limits<float>::quiet_NaN()},
        throttle_percentage_{std::numeric_limits<float>::quiet_NaN()},
        brake_percentage_{std::numeric_limits<float>::quiet_NaN()},
        steering_percentage_{std::numeric_limits<float>::quiet_NaN()},
        steering_torque_nm_{std::numeric_limits<float>::quiet_NaN()},
        battery_soc_percentage_{-1},
        throttle_percentage_cmd_{std::numeric_limits<float>::quiet_NaN()},
        brake_percentage_cmd_{std::numeric_limits<float>::quiet_NaN()} {}

inline void Chassis::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_),
           0,
           offsetof(Impl_, shovel_angle_) -
               offsetof(Impl_, header_) +
               sizeof(Impl_::shovel_angle_));
}
Chassis::~Chassis() {
  // @@protoc_insertion_point(destructor:control.canbus.Chassis)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Chassis::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.header_;
  delete _impl_.signal_;
  delete _impl_.chassis_gps_;
  delete _impl_.engage_advice_;
  delete _impl_.wheel_speed_;
  delete _impl_.surround_;
  delete _impl_.license_;
  delete _impl_.vehicle_id_;
  delete _impl_.check_response_;
  delete _impl_.custom_status_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Chassis::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Chassis::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Chassis>(),
            ::google::protobuf::Message::GetNewImpl<Chassis>(),
            ::google::protobuf::Message::GetClearImpl<Chassis>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<Chassis>(),
                ::google::protobuf::Message::GetSerializeImpl<Chassis>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Chassis, _impl_._cached_size_),
            false,
        },
        &Chassis::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Chassis::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 48, 16, 0, 9> Chassis::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Chassis, _impl_._has_bits_),
    0, // no _extensions_
    51, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    515,  // skipmap
    offsetof(decltype(_table_), field_entries),
    48,  // num_field_entries
    16,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Chassis_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::Chassis>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool engine_started = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Chassis, _impl_.engine_started_), 11>(),
     {24, 11, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.engine_started_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 fuel_range_m = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Chassis, _impl_.fuel_range_m_), 10>(),
     {56, 10, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.fuel_range_m_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool parking_brake = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Chassis, _impl_.parking_brake_), 12>(),
     {104, 12, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.parking_brake_)}},
    // optional bool high_beam_signal = 14 [deprecated = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Chassis, _impl_.high_beam_signal_), 13>(),
     {112, 13, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.high_beam_signal_)}},
    // optional bool low_beam_signal = 15 [deprecated = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Chassis, _impl_.low_beam_signal_), 14>(),
     {120, 14, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.low_beam_signal_)}},
    // optional bool left_turn_signal = 16 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {384, 15, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.left_turn_signal_)}},
    // optional bool right_turn_signal = 17 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {392, 16, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.right_turn_signal_)}},
    // optional bool horn = 18 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {400, 17, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.horn_)}},
    // optional bool wiper = 19;
    {::_pbi::TcParser::FastV8S2,
     {408, 18, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.wiper_)}},
    // optional bool disengage_status = 20 [deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {416, 19, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.disengage_status_)}},
    // optional .control.canbus.Chassis.DrivingMode driving_mode = 21 [default = COMPLETE_MANUAL];
    {::_pbi::TcParser::FastEr0S2,
     {424, 20, 4, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.driving_mode_)}},
    // optional .control.canbus.Chassis.ErrorCode error_code = 22 [default = NO_ERROR];
    {::_pbi::TcParser::FastEr0S2,
     {432, 21, 9, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.error_code_)}},
    // optional .control.canbus.Chassis.GearPosition gear_location = 23;
    {::_pbi::TcParser::FastEr0S2,
     {440, 23, 6, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.gear_location_)}},
    // optional double steering_timestamp = 24;
    {::_pbi::TcParser::FastF64S2,
     {449, 22, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.steering_timestamp_)}},
    // optional .control.common.Header header = 25;
    {::_pbi::TcParser::FastMtS2,
     {458, 0, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.header_)}},
    // optional int32 chassis_error_mask = 26 [default = 0];
    {::_pbi::TcParser::FastV32S2,
     {464, 24, 0, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.chassis_error_mask_)}},
    // optional .control.common.VehicleSignal signal = 27;
    {::_pbi::TcParser::FastMtS2,
     {474, 1, 1, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.signal_)}},
    // optional .control.canbus.ChassisGPS chassis_gps = 28;
    {::_pbi::TcParser::FastMtS2,
     {482, 2, 2, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.chassis_gps_)}},
    // optional .control.common.EngageAdvice engage_advice = 29;
    {::_pbi::TcParser::FastMtS2,
     {490, 3, 3, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.engage_advice_)}},
    // optional .control.canbus.WheelSpeed wheel_speed = 30;
    {::_pbi::TcParser::FastMtS2,
     {498, 4, 4, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.wheel_speed_)}},
    // optional .control.canbus.Surround surround = 31;
    {::_pbi::TcParser::FastMtS2,
     {506, 5, 5, PROTOBUF_FIELD_OFFSET(Chassis, _impl_.surround_)}},
  }}, {{
    33, 0, 2,
    0, 29, 65528, 45,
    65535, 65535
  }}, {{
    // optional bool engine_started = 3;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.engine_started_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional float engine_rpm = 4 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.engine_rpm_), _Internal::kHasBitsOffset + 38, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float speed_mps = 5 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.speed_mps_), _Internal::kHasBitsOffset + 39, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float odometer_m = 6 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.odometer_m_), _Internal::kHasBitsOffset + 40, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional int32 fuel_range_m = 7;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.fuel_range_m_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional float throttle_percentage = 8 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.throttle_percentage_), _Internal::kHasBitsOffset + 41, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float brake_percentage = 9 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.brake_percentage_), _Internal::kHasBitsOffset + 42, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float steering_percentage = 11 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.steering_percentage_), _Internal::kHasBitsOffset + 43, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float steering_torque_nm = 12 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.steering_torque_nm_), _Internal::kHasBitsOffset + 44, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional bool parking_brake = 13;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.parking_brake_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool high_beam_signal = 14 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.high_beam_signal_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool low_beam_signal = 15 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.low_beam_signal_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool left_turn_signal = 16 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.left_turn_signal_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool right_turn_signal = 17 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.right_turn_signal_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool horn = 18 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.horn_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool wiper = 19;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.wiper_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool disengage_status = 20 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.disengage_status_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .control.canbus.Chassis.DrivingMode driving_mode = 21 [default = COMPLETE_MANUAL];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.driving_mode_), _Internal::kHasBitsOffset + 20, 10,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .control.canbus.Chassis.ErrorCode error_code = 22 [default = NO_ERROR];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.error_code_), _Internal::kHasBitsOffset + 21, 11,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .control.canbus.Chassis.GearPosition gear_location = 23;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.gear_location_), _Internal::kHasBitsOffset + 23, 12,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double steering_timestamp = 24;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.steering_timestamp_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.common.Header header = 25;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 chassis_error_mask = 26 [default = 0];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.chassis_error_mask_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .control.common.VehicleSignal signal = 27;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.signal_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.canbus.ChassisGPS chassis_gps = 28;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.chassis_gps_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.EngageAdvice engage_advice = 29;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.engage_advice_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.canbus.WheelSpeed wheel_speed = 30;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.wheel_speed_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.canbus.Surround surround = 31;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.surround_), _Internal::kHasBitsOffset + 5, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.canbus.License license = 32 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.license_), _Internal::kHasBitsOffset + 6, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.VehicleID vehicle_id = 33;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.vehicle_id_), _Internal::kHasBitsOffset + 7, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 battery_soc_percentage = 34 [default = -1];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.battery_soc_percentage_), _Internal::kHasBitsOffset + 45, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional float throttle_percentage_cmd = 35 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.throttle_percentage_cmd_), _Internal::kHasBitsOffset + 46, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float brake_percentage_cmd = 36 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.brake_percentage_cmd_), _Internal::kHasBitsOffset + 47, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float steering_percentage_cmd = 37 [default = nan];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.steering_percentage_cmd_), _Internal::kHasBitsOffset + 37, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional .control.canbus.Chassis.BumperEvent front_bumper_event = 38;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.front_bumper_event_), _Internal::kHasBitsOffset + 25, 13,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .control.canbus.Chassis.BumperEvent back_bumper_event = 39;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.back_bumper_event_), _Internal::kHasBitsOffset + 26, 14,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .control.canbus.CheckResponse check_response = 40;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.check_response_), _Internal::kHasBitsOffset + 8, 8,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Any custom_status = 41;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.custom_status_), _Internal::kHasBitsOffset + 9, 9,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.canbus.Chassis.SteerMode steer_mode = 42;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.steer_mode_), _Internal::kHasBitsOffset + 27, 15,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional int32 door_fl_status = 43;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.door_fl_status_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 switch_status = 44;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.switch_status_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 epb_status = 45;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.epb_status_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int32 mtr_trq = 46;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.mtr_trq_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 container_position = 47;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.container_position_), _Internal::kHasBitsOffset + 32, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 container_status = 48;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.container_status_), _Internal::kHasBitsOffset + 33, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 pto_status = 49;
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.pto_status_), _Internal::kHasBitsOffset + 34, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional double arm_angle = 50 [default = 0];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.arm_angle_), _Internal::kHasBitsOffset + 35, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double shovel_angle = 51 [default = 0];
    {PROTOBUF_FIELD_OFFSET(Chassis, _impl_.shovel_angle_), _Internal::kHasBitsOffset + 36, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::common::Header>()},
    {::_pbi::TcParser::GetTable<::control::common::VehicleSignal>()},
    {::_pbi::TcParser::GetTable<::control::canbus::ChassisGPS>()},
    {::_pbi::TcParser::GetTable<::control::common::EngageAdvice>()},
    {::_pbi::TcParser::GetTable<::control::canbus::WheelSpeed>()},
    {::_pbi::TcParser::GetTable<::control::canbus::Surround>()},
    {::_pbi::TcParser::GetTable<::control::canbus::License>()},
    {::_pbi::TcParser::GetTable<::control::common::VehicleID>()},
    {::_pbi::TcParser::GetTable<::control::canbus::CheckResponse>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
    {0, 5},
    {0, 10},
    {0, 7},
    {0, 3},
    {0, 3},
    {0, 4},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Chassis::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.Chassis)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.signal_ != nullptr);
      _impl_.signal_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.chassis_gps_ != nullptr);
      _impl_.chassis_gps_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.engage_advice_ != nullptr);
      _impl_.engage_advice_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.wheel_speed_ != nullptr);
      _impl_.wheel_speed_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.surround_ != nullptr);
      _impl_.surround_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.license_ != nullptr);
      _impl_.license_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.vehicle_id_ != nullptr);
      _impl_.vehicle_id_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(_impl_.check_response_ != nullptr);
      _impl_.check_response_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      ABSL_DCHECK(_impl_.custom_status_ != nullptr);
      _impl_.custom_status_->Clear();
    }
  }
  if (cached_has_bits & 0x0000fc00u) {
    ::memset(&_impl_.fuel_range_m_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.left_turn_signal_) -
        reinterpret_cast<char*>(&_impl_.fuel_range_m_)) + sizeof(_impl_.left_turn_signal_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.right_turn_signal_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.gear_location_) -
        reinterpret_cast<char*>(&_impl_.right_turn_signal_)) + sizeof(_impl_.gear_location_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.chassis_error_mask_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mtr_trq_) -
        reinterpret_cast<char*>(&_impl_.chassis_error_mask_)) + sizeof(_impl_.mtr_trq_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.container_position_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.shovel_angle_) -
        reinterpret_cast<char*>(&_impl_.container_position_)) + sizeof(_impl_.shovel_angle_));
    _impl_.steering_percentage_cmd_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.engine_rpm_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.speed_mps_ = std::numeric_limits<float>::quiet_NaN();
  }
  if (cached_has_bits & 0x0000ff00u) {
    _impl_.odometer_m_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.throttle_percentage_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.brake_percentage_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.steering_percentage_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.steering_torque_nm_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.battery_soc_percentage_ = -1;
    _impl_.throttle_percentage_cmd_ = std::numeric_limits<float>::quiet_NaN();
    _impl_.brake_percentage_cmd_ = std::numeric_limits<float>::quiet_NaN();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Chassis::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.Chassis)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool engine_started = 3;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_engine_started(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional float engine_rpm = 4 [default = nan];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_engine_rpm(), target);
  }

  // optional float speed_mps = 5 [default = nan];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_speed_mps(), target);
  }

  // optional float odometer_m = 6 [default = nan];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_odometer_m(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 fuel_range_m = 7;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_fuel_range_m(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional float throttle_percentage = 8 [default = nan];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_throttle_percentage(), target);
  }

  // optional float brake_percentage = 9 [default = nan];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_brake_percentage(), target);
  }

  // optional float steering_percentage = 11 [default = nan];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_steering_percentage(), target);
  }

  // optional float steering_torque_nm = 12 [default = nan];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_steering_torque_nm(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool parking_brake = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this->_internal_parking_brake(), target);
  }

  // optional bool high_beam_signal = 14 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        14, this->_internal_high_beam_signal(), target);
  }

  // optional bool low_beam_signal = 15 [deprecated = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        15, this->_internal_low_beam_signal(), target);
  }

  // optional bool left_turn_signal = 16 [deprecated = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_left_turn_signal(), target);
  }

  // optional bool right_turn_signal = 17 [deprecated = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        17, this->_internal_right_turn_signal(), target);
  }

  // optional bool horn = 18 [deprecated = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this->_internal_horn(), target);
  }

  // optional bool wiper = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this->_internal_wiper(), target);
  }

  // optional bool disengage_status = 20 [deprecated = true];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        20, this->_internal_disengage_status(), target);
  }

  // optional .control.canbus.Chassis.DrivingMode driving_mode = 21 [default = COMPLETE_MANUAL];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        21, this->_internal_driving_mode(), target);
  }

  // optional .control.canbus.Chassis.ErrorCode error_code = 22 [default = NO_ERROR];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        22, this->_internal_error_code(), target);
  }

  // optional .control.canbus.Chassis.GearPosition gear_location = 23;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        23, this->_internal_gear_location(), target);
  }

  // optional double steering_timestamp = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        24, this->_internal_steering_timestamp(), target);
  }

  // optional .control.common.Header header = 25;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        25, *_impl_.header_, _impl_.header_->GetCachedSize(), target, stream);
  }

  // optional int32 chassis_error_mask = 26 [default = 0];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        26, this->_internal_chassis_error_mask(), target);
  }

  // optional .control.common.VehicleSignal signal = 27;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        27, *_impl_.signal_, _impl_.signal_->GetCachedSize(), target, stream);
  }

  // optional .control.canbus.ChassisGPS chassis_gps = 28;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        28, *_impl_.chassis_gps_, _impl_.chassis_gps_->GetCachedSize(), target, stream);
  }

  // optional .control.common.EngageAdvice engage_advice = 29;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        29, *_impl_.engage_advice_, _impl_.engage_advice_->GetCachedSize(), target, stream);
  }

  // optional .control.canbus.WheelSpeed wheel_speed = 30;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        30, *_impl_.wheel_speed_, _impl_.wheel_speed_->GetCachedSize(), target, stream);
  }

  // optional .control.canbus.Surround surround = 31;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        31, *_impl_.surround_, _impl_.surround_->GetCachedSize(), target, stream);
  }

  // optional .control.canbus.License license = 32 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        32, *_impl_.license_, _impl_.license_->GetCachedSize(), target, stream);
  }

  // optional .control.common.VehicleID vehicle_id = 33;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        33, *_impl_.vehicle_id_, _impl_.vehicle_id_->GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 battery_soc_percentage = 34 [default = -1];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        34, this->_internal_battery_soc_percentage(), target);
  }

  // optional float throttle_percentage_cmd = 35 [default = nan];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        35, this->_internal_throttle_percentage_cmd(), target);
  }

  // optional float brake_percentage_cmd = 36 [default = nan];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        36, this->_internal_brake_percentage_cmd(), target);
  }

  // optional float steering_percentage_cmd = 37 [default = nan];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        37, this->_internal_steering_percentage_cmd(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .control.canbus.Chassis.BumperEvent front_bumper_event = 38;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        38, this->_internal_front_bumper_event(), target);
  }

  // optional .control.canbus.Chassis.BumperEvent back_bumper_event = 39;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        39, this->_internal_back_bumper_event(), target);
  }

  // optional .control.canbus.CheckResponse check_response = 40;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        40, *_impl_.check_response_, _impl_.check_response_->GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Any custom_status = 41;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        41, *_impl_.custom_status_, _impl_.custom_status_->GetCachedSize(), target, stream);
  }

  // optional .control.canbus.Chassis.SteerMode steer_mode = 42;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        42, this->_internal_steer_mode(), target);
  }

  // optional int32 door_fl_status = 43;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        43, this->_internal_door_fl_status(), target);
  }

  // optional int32 switch_status = 44;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        44, this->_internal_switch_status(), target);
  }

  // optional uint32 epb_status = 45;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        45, this->_internal_epb_status(), target);
  }

  // optional int32 mtr_trq = 46;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        46, this->_internal_mtr_trq(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 container_position = 47;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        47, this->_internal_container_position(), target);
  }

  // optional uint32 container_status = 48;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        48, this->_internal_container_status(), target);
  }

  // optional uint32 pto_status = 49;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        49, this->_internal_pto_status(), target);
  }

  // optional double arm_angle = 50 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        50, this->_internal_arm_angle(), target);
  }

  // optional double shovel_angle = 51 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        51, this->_internal_shovel_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.Chassis)
  return target;
}

::size_t Chassis::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.Chassis)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .control.common.Header header = 25;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_);
    }
    // optional .control.common.VehicleSignal signal = 27;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.signal_);
    }
    // optional .control.canbus.ChassisGPS chassis_gps = 28;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.chassis_gps_);
    }
    // optional .control.common.EngageAdvice engage_advice = 29;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.engage_advice_);
    }
    // optional .control.canbus.WheelSpeed wheel_speed = 30;
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.wheel_speed_);
    }
    // optional .control.canbus.Surround surround = 31;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.surround_);
    }
    // optional .control.canbus.License license = 32 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.license_);
    }
    // optional .control.common.VehicleID vehicle_id = 33;
    if (cached_has_bits & 0x00000080u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.vehicle_id_);
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .control.canbus.CheckResponse check_response = 40;
    if (cached_has_bits & 0x00000100u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.check_response_);
    }
    // optional .google.protobuf.Any custom_status = 41;
    if (cached_has_bits & 0x00000200u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.custom_status_);
    }
    // optional int32 fuel_range_m = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_fuel_range_m());
    }
    // optional bool engine_started = 3;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2;
    }
    // optional bool parking_brake = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2;
    }
    // optional bool high_beam_signal = 14 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2;
    }
    // optional bool low_beam_signal = 15 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2;
    }
    // optional bool left_turn_signal = 16 [deprecated = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 3;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool right_turn_signal = 17 [deprecated = true];
    if (cached_has_bits & 0x00010000u) {
      total_size += 3;
    }
    // optional bool horn = 18 [deprecated = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 3;
    }
    // optional bool wiper = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 3;
    }
    // optional bool disengage_status = 20 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 3;
    }
    // optional .control.canbus.Chassis.DrivingMode driving_mode = 21 [default = COMPLETE_MANUAL];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_driving_mode());
    }
    // optional .control.canbus.Chassis.ErrorCode error_code = 22 [default = NO_ERROR];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
    }
    // optional double steering_timestamp = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 10;
    }
    // optional .control.canbus.Chassis.GearPosition gear_location = 23;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_gear_location());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 chassis_error_mask = 26 [default = 0];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_chassis_error_mask());
    }
    // optional .control.canbus.Chassis.BumperEvent front_bumper_event = 38;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_front_bumper_event());
    }
    // optional .control.canbus.Chassis.BumperEvent back_bumper_event = 39;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_back_bumper_event());
    }
    // optional .control.canbus.Chassis.SteerMode steer_mode = 42;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_steer_mode());
    }
    // optional int32 door_fl_status = 43;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_door_fl_status());
    }
    // optional int32 switch_status = 44;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_switch_status());
    }
    // optional uint32 epb_status = 45;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_epb_status());
    }
    // optional int32 mtr_trq = 46;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_mtr_trq());
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 container_position = 47;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_container_position());
    }
    // optional uint32 container_status = 48;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_container_status());
    }
    // optional uint32 pto_status = 49;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_pto_status());
    }
    // optional double arm_angle = 50 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 10;
    }
    // optional double shovel_angle = 51 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += 10;
    }
    // optional float steering_percentage_cmd = 37 [default = nan];
    if (cached_has_bits & 0x00000020u) {
      total_size += 6;
    }
    // optional float engine_rpm = 4 [default = nan];
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }
    // optional float speed_mps = 5 [default = nan];
    if (cached_has_bits & 0x00000080u) {
      total_size += 5;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float odometer_m = 6 [default = nan];
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }
    // optional float throttle_percentage = 8 [default = nan];
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }
    // optional float brake_percentage = 9 [default = nan];
    if (cached_has_bits & 0x00000400u) {
      total_size += 5;
    }
    // optional float steering_percentage = 11 [default = nan];
    if (cached_has_bits & 0x00000800u) {
      total_size += 5;
    }
    // optional float steering_torque_nm = 12 [default = nan];
    if (cached_has_bits & 0x00001000u) {
      total_size += 5;
    }
    // optional int32 battery_soc_percentage = 34 [default = -1];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_battery_soc_percentage());
    }
    // optional float throttle_percentage_cmd = 35 [default = nan];
    if (cached_has_bits & 0x00004000u) {
      total_size += 6;
    }
    // optional float brake_percentage_cmd = 36 [default = nan];
    if (cached_has_bits & 0x00008000u) {
      total_size += 6;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void Chassis::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Chassis*>(&to_msg);
  auto& from = static_cast<const Chassis&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.Chassis)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.header_ != nullptr);
      if (_this->_impl_.header_ == nullptr) {
        _this->_impl_.header_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::Header>(arena, *from._impl_.header_);
      } else {
        _this->_impl_.header_->MergeFrom(*from._impl_.header_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.signal_ != nullptr);
      if (_this->_impl_.signal_ == nullptr) {
        _this->_impl_.signal_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::VehicleSignal>(arena, *from._impl_.signal_);
      } else {
        _this->_impl_.signal_->MergeFrom(*from._impl_.signal_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.chassis_gps_ != nullptr);
      if (_this->_impl_.chassis_gps_ == nullptr) {
        _this->_impl_.chassis_gps_ =
            ::google::protobuf::Message::CopyConstruct<::control::canbus::ChassisGPS>(arena, *from._impl_.chassis_gps_);
      } else {
        _this->_impl_.chassis_gps_->MergeFrom(*from._impl_.chassis_gps_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.engage_advice_ != nullptr);
      if (_this->_impl_.engage_advice_ == nullptr) {
        _this->_impl_.engage_advice_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::EngageAdvice>(arena, *from._impl_.engage_advice_);
      } else {
        _this->_impl_.engage_advice_->MergeFrom(*from._impl_.engage_advice_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.wheel_speed_ != nullptr);
      if (_this->_impl_.wheel_speed_ == nullptr) {
        _this->_impl_.wheel_speed_ =
            ::google::protobuf::Message::CopyConstruct<::control::canbus::WheelSpeed>(arena, *from._impl_.wheel_speed_);
      } else {
        _this->_impl_.wheel_speed_->MergeFrom(*from._impl_.wheel_speed_);
      }
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(from._impl_.surround_ != nullptr);
      if (_this->_impl_.surround_ == nullptr) {
        _this->_impl_.surround_ =
            ::google::protobuf::Message::CopyConstruct<::control::canbus::Surround>(arena, *from._impl_.surround_);
      } else {
        _this->_impl_.surround_->MergeFrom(*from._impl_.surround_);
      }
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(from._impl_.license_ != nullptr);
      if (_this->_impl_.license_ == nullptr) {
        _this->_impl_.license_ =
            ::google::protobuf::Message::CopyConstruct<::control::canbus::License>(arena, *from._impl_.license_);
      } else {
        _this->_impl_.license_->MergeFrom(*from._impl_.license_);
      }
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(from._impl_.vehicle_id_ != nullptr);
      if (_this->_impl_.vehicle_id_ == nullptr) {
        _this->_impl_.vehicle_id_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::VehicleID>(arena, *from._impl_.vehicle_id_);
      } else {
        _this->_impl_.vehicle_id_->MergeFrom(*from._impl_.vehicle_id_);
      }
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(from._impl_.check_response_ != nullptr);
      if (_this->_impl_.check_response_ == nullptr) {
        _this->_impl_.check_response_ =
            ::google::protobuf::Message::CopyConstruct<::control::canbus::CheckResponse>(arena, *from._impl_.check_response_);
      } else {
        _this->_impl_.check_response_->MergeFrom(*from._impl_.check_response_);
      }
    }
    if (cached_has_bits & 0x00000200u) {
      ABSL_DCHECK(from._impl_.custom_status_ != nullptr);
      if (_this->_impl_.custom_status_ == nullptr) {
        _this->_impl_.custom_status_ =
            ::google::protobuf::Message::CopyConstruct<::google::protobuf::Any>(arena, *from._impl_.custom_status_);
      } else {
        _this->_impl_.custom_status_->MergeFrom(*from._impl_.custom_status_);
      }
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.fuel_range_m_ = from._impl_.fuel_range_m_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.engine_started_ = from._impl_.engine_started_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.parking_brake_ = from._impl_.parking_brake_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.high_beam_signal_ = from._impl_.high_beam_signal_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.low_beam_signal_ = from._impl_.low_beam_signal_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.left_turn_signal_ = from._impl_.left_turn_signal_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.right_turn_signal_ = from._impl_.right_turn_signal_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.horn_ = from._impl_.horn_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.wiper_ = from._impl_.wiper_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.disengage_status_ = from._impl_.disengage_status_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.driving_mode_ = from._impl_.driving_mode_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.steering_timestamp_ = from._impl_.steering_timestamp_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.gear_location_ = from._impl_.gear_location_;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.chassis_error_mask_ = from._impl_.chassis_error_mask_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.front_bumper_event_ = from._impl_.front_bumper_event_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.back_bumper_event_ = from._impl_.back_bumper_event_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.steer_mode_ = from._impl_.steer_mode_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.door_fl_status_ = from._impl_.door_fl_status_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.switch_status_ = from._impl_.switch_status_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.epb_status_ = from._impl_.epb_status_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.mtr_trq_ = from._impl_.mtr_trq_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.container_position_ = from._impl_.container_position_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.container_status_ = from._impl_.container_status_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pto_status_ = from._impl_.pto_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.arm_angle_ = from._impl_.arm_angle_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.shovel_angle_ = from._impl_.shovel_angle_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.steering_percentage_cmd_ = from._impl_.steering_percentage_cmd_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.engine_rpm_ = from._impl_.engine_rpm_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.speed_mps_ = from._impl_.speed_mps_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.odometer_m_ = from._impl_.odometer_m_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.throttle_percentage_ = from._impl_.throttle_percentage_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.brake_percentage_ = from._impl_.brake_percentage_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.steering_percentage_ = from._impl_.steering_percentage_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.steering_torque_nm_ = from._impl_.steering_torque_nm_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.battery_soc_percentage_ = from._impl_.battery_soc_percentage_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.throttle_percentage_cmd_ = from._impl_.throttle_percentage_cmd_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.brake_percentage_cmd_ = from._impl_.brake_percentage_cmd_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Chassis::CopyFrom(const Chassis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.Chassis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Chassis::InternalSwap(Chassis* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Chassis, _impl_.brake_percentage_cmd_)
      + sizeof(Chassis::_impl_.brake_percentage_cmd_)
      - PROTOBUF_FIELD_OFFSET(Chassis, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::google::protobuf::Metadata Chassis::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChassisGPS::_Internal {
 public:
  using HasBits =
      decltype(std::declval<ChassisGPS>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_._has_bits_);
};

ChassisGPS::ChassisGPS(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.ChassisGPS)
}
ChassisGPS::ChassisGPS(
    ::google::protobuf::Arena* arena, const ChassisGPS& from)
    : ChassisGPS(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE ChassisGPS::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ChassisGPS::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, latitude_),
           0,
           offsetof(Impl_, num_satellites_) -
               offsetof(Impl_, latitude_) +
               sizeof(Impl_::num_satellites_));
}
ChassisGPS::~ChassisGPS() {
  // @@protoc_insertion_point(destructor:control.canbus.ChassisGPS)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ChassisGPS::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    ChassisGPS::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &ChassisGPS::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<ChassisGPS>(),
            ::google::protobuf::Message::GetNewImpl<ChassisGPS>(),
            ::google::protobuf::Message::GetClearImpl<ChassisGPS>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<ChassisGPS>(),
                ::google::protobuf::Message::GetSerializeImpl<ChassisGPS>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_._cached_size_),
            false,
        },
        &ChassisGPS::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* ChassisGPS::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 20, 1, 0, 2> ChassisGPS::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_._has_bits_),
    0, // no _extensions_
    20, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4293918720,  // skipmap
    offsetof(decltype(_table_), field_entries),
    20,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_ChassisGPS_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::ChassisGPS>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double latitude = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.latitude_)}},
    // optional double longitude = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.longitude_)}},
    // optional bool gps_valid = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChassisGPS, _impl_.gps_valid_), 10>(),
     {24, 10, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.gps_valid_)}},
    // optional int32 year = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChassisGPS, _impl_.year_), 2>(),
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.year_)}},
    // optional int32 month = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChassisGPS, _impl_.month_), 3>(),
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.month_)}},
    // optional int32 day = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChassisGPS, _impl_.day_), 4>(),
     {48, 4, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.day_)}},
    // optional int32 hours = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChassisGPS, _impl_.hours_), 5>(),
     {56, 5, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.hours_)}},
    // optional int32 minutes = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChassisGPS, _impl_.minutes_), 6>(),
     {64, 6, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.minutes_)}},
    // optional int32 seconds = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChassisGPS, _impl_.seconds_), 7>(),
     {72, 7, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.seconds_)}},
    // optional double compass_direction = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 8, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.compass_direction_)}},
    // optional double pdop = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 9, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.pdop_)}},
    // optional bool is_gps_fault = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChassisGPS, _impl_.is_gps_fault_), 11>(),
     {96, 11, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.is_gps_fault_)}},
    // optional bool is_inferred = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChassisGPS, _impl_.is_inferred_), 12>(),
     {104, 12, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.is_inferred_)}},
    // optional double altitude = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 14, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.altitude_)}},
    // optional double heading = 15;
    {::_pbi::TcParser::FastF64S1,
     {121, 15, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.heading_)}},
    // optional double hdop = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 16, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.hdop_)}},
    // optional double vdop = 17;
    {::_pbi::TcParser::FastF64S2,
     {393, 17, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.vdop_)}},
    // optional .control.canbus.GpsQuality quality = 18;
    {::_pbi::TcParser::FastEr0S2,
     {400, 13, 3, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.quality_)}},
    // optional int32 num_satellites = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 19, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.num_satellites_)}},
    // optional double gps_speed = 20;
    {::_pbi::TcParser::FastF64S2,
     {417, 18, 0, PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.gps_speed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double latitude = 1;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.latitude_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double longitude = 2;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.longitude_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool gps_valid = 3;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.gps_valid_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 year = 4;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.year_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 month = 5;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.month_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 day = 6;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.day_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 hours = 7;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.hours_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 minutes = 8;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.minutes_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 seconds = 9;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.seconds_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional double compass_direction = 10;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.compass_direction_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double pdop = 11;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.pdop_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_gps_fault = 12;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.is_gps_fault_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_inferred = 13;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.is_inferred_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double altitude = 14;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.altitude_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double heading = 15;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.heading_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double hdop = 16;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.hdop_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double vdop = 17;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.vdop_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.canbus.GpsQuality quality = 18;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.quality_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional int32 num_satellites = 19;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.num_satellites_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional double gps_speed = 20;
    {PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.gps_speed_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {0, 4},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void ChassisGPS::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.ChassisGPS)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.latitude_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.seconds_) -
        reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.seconds_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.compass_direction_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.heading_) -
        reinterpret_cast<char*>(&_impl_.compass_direction_)) + sizeof(_impl_.heading_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.hdop_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.num_satellites_) -
        reinterpret_cast<char*>(&_impl_.hdop_)) + sizeof(_impl_.num_satellites_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* ChassisGPS::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.ChassisGPS)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double latitude = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_latitude(), target);
  }

  // optional double longitude = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_longitude(), target);
  }

  // optional bool gps_valid = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_gps_valid(), target);
  }

  // optional int32 year = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_year(), target);
  }

  // optional int32 month = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_month(), target);
  }

  // optional int32 day = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_day(), target);
  }

  // optional int32 hours = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_hours(), target);
  }

  // optional int32 minutes = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<8>(
            stream, this->_internal_minutes(), target);
  }

  // optional int32 seconds = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<9>(
            stream, this->_internal_seconds(), target);
  }

  // optional double compass_direction = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_compass_direction(), target);
  }

  // optional double pdop = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_pdop(), target);
  }

  // optional bool is_gps_fault = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        12, this->_internal_is_gps_fault(), target);
  }

  // optional bool is_inferred = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this->_internal_is_inferred(), target);
  }

  // optional double altitude = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_altitude(), target);
  }

  // optional double heading = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_heading(), target);
  }

  // optional double hdop = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_hdop(), target);
  }

  // optional double vdop = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_vdop(), target);
  }

  // optional .control.canbus.GpsQuality quality = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        18, this->_internal_quality(), target);
  }

  // optional int32 num_satellites = 19;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        19, this->_internal_num_satellites(), target);
  }

  // optional double gps_speed = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_gps_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.ChassisGPS)
  return target;
}

::size_t ChassisGPS::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.ChassisGPS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double latitude = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }
    // optional double longitude = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }
    // optional int32 year = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_year());
    }
    // optional int32 month = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_month());
    }
    // optional int32 day = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_day());
    }
    // optional int32 hours = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_hours());
    }
    // optional int32 minutes = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_minutes());
    }
    // optional int32 seconds = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_seconds());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double compass_direction = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double pdop = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional bool gps_valid = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2;
    }
    // optional bool is_gps_fault = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2;
    }
    // optional bool is_inferred = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2;
    }
    // optional .control.canbus.GpsQuality quality = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_quality());
    }
    // optional double altitude = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 9;
    }
    // optional double heading = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += 9;
    }
  }
  if (cached_has_bits & 0x000f0000u) {
    // optional double hdop = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 10;
    }
    // optional double vdop = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 10;
    }
    // optional double gps_speed = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 10;
    }
    // optional int32 num_satellites = 19;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_num_satellites());
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void ChassisGPS::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChassisGPS*>(&to_msg);
  auto& from = static_cast<const ChassisGPS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.ChassisGPS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.year_ = from._impl_.year_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.month_ = from._impl_.month_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.day_ = from._impl_.day_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.hours_ = from._impl_.hours_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.minutes_ = from._impl_.minutes_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.seconds_ = from._impl_.seconds_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.compass_direction_ = from._impl_.compass_direction_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pdop_ = from._impl_.pdop_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.gps_valid_ = from._impl_.gps_valid_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_gps_fault_ = from._impl_.is_gps_fault_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_inferred_ = from._impl_.is_inferred_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.altitude_ = from._impl_.altitude_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.heading_ = from._impl_.heading_;
    }
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.hdop_ = from._impl_.hdop_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.vdop_ = from._impl_.vdop_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.gps_speed_ = from._impl_.gps_speed_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.num_satellites_ = from._impl_.num_satellites_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChassisGPS::CopyFrom(const ChassisGPS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.ChassisGPS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChassisGPS::InternalSwap(ChassisGPS* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.num_satellites_)
      + sizeof(ChassisGPS::_impl_.num_satellites_)
      - PROTOBUF_FIELD_OFFSET(ChassisGPS, _impl_.latitude_)>(
          reinterpret_cast<char*>(&_impl_.latitude_),
          reinterpret_cast<char*>(&other->_impl_.latitude_));
}

::google::protobuf::Metadata ChassisGPS::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class WheelSpeed::_Internal {
 public:
  using HasBits =
      decltype(std::declval<WheelSpeed>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_._has_bits_);
};

WheelSpeed::WheelSpeed(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.WheelSpeed)
}
WheelSpeed::WheelSpeed(
    ::google::protobuf::Arena* arena, const WheelSpeed& from)
    : WheelSpeed(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE WheelSpeed::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        wheel_direction_rr_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)},
        wheel_direction_rl_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)},
        wheel_direction_fr_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)},
        wheel_direction_fl_{static_cast< ::control::canbus::WheelSpeed_WheelSpeedType >(3)} {}

inline void WheelSpeed::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, wheel_spd_rr_),
           0,
           offsetof(Impl_, is_wheel_spd_fl_valid_) -
               offsetof(Impl_, wheel_spd_rr_) +
               sizeof(Impl_::is_wheel_spd_fl_valid_));
}
WheelSpeed::~WheelSpeed() {
  // @@protoc_insertion_point(destructor:control.canbus.WheelSpeed)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void WheelSpeed::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    WheelSpeed::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &WheelSpeed::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<WheelSpeed>(),
            ::google::protobuf::Message::GetNewImpl<WheelSpeed>(),
            ::google::protobuf::Message::GetClearImpl<WheelSpeed>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<WheelSpeed>(),
                ::google::protobuf::Message::GetSerializeImpl<WheelSpeed>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_._cached_size_),
            false,
        },
        &WheelSpeed::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* WheelSpeed::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 4, 0, 2> WheelSpeed::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_WheelSpeed_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::WheelSpeed>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool is_wheel_spd_rr_valid = 1 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(WheelSpeed, _impl_.is_wheel_spd_rr_valid_), 4>(),
     {8, 4, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_rr_valid_)}},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 2 [default = INVALID];
    {::_pbi::TcParser::FastEr0S1,
     {16, 8, 3, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_rr_)}},
    // optional double wheel_spd_rr = 3 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {25, 0, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_rr_)}},
    // optional bool is_wheel_spd_rl_valid = 4 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(WheelSpeed, _impl_.is_wheel_spd_rl_valid_), 5>(),
     {32, 5, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_rl_valid_)}},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 5 [default = INVALID];
    {::_pbi::TcParser::FastEr0S1,
     {40, 9, 3, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_rl_)}},
    // optional double wheel_spd_rl = 6 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {49, 1, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_rl_)}},
    // optional bool is_wheel_spd_fr_valid = 7 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(WheelSpeed, _impl_.is_wheel_spd_fr_valid_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_fr_valid_)}},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 8 [default = INVALID];
    {::_pbi::TcParser::FastEr0S1,
     {64, 10, 3, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_fr_)}},
    // optional double wheel_spd_fr = 9 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {73, 2, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_fr_)}},
    // optional bool is_wheel_spd_fl_valid = 10 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(WheelSpeed, _impl_.is_wheel_spd_fl_valid_), 7>(),
     {80, 7, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_fl_valid_)}},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 11 [default = INVALID];
    {::_pbi::TcParser::FastEr0S1,
     {88, 11, 3, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_fl_)}},
    // optional double wheel_spd_fl = 12 [default = 0];
    {::_pbi::TcParser::FastF64S1,
     {97, 3, 0, PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_fl_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool is_wheel_spd_rr_valid = 1 [default = false];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_rr_valid_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 2 [default = INVALID];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_rr_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double wheel_spd_rr = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_rr_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_wheel_spd_rl_valid = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_rl_valid_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 5 [default = INVALID];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_rl_), _Internal::kHasBitsOffset + 9, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double wheel_spd_rl = 6 [default = 0];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_rl_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_wheel_spd_fr_valid = 7 [default = false];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_fr_valid_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 8 [default = INVALID];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_fr_), _Internal::kHasBitsOffset + 10, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double wheel_spd_fr = 9 [default = 0];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_fr_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool is_wheel_spd_fl_valid = 10 [default = false];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.is_wheel_spd_fl_valid_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 11 [default = INVALID];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_fl_), _Internal::kHasBitsOffset + 11, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double wheel_spd_fl = 12 [default = 0];
    {PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_fl_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {0, 4},
    {0, 4},
    {0, 4},
    {0, 4},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void WheelSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.WheelSpeed)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.wheel_spd_rr_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_wheel_spd_fl_valid_) -
        reinterpret_cast<char*>(&_impl_.wheel_spd_rr_)) + sizeof(_impl_.is_wheel_spd_fl_valid_));
  }
  if (cached_has_bits & 0x00000f00u) {
    _impl_.wheel_direction_rr_ = 3;
    _impl_.wheel_direction_rl_ = 3;
    _impl_.wheel_direction_fr_ = 3;
    _impl_.wheel_direction_fl_ = 3;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* WheelSpeed::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.WheelSpeed)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_wheel_spd_rr_valid = 1 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_is_wheel_spd_rr_valid(), target);
  }

  // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 2 [default = INVALID];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_wheel_direction_rr(), target);
  }

  // optional double wheel_spd_rr = 3 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_wheel_spd_rr(), target);
  }

  // optional bool is_wheel_spd_rl_valid = 4 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is_wheel_spd_rl_valid(), target);
  }

  // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 5 [default = INVALID];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_wheel_direction_rl(), target);
  }

  // optional double wheel_spd_rl = 6 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_wheel_spd_rl(), target);
  }

  // optional bool is_wheel_spd_fr_valid = 7 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_wheel_spd_fr_valid(), target);
  }

  // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 8 [default = INVALID];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_wheel_direction_fr(), target);
  }

  // optional double wheel_spd_fr = 9 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_wheel_spd_fr(), target);
  }

  // optional bool is_wheel_spd_fl_valid = 10 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_is_wheel_spd_fl_valid(), target);
  }

  // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 11 [default = INVALID];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        11, this->_internal_wheel_direction_fl(), target);
  }

  // optional double wheel_spd_fl = 12 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_wheel_spd_fl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.WheelSpeed)
  return target;
}

::size_t WheelSpeed::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.WheelSpeed)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double wheel_spd_rr = 3 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }
    // optional double wheel_spd_rl = 6 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }
    // optional double wheel_spd_fr = 9 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }
    // optional double wheel_spd_fl = 12 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }
    // optional bool is_wheel_spd_rr_valid = 1 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }
    // optional bool is_wheel_spd_rl_valid = 4 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2;
    }
    // optional bool is_wheel_spd_fr_valid = 7 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }
    // optional bool is_wheel_spd_fl_valid = 10 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 2 [default = INVALID];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_wheel_direction_rr());
    }
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 5 [default = INVALID];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_wheel_direction_rl());
    }
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 8 [default = INVALID];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_wheel_direction_fr());
    }
    // optional .control.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 11 [default = INVALID];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_wheel_direction_fl());
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void WheelSpeed::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<WheelSpeed*>(&to_msg);
  auto& from = static_cast<const WheelSpeed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.WheelSpeed)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.wheel_spd_rr_ = from._impl_.wheel_spd_rr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.wheel_spd_rl_ = from._impl_.wheel_spd_rl_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.wheel_spd_fr_ = from._impl_.wheel_spd_fr_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.wheel_spd_fl_ = from._impl_.wheel_spd_fl_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_wheel_spd_rr_valid_ = from._impl_.is_wheel_spd_rr_valid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_wheel_spd_rl_valid_ = from._impl_.is_wheel_spd_rl_valid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_wheel_spd_fr_valid_ = from._impl_.is_wheel_spd_fr_valid_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_wheel_spd_fl_valid_ = from._impl_.is_wheel_spd_fl_valid_;
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.wheel_direction_rr_ = from._impl_.wheel_direction_rr_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.wheel_direction_rl_ = from._impl_.wheel_direction_rl_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.wheel_direction_fr_ = from._impl_.wheel_direction_fr_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.wheel_direction_fl_ = from._impl_.wheel_direction_fl_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void WheelSpeed::CopyFrom(const WheelSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.WheelSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void WheelSpeed::InternalSwap(WheelSpeed* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_direction_fl_)
      + sizeof(WheelSpeed::_impl_.wheel_direction_fl_)
      - PROTOBUF_FIELD_OFFSET(WheelSpeed, _impl_.wheel_spd_rr_)>(
          reinterpret_cast<char*>(&_impl_.wheel_spd_rr_),
          reinterpret_cast<char*>(&other->_impl_.wheel_spd_rr_));
}

::google::protobuf::Metadata WheelSpeed::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Sonar::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Sonar>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Sonar, _impl_._has_bits_);
};

void Sonar::clear_translation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.translation_ != nullptr) _impl_.translation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Sonar::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
Sonar::Sonar(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.Sonar)
}
inline PROTOBUF_NDEBUG_INLINE Sonar::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::canbus::Sonar& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Sonar::Sonar(
    ::google::protobuf::Arena* arena,
    const Sonar& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Sonar* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.translation_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::control::common::Point3D>(
                              arena, *from._impl_.translation_)
                        : nullptr;
  _impl_.rotation_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::control::common::Quaternion>(
                              arena, *from._impl_.rotation_)
                        : nullptr;
  _impl_.range_ = from._impl_.range_;

  // @@protoc_insertion_point(copy_constructor:control.canbus.Sonar)
}
inline PROTOBUF_NDEBUG_INLINE Sonar::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Sonar::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, translation_),
           0,
           offsetof(Impl_, range_) -
               offsetof(Impl_, translation_) +
               sizeof(Impl_::range_));
}
Sonar::~Sonar() {
  // @@protoc_insertion_point(destructor:control.canbus.Sonar)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Sonar::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.translation_;
  delete _impl_.rotation_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Sonar::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Sonar::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Sonar>(),
            ::google::protobuf::Message::GetNewImpl<Sonar>(),
            ::google::protobuf::Message::GetClearImpl<Sonar>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<Sonar>(),
                ::google::protobuf::Message::GetSerializeImpl<Sonar>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Sonar, _impl_._cached_size_),
            false,
        },
        &Sonar::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Sonar::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> Sonar::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Sonar, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Sonar_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::Sonar>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double range = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 2, 0, PROTOBUF_FIELD_OFFSET(Sonar, _impl_.range_)}},
    // optional .control.common.Point3D translation = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(Sonar, _impl_.translation_)}},
    // optional .control.common.Quaternion rotation = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(Sonar, _impl_.rotation_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double range = 1;
    {PROTOBUF_FIELD_OFFSET(Sonar, _impl_.range_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .control.common.Point3D translation = 2;
    {PROTOBUF_FIELD_OFFSET(Sonar, _impl_.translation_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .control.common.Quaternion rotation = 3;
    {PROTOBUF_FIELD_OFFSET(Sonar, _impl_.rotation_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::common::Point3D>()},
    {::_pbi::TcParser::GetTable<::control::common::Quaternion>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Sonar::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.Sonar)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.translation_ != nullptr);
      _impl_.translation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  _impl_.range_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Sonar::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.Sonar)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double range = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_range(), target);
  }

  // optional .control.common.Point3D translation = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *_impl_.translation_, _impl_.translation_->GetCachedSize(), target, stream);
  }

  // optional .control.common.Quaternion rotation = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *_impl_.rotation_, _impl_.rotation_->GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.Sonar)
  return target;
}

::size_t Sonar::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.Sonar)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .control.common.Point3D translation = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.translation_);
    }
    // optional .control.common.Quaternion rotation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.rotation_);
    }
    // optional double range = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void Sonar::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Sonar*>(&to_msg);
  auto& from = static_cast<const Sonar&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.Sonar)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.translation_ != nullptr);
      if (_this->_impl_.translation_ == nullptr) {
        _this->_impl_.translation_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::Point3D>(arena, *from._impl_.translation_);
      } else {
        _this->_impl_.translation_->MergeFrom(*from._impl_.translation_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.rotation_ != nullptr);
      if (_this->_impl_.rotation_ == nullptr) {
        _this->_impl_.rotation_ =
            ::google::protobuf::Message::CopyConstruct<::control::common::Quaternion>(arena, *from._impl_.rotation_);
      } else {
        _this->_impl_.rotation_->MergeFrom(*from._impl_.rotation_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.range_ = from._impl_.range_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Sonar::CopyFrom(const Sonar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.Sonar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Sonar::InternalSwap(Sonar* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sonar, _impl_.range_)
      + sizeof(Sonar::_impl_.range_)
      - PROTOBUF_FIELD_OFFSET(Sonar, _impl_.translation_)>(
          reinterpret_cast<char*>(&_impl_.translation_),
          reinterpret_cast<char*>(&other->_impl_.translation_));
}

::google::protobuf::Metadata Sonar::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Surround::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Surround>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Surround, _impl_._has_bits_);
};

Surround::Surround(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.Surround)
}
inline PROTOBUF_NDEBUG_INLINE Surround::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::canbus::Surround& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        sonar_range_{visibility, arena, from.sonar_range_},
        sonar_{visibility, arena, from.sonar_} {}

Surround::Surround(
    ::google::protobuf::Arena* arena,
    const Surround& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Surround* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, cross_traffic_alert_left_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, cross_traffic_alert_left_),
           offsetof(Impl_, sonar_fault_) -
               offsetof(Impl_, cross_traffic_alert_left_) +
               sizeof(Impl_::sonar_fault_));

  // @@protoc_insertion_point(copy_constructor:control.canbus.Surround)
}
inline PROTOBUF_NDEBUG_INLINE Surround::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        sonar_range_{visibility, arena},
        sonar_{visibility, arena} {}

inline void Surround::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, cross_traffic_alert_left_),
           0,
           offsetof(Impl_, sonar_fault_) -
               offsetof(Impl_, cross_traffic_alert_left_) +
               sizeof(Impl_::sonar_fault_));
}
Surround::~Surround() {
  // @@protoc_insertion_point(destructor:control.canbus.Surround)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Surround::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Surround::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Surround::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Surround>(),
            ::google::protobuf::Message::GetNewImpl<Surround>(),
            ::google::protobuf::Message::GetClearImpl<Surround>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<Surround>(),
                ::google::protobuf::Message::GetSerializeImpl<Surround>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Surround, _impl_._cached_size_),
            false,
        },
        &Surround::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Surround::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 24, 1, 0, 2> Surround::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Surround, _impl_._has_bits_),
    0, // no _extensions_
    24, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4278190080,  // skipmap
    offsetof(decltype(_table_), field_entries),
    24,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Surround_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::Surround>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool cross_traffic_alert_left = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.cross_traffic_alert_left_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_left_)}},
    // optional bool cross_traffic_alert_left_enabled = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.cross_traffic_alert_left_enabled_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_left_enabled_)}},
    // optional bool blind_spot_left_alert = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.blind_spot_left_alert_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_left_alert_)}},
    // optional bool blind_spot_left_alert_enabled = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.blind_spot_left_alert_enabled_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_left_alert_enabled_)}},
    // optional bool cross_traffic_alert_right = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.cross_traffic_alert_right_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_right_)}},
    // optional bool cross_traffic_alert_right_enabled = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.cross_traffic_alert_right_enabled_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_right_enabled_)}},
    // optional bool blind_spot_right_alert = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.blind_spot_right_alert_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_right_alert_)}},
    // optional bool blind_spot_right_alert_enabled = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Surround, _impl_.blind_spot_right_alert_enabled_), 7>(),
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_right_alert_enabled_)}},
    // optional double sonar00 = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 8, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar00_)}},
    // optional double sonar01 = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 9, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar01_)}},
    // optional double sonar02 = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 10, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar02_)}},
    // optional double sonar03 = 12;
    {::_pbi::TcParser::FastF64S1,
     {97, 11, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar03_)}},
    // optional double sonar04 = 13;
    {::_pbi::TcParser::FastF64S1,
     {105, 12, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar04_)}},
    // optional double sonar05 = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 13, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar05_)}},
    // optional double sonar06 = 15;
    {::_pbi::TcParser::FastF64S1,
     {121, 14, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar06_)}},
    // optional double sonar07 = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 15, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar07_)}},
    // optional double sonar08 = 17;
    {::_pbi::TcParser::FastF64S2,
     {393, 16, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar08_)}},
    // optional double sonar09 = 18;
    {::_pbi::TcParser::FastF64S2,
     {401, 17, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar09_)}},
    // optional double sonar10 = 19;
    {::_pbi::TcParser::FastF64S2,
     {409, 18, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar10_)}},
    // optional double sonar11 = 20;
    {::_pbi::TcParser::FastF64S2,
     {417, 19, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar11_)}},
    // optional bool sonar_enabled = 21;
    {::_pbi::TcParser::FastV8S2,
     {424, 20, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_enabled_)}},
    // optional bool sonar_fault = 22;
    {::_pbi::TcParser::FastV8S2,
     {432, 21, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_fault_)}},
    // repeated double sonar_range = 23;
    {::_pbi::TcParser::FastF64R2,
     {441, 63, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_range_)}},
    // repeated .control.canbus.Sonar sonar = 24;
    {::_pbi::TcParser::FastMtR2,
     {450, 63, 0, PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool cross_traffic_alert_left = 1;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_left_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool cross_traffic_alert_left_enabled = 2;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_left_enabled_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool blind_spot_left_alert = 3;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_left_alert_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool blind_spot_left_alert_enabled = 4;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_left_alert_enabled_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool cross_traffic_alert_right = 5;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_right_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool cross_traffic_alert_right_enabled = 6;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_right_enabled_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool blind_spot_right_alert = 7;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_right_alert_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool blind_spot_right_alert_enabled = 8;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.blind_spot_right_alert_enabled_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double sonar00 = 9;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar00_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar01 = 10;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar01_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar02 = 11;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar02_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar03 = 12;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar03_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar04 = 13;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar04_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar05 = 14;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar05_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar06 = 15;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar06_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar07 = 16;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar07_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar08 = 17;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar08_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar09 = 18;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar09_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar10 = 19;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar10_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double sonar11 = 20;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar11_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool sonar_enabled = 21;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_enabled_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool sonar_fault = 22;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_fault_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated double sonar_range = 23;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_range_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated .control.canbus.Sonar sonar = 24;
    {PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::control::canbus::Sonar>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Surround::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.Surround)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sonar_range_.Clear();
  _impl_.sonar_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.cross_traffic_alert_left_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.blind_spot_right_alert_enabled_) -
        reinterpret_cast<char*>(&_impl_.cross_traffic_alert_left_)) + sizeof(_impl_.blind_spot_right_alert_enabled_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.sonar00_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sonar07_) -
        reinterpret_cast<char*>(&_impl_.sonar00_)) + sizeof(_impl_.sonar07_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.sonar08_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sonar_fault_) -
        reinterpret_cast<char*>(&_impl_.sonar08_)) + sizeof(_impl_.sonar_fault_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Surround::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.Surround)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool cross_traffic_alert_left = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_cross_traffic_alert_left(), target);
  }

  // optional bool cross_traffic_alert_left_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_cross_traffic_alert_left_enabled(), target);
  }

  // optional bool blind_spot_left_alert = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_blind_spot_left_alert(), target);
  }

  // optional bool blind_spot_left_alert_enabled = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_blind_spot_left_alert_enabled(), target);
  }

  // optional bool cross_traffic_alert_right = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_cross_traffic_alert_right(), target);
  }

  // optional bool cross_traffic_alert_right_enabled = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_cross_traffic_alert_right_enabled(), target);
  }

  // optional bool blind_spot_right_alert = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_blind_spot_right_alert(), target);
  }

  // optional bool blind_spot_right_alert_enabled = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_blind_spot_right_alert_enabled(), target);
  }

  // optional double sonar00 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_sonar00(), target);
  }

  // optional double sonar01 = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_sonar01(), target);
  }

  // optional double sonar02 = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_sonar02(), target);
  }

  // optional double sonar03 = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_sonar03(), target);
  }

  // optional double sonar04 = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_sonar04(), target);
  }

  // optional double sonar05 = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_sonar05(), target);
  }

  // optional double sonar06 = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_sonar06(), target);
  }

  // optional double sonar07 = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_sonar07(), target);
  }

  // optional double sonar08 = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_sonar08(), target);
  }

  // optional double sonar09 = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        18, this->_internal_sonar09(), target);
  }

  // optional double sonar10 = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        19, this->_internal_sonar10(), target);
  }

  // optional double sonar11 = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_sonar11(), target);
  }

  // optional bool sonar_enabled = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        21, this->_internal_sonar_enabled(), target);
  }

  // optional bool sonar_fault = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        22, this->_internal_sonar_fault(), target);
  }

  // repeated double sonar_range = 23;
  for (int i = 0, n = this->_internal_sonar_range_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        23, this->_internal_sonar_range().Get(i), target);
  }

  // repeated .control.canbus.Sonar sonar = 24;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_sonar_size());
       i < n; i++) {
    const auto& repfield = this->_internal_sonar().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            24, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.Surround)
  return target;
}

::size_t Surround::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.Surround)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
   {
    // repeated double sonar_range = 23;
     {
      std::size_t data_size = std::size_t{8} *
          ::_pbi::FromIntSize(this->_internal_sonar_range_size())
      ;
      std::size_t tag_size = std::size_t{2} *
          ::_pbi::FromIntSize(this->_internal_sonar_range_size());
      ;
      total_size += tag_size + data_size;
    }
    // repeated .control.canbus.Sonar sonar = 24;
     {
      total_size += 2UL * this->_internal_sonar_size();
      for (const auto& msg : this->_internal_sonar()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool cross_traffic_alert_left = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2;
    }
    // optional bool cross_traffic_alert_left_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }
    // optional bool blind_spot_left_alert = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }
    // optional bool blind_spot_left_alert_enabled = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }
    // optional bool cross_traffic_alert_right = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }
    // optional bool cross_traffic_alert_right_enabled = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2;
    }
    // optional bool blind_spot_right_alert = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }
    // optional bool blind_spot_right_alert_enabled = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double sonar00 = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }
    // optional double sonar01 = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }
    // optional double sonar02 = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }
    // optional double sonar03 = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }
    // optional double sonar04 = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 9;
    }
    // optional double sonar05 = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 9;
    }
    // optional double sonar06 = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 9;
    }
    // optional double sonar07 = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 10;
    }
  }
  if (cached_has_bits & 0x003f0000u) {
    // optional double sonar08 = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 10;
    }
    // optional double sonar09 = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 10;
    }
    // optional double sonar10 = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 10;
    }
    // optional double sonar11 = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 10;
    }
    // optional bool sonar_enabled = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 3;
    }
    // optional bool sonar_fault = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 3;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void Surround::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Surround*>(&to_msg);
  auto& from = static_cast<const Surround&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.Surround)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_sonar_range()->MergeFrom(from._internal_sonar_range());
  _this->_internal_mutable_sonar()->MergeFrom(
      from._internal_sonar());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.cross_traffic_alert_left_ = from._impl_.cross_traffic_alert_left_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cross_traffic_alert_left_enabled_ = from._impl_.cross_traffic_alert_left_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blind_spot_left_alert_ = from._impl_.blind_spot_left_alert_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blind_spot_left_alert_enabled_ = from._impl_.blind_spot_left_alert_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cross_traffic_alert_right_ = from._impl_.cross_traffic_alert_right_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.cross_traffic_alert_right_enabled_ = from._impl_.cross_traffic_alert_right_enabled_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.blind_spot_right_alert_ = from._impl_.blind_spot_right_alert_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.blind_spot_right_alert_enabled_ = from._impl_.blind_spot_right_alert_enabled_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.sonar00_ = from._impl_.sonar00_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.sonar01_ = from._impl_.sonar01_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.sonar02_ = from._impl_.sonar02_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.sonar03_ = from._impl_.sonar03_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.sonar04_ = from._impl_.sonar04_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.sonar05_ = from._impl_.sonar05_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.sonar06_ = from._impl_.sonar06_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.sonar07_ = from._impl_.sonar07_;
    }
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.sonar08_ = from._impl_.sonar08_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.sonar09_ = from._impl_.sonar09_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.sonar10_ = from._impl_.sonar10_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.sonar11_ = from._impl_.sonar11_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.sonar_enabled_ = from._impl_.sonar_enabled_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.sonar_fault_ = from._impl_.sonar_fault_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Surround::CopyFrom(const Surround& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.Surround)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Surround::InternalSwap(Surround* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.sonar_range_.InternalSwap(&other->_impl_.sonar_range_);
  _impl_.sonar_.InternalSwap(&other->_impl_.sonar_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Surround, _impl_.sonar_fault_)
      + sizeof(Surround::_impl_.sonar_fault_)
      - PROTOBUF_FIELD_OFFSET(Surround, _impl_.cross_traffic_alert_left_)>(
          reinterpret_cast<char*>(&_impl_.cross_traffic_alert_left_),
          reinterpret_cast<char*>(&other->_impl_.cross_traffic_alert_left_));
}

::google::protobuf::Metadata Surround::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class License::_Internal {
 public:
  using HasBits =
      decltype(std::declval<License>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(License, _impl_._has_bits_);
};

License::License(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.License)
}
inline PROTOBUF_NDEBUG_INLINE License::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::control::canbus::License& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vin_(arena, from.vin_) {}

License::License(
    ::google::protobuf::Arena* arena,
    const License& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  License* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:control.canbus.License)
}
inline PROTOBUF_NDEBUG_INLINE License::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        vin_(arena) {}

inline void License::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
License::~License() {
  // @@protoc_insertion_point(destructor:control.canbus.License)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void License::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.vin_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    License::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &License::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<License>(),
            ::google::protobuf::Message::GetNewImpl<License>(),
            ::google::protobuf::Message::GetClearImpl<License>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<License>(),
                ::google::protobuf::Message::GetSerializeImpl<License>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(License, _impl_._cached_size_),
            false,
        },
        &License::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* License::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 34, 2> License::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(License, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_License_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::License>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string vin = 1 [deprecated = true];
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(License, _impl_.vin_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string vin = 1 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(License, _impl_.vin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\26\3\0\0\0\0\0\0"
    "control.canbus.License"
    "vin"
  }},
};

PROTOBUF_NOINLINE void License::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.License)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.vin_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* License::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.License)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string vin = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_vin();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "control.canbus.License.vin");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.License)
  return target;
}

::size_t License::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.License)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional string vin = 1 [deprecated = true];
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_vin());
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void License::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<License*>(&to_msg);
  auto& from = static_cast<const License&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.License)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_internal_set_vin(from._internal_vin());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void License::CopyFrom(const License& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.License)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void License::InternalSwap(License* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.vin_, &other->_impl_.vin_, arena);
}

::google::protobuf::Metadata License::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CheckResponse::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CheckResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_._has_bits_);
};

CheckResponse::CheckResponse(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:control.canbus.CheckResponse)
}
CheckResponse::CheckResponse(
    ::google::protobuf::Arena* arena, const CheckResponse& from)
    : CheckResponse(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CheckResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CheckResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, is_eps_online_),
           0,
           offsetof(Impl_, is_vcu_online_) -
               offsetof(Impl_, is_eps_online_) +
               sizeof(Impl_::is_vcu_online_));
}
CheckResponse::~CheckResponse() {
  // @@protoc_insertion_point(destructor:control.canbus.CheckResponse)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CheckResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    CheckResponse::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &CheckResponse::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<CheckResponse>(),
            ::google::protobuf::Message::GetNewImpl<CheckResponse>(),
            ::google::protobuf::Message::GetClearImpl<CheckResponse>(),
                ::google::protobuf::Message::GetByteSizeLongImpl<CheckResponse>(),
                ::google::protobuf::Message::GetSerializeImpl<CheckResponse>(),
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_._cached_size_),
            false,
        },
        &CheckResponse::kDescriptorMethods,
        &descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* CheckResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2> CheckResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CheckResponse_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::control::canbus::CheckResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool is_eps_online = 1 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_eps_online_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_eps_online_)}},
    // optional bool is_epb_online = 2 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_epb_online_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_epb_online_)}},
    // optional bool is_esp_online = 3 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_esp_online_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_esp_online_)}},
    // optional bool is_vtog_online = 4 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_vtog_online_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_vtog_online_)}},
    // optional bool is_scu_online = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_scu_online_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_scu_online_)}},
    // optional bool is_switch_online = 6 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_switch_online_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_switch_online_)}},
    // optional bool is_vcu_online = 7 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CheckResponse, _impl_.is_vcu_online_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_vcu_online_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool is_eps_online = 1 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_eps_online_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_epb_online = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_epb_online_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_esp_online = 3 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_esp_online_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_vtog_online = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_vtog_online_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_scu_online = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_scu_online_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_switch_online = 6 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_switch_online_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool is_vcu_online = 7 [default = false];
    {PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_vcu_online_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void CheckResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:control.canbus.CheckResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.is_eps_online_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_vcu_online_) -
        reinterpret_cast<char*>(&_impl_.is_eps_online_)) + sizeof(_impl_.is_vcu_online_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* CheckResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:control.canbus.CheckResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_eps_online = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_is_eps_online(), target);
  }

  // optional bool is_epb_online = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_is_epb_online(), target);
  }

  // optional bool is_esp_online = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_is_esp_online(), target);
  }

  // optional bool is_vtog_online = 4 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is_vtog_online(), target);
  }

  // optional bool is_scu_online = 5 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_is_scu_online(), target);
  }

  // optional bool is_switch_online = 6 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_is_switch_online(), target);
  }

  // optional bool is_vcu_online = 7 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_vcu_online(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:control.canbus.CheckResponse)
  return target;
}

::size_t CheckResponse::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:control.canbus.CheckResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(
      reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bool is_eps_online = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2;
    }
    // optional bool is_epb_online = 2 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }
    // optional bool is_esp_online = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }
    // optional bool is_vtog_online = 4 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }
    // optional bool is_scu_online = 5 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }
    // optional bool is_switch_online = 6 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2;
    }
    // optional bool is_vcu_online = 7 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

void CheckResponse::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CheckResponse*>(&to_msg);
  auto& from = static_cast<const CheckResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:control.canbus.CheckResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.is_eps_online_ = from._impl_.is_eps_online_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_epb_online_ = from._impl_.is_epb_online_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_esp_online_ = from._impl_.is_esp_online_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_vtog_online_ = from._impl_.is_vtog_online_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_scu_online_ = from._impl_.is_scu_online_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_switch_online_ = from._impl_.is_switch_online_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_vcu_online_ = from._impl_.is_vcu_online_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CheckResponse::CopyFrom(const CheckResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:control.canbus.CheckResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CheckResponse::InternalSwap(CheckResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_vcu_online_)
      + sizeof(CheckResponse::_impl_.is_vcu_online_)
      - PROTOBUF_FIELD_OFFSET(CheckResponse, _impl_.is_eps_online_)>(
          reinterpret_cast<char*>(&_impl_.is_eps_online_),
          reinterpret_cast<char*>(&other->_impl_.is_eps_online_));
}

::google::protobuf::Metadata CheckResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace canbus
}  // namespace control
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_common_5fmsgs_2fchassis_5fmsgs_2fchassis_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
