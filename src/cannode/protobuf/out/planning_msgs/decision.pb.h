// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning_msgs/decision.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fdecision_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fdecision_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common_msgs/basic_msgs/geometry.pb.h"
#include "common_msgs/basic_msgs/vehicle_signal.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_planning_5fmsgs_2fdecision_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_planning_5fmsgs_2fdecision_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_planning_5fmsgs_2fdecision_2eproto;
namespace control {
namespace planning {
class DecisionResult;
class DecisionResultDefaultTypeInternal;
extern DecisionResultDefaultTypeInternal _DecisionResult_default_instance_;
class EmergencyStopCruiseToStop;
class EmergencyStopCruiseToStopDefaultTypeInternal;
extern EmergencyStopCruiseToStopDefaultTypeInternal _EmergencyStopCruiseToStop_default_instance_;
class EmergencyStopHardBrake;
class EmergencyStopHardBrakeDefaultTypeInternal;
extern EmergencyStopHardBrakeDefaultTypeInternal _EmergencyStopHardBrake_default_instance_;
class MainChangeLane;
class MainChangeLaneDefaultTypeInternal;
extern MainChangeLaneDefaultTypeInternal _MainChangeLane_default_instance_;
class MainCruise;
class MainCruiseDefaultTypeInternal;
extern MainCruiseDefaultTypeInternal _MainCruise_default_instance_;
class MainDecision;
class MainDecisionDefaultTypeInternal;
extern MainDecisionDefaultTypeInternal _MainDecision_default_instance_;
class MainEmergencyStop;
class MainEmergencyStopDefaultTypeInternal;
extern MainEmergencyStopDefaultTypeInternal _MainEmergencyStop_default_instance_;
class MainMissionComplete;
class MainMissionCompleteDefaultTypeInternal;
extern MainMissionCompleteDefaultTypeInternal _MainMissionComplete_default_instance_;
class MainNotReady;
class MainNotReadyDefaultTypeInternal;
extern MainNotReadyDefaultTypeInternal _MainNotReady_default_instance_;
class MainParking;
class MainParkingDefaultTypeInternal;
extern MainParkingDefaultTypeInternal _MainParking_default_instance_;
class MainStop;
class MainStopDefaultTypeInternal;
extern MainStopDefaultTypeInternal _MainStop_default_instance_;
class ObjectAvoid;
class ObjectAvoidDefaultTypeInternal;
extern ObjectAvoidDefaultTypeInternal _ObjectAvoid_default_instance_;
class ObjectDecision;
class ObjectDecisionDefaultTypeInternal;
extern ObjectDecisionDefaultTypeInternal _ObjectDecision_default_instance_;
class ObjectDecisionType;
class ObjectDecisionTypeDefaultTypeInternal;
extern ObjectDecisionTypeDefaultTypeInternal _ObjectDecisionType_default_instance_;
class ObjectDecisions;
class ObjectDecisionsDefaultTypeInternal;
extern ObjectDecisionsDefaultTypeInternal _ObjectDecisions_default_instance_;
class ObjectDynamic;
class ObjectDynamicDefaultTypeInternal;
extern ObjectDynamicDefaultTypeInternal _ObjectDynamic_default_instance_;
class ObjectFollow;
class ObjectFollowDefaultTypeInternal;
extern ObjectFollowDefaultTypeInternal _ObjectFollow_default_instance_;
class ObjectIgnore;
class ObjectIgnoreDefaultTypeInternal;
extern ObjectIgnoreDefaultTypeInternal _ObjectIgnore_default_instance_;
class ObjectMotionType;
class ObjectMotionTypeDefaultTypeInternal;
extern ObjectMotionTypeDefaultTypeInternal _ObjectMotionType_default_instance_;
class ObjectNudge;
class ObjectNudgeDefaultTypeInternal;
extern ObjectNudgeDefaultTypeInternal _ObjectNudge_default_instance_;
class ObjectOvertake;
class ObjectOvertakeDefaultTypeInternal;
extern ObjectOvertakeDefaultTypeInternal _ObjectOvertake_default_instance_;
class ObjectSidePass;
class ObjectSidePassDefaultTypeInternal;
extern ObjectSidePassDefaultTypeInternal _ObjectSidePass_default_instance_;
class ObjectStatic;
class ObjectStaticDefaultTypeInternal;
extern ObjectStaticDefaultTypeInternal _ObjectStatic_default_instance_;
class ObjectStatus;
class ObjectStatusDefaultTypeInternal;
extern ObjectStatusDefaultTypeInternal _ObjectStatus_default_instance_;
class ObjectStop;
class ObjectStopDefaultTypeInternal;
extern ObjectStopDefaultTypeInternal _ObjectStop_default_instance_;
class ObjectYield;
class ObjectYieldDefaultTypeInternal;
extern ObjectYieldDefaultTypeInternal _ObjectYield_default_instance_;
class TargetLane;
class TargetLaneDefaultTypeInternal;
extern TargetLaneDefaultTypeInternal _TargetLane_default_instance_;
}  // namespace planning
}  // namespace control
PROTOBUF_NAMESPACE_OPEN
template<> ::control::planning::DecisionResult* Arena::CreateMaybeMessage<::control::planning::DecisionResult>(Arena*);
template<> ::control::planning::EmergencyStopCruiseToStop* Arena::CreateMaybeMessage<::control::planning::EmergencyStopCruiseToStop>(Arena*);
template<> ::control::planning::EmergencyStopHardBrake* Arena::CreateMaybeMessage<::control::planning::EmergencyStopHardBrake>(Arena*);
template<> ::control::planning::MainChangeLane* Arena::CreateMaybeMessage<::control::planning::MainChangeLane>(Arena*);
template<> ::control::planning::MainCruise* Arena::CreateMaybeMessage<::control::planning::MainCruise>(Arena*);
template<> ::control::planning::MainDecision* Arena::CreateMaybeMessage<::control::planning::MainDecision>(Arena*);
template<> ::control::planning::MainEmergencyStop* Arena::CreateMaybeMessage<::control::planning::MainEmergencyStop>(Arena*);
template<> ::control::planning::MainMissionComplete* Arena::CreateMaybeMessage<::control::planning::MainMissionComplete>(Arena*);
template<> ::control::planning::MainNotReady* Arena::CreateMaybeMessage<::control::planning::MainNotReady>(Arena*);
template<> ::control::planning::MainParking* Arena::CreateMaybeMessage<::control::planning::MainParking>(Arena*);
template<> ::control::planning::MainStop* Arena::CreateMaybeMessage<::control::planning::MainStop>(Arena*);
template<> ::control::planning::ObjectAvoid* Arena::CreateMaybeMessage<::control::planning::ObjectAvoid>(Arena*);
template<> ::control::planning::ObjectDecision* Arena::CreateMaybeMessage<::control::planning::ObjectDecision>(Arena*);
template<> ::control::planning::ObjectDecisionType* Arena::CreateMaybeMessage<::control::planning::ObjectDecisionType>(Arena*);
template<> ::control::planning::ObjectDecisions* Arena::CreateMaybeMessage<::control::planning::ObjectDecisions>(Arena*);
template<> ::control::planning::ObjectDynamic* Arena::CreateMaybeMessage<::control::planning::ObjectDynamic>(Arena*);
template<> ::control::planning::ObjectFollow* Arena::CreateMaybeMessage<::control::planning::ObjectFollow>(Arena*);
template<> ::control::planning::ObjectIgnore* Arena::CreateMaybeMessage<::control::planning::ObjectIgnore>(Arena*);
template<> ::control::planning::ObjectMotionType* Arena::CreateMaybeMessage<::control::planning::ObjectMotionType>(Arena*);
template<> ::control::planning::ObjectNudge* Arena::CreateMaybeMessage<::control::planning::ObjectNudge>(Arena*);
template<> ::control::planning::ObjectOvertake* Arena::CreateMaybeMessage<::control::planning::ObjectOvertake>(Arena*);
template<> ::control::planning::ObjectSidePass* Arena::CreateMaybeMessage<::control::planning::ObjectSidePass>(Arena*);
template<> ::control::planning::ObjectStatic* Arena::CreateMaybeMessage<::control::planning::ObjectStatic>(Arena*);
template<> ::control::planning::ObjectStatus* Arena::CreateMaybeMessage<::control::planning::ObjectStatus>(Arena*);
template<> ::control::planning::ObjectStop* Arena::CreateMaybeMessage<::control::planning::ObjectStop>(Arena*);
template<> ::control::planning::ObjectYield* Arena::CreateMaybeMessage<::control::planning::ObjectYield>(Arena*);
template<> ::control::planning::TargetLane* Arena::CreateMaybeMessage<::control::planning::TargetLane>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace control {
namespace planning {

enum ObjectNudge_Type : int {
  ObjectNudge_Type_LEFT_NUDGE = 1,
  ObjectNudge_Type_RIGHT_NUDGE = 2,
  ObjectNudge_Type_DYNAMIC_LEFT_NUDGE = 3,
  ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE = 4
};
bool ObjectNudge_Type_IsValid(int value);
constexpr ObjectNudge_Type ObjectNudge_Type_Type_MIN = ObjectNudge_Type_LEFT_NUDGE;
constexpr ObjectNudge_Type ObjectNudge_Type_Type_MAX = ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
constexpr int ObjectNudge_Type_Type_ARRAYSIZE = ObjectNudge_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectNudge_Type_descriptor();
template<typename T>
inline const std::string& ObjectNudge_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjectNudge_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjectNudge_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjectNudge_Type_descriptor(), enum_t_value);
}
inline bool ObjectNudge_Type_Parse(
    const std::string& name, ObjectNudge_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectNudge_Type>(
    ObjectNudge_Type_descriptor(), name, value);
}
enum ObjectSidePass_Type : int {
  ObjectSidePass_Type_LEFT = 1,
  ObjectSidePass_Type_RIGHT = 2
};
bool ObjectSidePass_Type_IsValid(int value);
constexpr ObjectSidePass_Type ObjectSidePass_Type_Type_MIN = ObjectSidePass_Type_LEFT;
constexpr ObjectSidePass_Type ObjectSidePass_Type_Type_MAX = ObjectSidePass_Type_RIGHT;
constexpr int ObjectSidePass_Type_Type_ARRAYSIZE = ObjectSidePass_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectSidePass_Type_descriptor();
template<typename T>
inline const std::string& ObjectSidePass_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjectSidePass_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjectSidePass_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjectSidePass_Type_descriptor(), enum_t_value);
}
inline bool ObjectSidePass_Type_Parse(
    const std::string& name, ObjectSidePass_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectSidePass_Type>(
    ObjectSidePass_Type_descriptor(), name, value);
}
enum MainEmergencyStop_ReasonCode : int {
  MainEmergencyStop_ReasonCode_ESTOP_REASON_INTERNAL_ERR = 1,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_COLLISION = 2,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_FIND_PATH = 3,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_MAKE_DECISION = 4,
  MainEmergencyStop_ReasonCode_ESTOP_REASON_SENSOR_ERROR = 5
};
bool MainEmergencyStop_ReasonCode_IsValid(int value);
constexpr MainEmergencyStop_ReasonCode MainEmergencyStop_ReasonCode_ReasonCode_MIN = MainEmergencyStop_ReasonCode_ESTOP_REASON_INTERNAL_ERR;
constexpr MainEmergencyStop_ReasonCode MainEmergencyStop_ReasonCode_ReasonCode_MAX = MainEmergencyStop_ReasonCode_ESTOP_REASON_SENSOR_ERROR;
constexpr int MainEmergencyStop_ReasonCode_ReasonCode_ARRAYSIZE = MainEmergencyStop_ReasonCode_ReasonCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MainEmergencyStop_ReasonCode_descriptor();
template<typename T>
inline const std::string& MainEmergencyStop_ReasonCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MainEmergencyStop_ReasonCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MainEmergencyStop_ReasonCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MainEmergencyStop_ReasonCode_descriptor(), enum_t_value);
}
inline bool MainEmergencyStop_ReasonCode_Parse(
    const std::string& name, MainEmergencyStop_ReasonCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MainEmergencyStop_ReasonCode>(
    MainEmergencyStop_ReasonCode_descriptor(), name, value);
}
enum MainChangeLane_Type : int {
  MainChangeLane_Type_LEFT = 1,
  MainChangeLane_Type_RIGHT = 2
};
bool MainChangeLane_Type_IsValid(int value);
constexpr MainChangeLane_Type MainChangeLane_Type_Type_MIN = MainChangeLane_Type_LEFT;
constexpr MainChangeLane_Type MainChangeLane_Type_Type_MAX = MainChangeLane_Type_RIGHT;
constexpr int MainChangeLane_Type_Type_ARRAYSIZE = MainChangeLane_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MainChangeLane_Type_descriptor();
template<typename T>
inline const std::string& MainChangeLane_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MainChangeLane_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MainChangeLane_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MainChangeLane_Type_descriptor(), enum_t_value);
}
inline bool MainChangeLane_Type_Parse(
    const std::string& name, MainChangeLane_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MainChangeLane_Type>(
    MainChangeLane_Type_descriptor(), name, value);
}
enum MainParking_ParkingStatus : int {
  MainParking_ParkingStatus_IN_PARKING = 1
};
bool MainParking_ParkingStatus_IsValid(int value);
constexpr MainParking_ParkingStatus MainParking_ParkingStatus_ParkingStatus_MIN = MainParking_ParkingStatus_IN_PARKING;
constexpr MainParking_ParkingStatus MainParking_ParkingStatus_ParkingStatus_MAX = MainParking_ParkingStatus_IN_PARKING;
constexpr int MainParking_ParkingStatus_ParkingStatus_ARRAYSIZE = MainParking_ParkingStatus_ParkingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MainParking_ParkingStatus_descriptor();
template<typename T>
inline const std::string& MainParking_ParkingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MainParking_ParkingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MainParking_ParkingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MainParking_ParkingStatus_descriptor(), enum_t_value);
}
inline bool MainParking_ParkingStatus_Parse(
    const std::string& name, MainParking_ParkingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MainParking_ParkingStatus>(
    MainParking_ParkingStatus_descriptor(), name, value);
}
enum StopReasonCode : int {
  STOP_REASON_HEAD_VEHICLE = 1,
  STOP_REASON_DESTINATION = 2,
  STOP_REASON_PEDESTRIAN = 3,
  STOP_REASON_OBSTACLE = 4,
  STOP_REASON_PREPARKING = 5,
  STOP_REASON_SIGNAL = 100,
  STOP_REASON_STOP_SIGN = 101,
  STOP_REASON_YIELD_SIGN = 102,
  STOP_REASON_CLEAR_ZONE = 103,
  STOP_REASON_CROSSWALK = 104,
  STOP_REASON_CREEPER = 105,
  STOP_REASON_REFERENCE_END = 106,
  STOP_REASON_YELLOW_SIGNAL = 107,
  STOP_REASON_PULL_OVER = 108,
  STOP_REASON_SIDEPASS_SAFETY = 109,
  STOP_REASON_PRE_OPEN_SPACE_STOP = 200,
  STOP_REASON_LANE_CHANGE_URGENCY = 201,
  STOP_REASON_EMERGENCY = 202
};
bool StopReasonCode_IsValid(int value);
constexpr StopReasonCode StopReasonCode_MIN = STOP_REASON_HEAD_VEHICLE;
constexpr StopReasonCode StopReasonCode_MAX = STOP_REASON_EMERGENCY;
constexpr int StopReasonCode_ARRAYSIZE = StopReasonCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopReasonCode_descriptor();
template<typename T>
inline const std::string& StopReasonCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopReasonCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopReasonCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopReasonCode_descriptor(), enum_t_value);
}
inline bool StopReasonCode_Parse(
    const std::string& name, StopReasonCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopReasonCode>(
    StopReasonCode_descriptor(), name, value);
}
// ===================================================================

class TargetLane PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.TargetLane) */ {
 public:
  inline TargetLane() : TargetLane(nullptr) {};
  virtual ~TargetLane();

  TargetLane(const TargetLane& from);
  TargetLane(TargetLane&& from) noexcept
    : TargetLane() {
    *this = ::std::move(from);
  }

  inline TargetLane& operator=(const TargetLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetLane& operator=(TargetLane&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TargetLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetLane* internal_default_instance() {
    return reinterpret_cast<const TargetLane*>(
               &_TargetLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TargetLane& a, TargetLane& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetLane* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TargetLane* New() const final {
    return CreateMaybeMessage<TargetLane>(nullptr);
  }

  TargetLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TargetLane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TargetLane& from);
  void MergeFrom(const TargetLane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetLane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.TargetLane";
  }
  protected:
  explicit TargetLane(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStartSFieldNumber = 2,
    kEndSFieldNumber = 3,
    kSpeedLimitFieldNumber = 4,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional double start_s = 2;
  bool has_start_s() const;
  private:
  bool _internal_has_start_s() const;
  public:
  void clear_start_s();
  double start_s() const;
  void set_start_s(double value);
  private:
  double _internal_start_s() const;
  void _internal_set_start_s(double value);
  public:

  // optional double end_s = 3;
  bool has_end_s() const;
  private:
  bool _internal_has_end_s() const;
  public:
  void clear_end_s();
  double end_s() const;
  void set_end_s(double value);
  private:
  double _internal_end_s() const;
  void _internal_set_end_s(double value);
  public:

  // optional double speed_limit = 4;
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  double speed_limit() const;
  void set_speed_limit(double value);
  private:
  double _internal_speed_limit() const;
  void _internal_set_speed_limit(double value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.TargetLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  double start_s_;
  double end_s_;
  double speed_limit_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectIgnore PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectIgnore) */ {
 public:
  inline ObjectIgnore() : ObjectIgnore(nullptr) {};
  virtual ~ObjectIgnore();

  ObjectIgnore(const ObjectIgnore& from);
  ObjectIgnore(ObjectIgnore&& from) noexcept
    : ObjectIgnore() {
    *this = ::std::move(from);
  }

  inline ObjectIgnore& operator=(const ObjectIgnore& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectIgnore& operator=(ObjectIgnore&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectIgnore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectIgnore* internal_default_instance() {
    return reinterpret_cast<const ObjectIgnore*>(
               &_ObjectIgnore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ObjectIgnore& a, ObjectIgnore& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectIgnore* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectIgnore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectIgnore* New() const final {
    return CreateMaybeMessage<ObjectIgnore>(nullptr);
  }

  ObjectIgnore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectIgnore>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectIgnore& from);
  void MergeFrom(const ObjectIgnore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectIgnore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectIgnore";
  }
  protected:
  explicit ObjectIgnore(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.ObjectIgnore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStop PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectStop) */ {
 public:
  inline ObjectStop() : ObjectStop(nullptr) {};
  virtual ~ObjectStop();

  ObjectStop(const ObjectStop& from);
  ObjectStop(ObjectStop&& from) noexcept
    : ObjectStop() {
    *this = ::std::move(from);
  }

  inline ObjectStop& operator=(const ObjectStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStop& operator=(ObjectStop&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectStop* internal_default_instance() {
    return reinterpret_cast<const ObjectStop*>(
               &_ObjectStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ObjectStop& a, ObjectStop& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectStop* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectStop* New() const final {
    return CreateMaybeMessage<ObjectStop>(nullptr);
  }

  ObjectStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectStop>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectStop& from);
  void MergeFrom(const ObjectStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectStop";
  }
  protected:
  explicit ObjectStop(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitForObstacleFieldNumber = 5,
    kStopPointFieldNumber = 3,
    kDistanceSFieldNumber = 2,
    kStopHeadingFieldNumber = 4,
    kReasonCodeFieldNumber = 1,
  };
  // repeated string wait_for_obstacle = 5;
  int wait_for_obstacle_size() const;
  private:
  int _internal_wait_for_obstacle_size() const;
  public:
  void clear_wait_for_obstacle();
  const std::string& wait_for_obstacle(int index) const;
  std::string* mutable_wait_for_obstacle(int index);
  void set_wait_for_obstacle(int index, const std::string& value);
  void set_wait_for_obstacle(int index, std::string&& value);
  void set_wait_for_obstacle(int index, const char* value);
  void set_wait_for_obstacle(int index, const char* value, size_t size);
  std::string* add_wait_for_obstacle();
  void add_wait_for_obstacle(const std::string& value);
  void add_wait_for_obstacle(std::string&& value);
  void add_wait_for_obstacle(const char* value);
  void add_wait_for_obstacle(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wait_for_obstacle() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wait_for_obstacle();
  private:
  const std::string& _internal_wait_for_obstacle(int index) const;
  std::string* _internal_add_wait_for_obstacle();
  public:

  // optional .control.common.PointENU stop_point = 3;
  bool has_stop_point() const;
  private:
  bool _internal_has_stop_point() const;
  public:
  void clear_stop_point();
  const ::control::common::PointENU& stop_point() const;
  ::control::common::PointENU* release_stop_point();
  ::control::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::control::common::PointENU* stop_point);
  private:
  const ::control::common::PointENU& _internal_stop_point() const;
  ::control::common::PointENU* _internal_mutable_stop_point();
  public:
  void unsafe_arena_set_allocated_stop_point(
      ::control::common::PointENU* stop_point);
  ::control::common::PointENU* unsafe_arena_release_stop_point();

  // optional double distance_s = 2;
  bool has_distance_s() const;
  private:
  bool _internal_has_distance_s() const;
  public:
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // optional double stop_heading = 4;
  bool has_stop_heading() const;
  private:
  bool _internal_has_stop_heading() const;
  public:
  void clear_stop_heading();
  double stop_heading() const;
  void set_stop_heading(double value);
  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);
  public:

  // optional .control.planning.StopReasonCode reason_code = 1;
  bool has_reason_code() const;
  private:
  bool _internal_has_reason_code() const;
  public:
  void clear_reason_code();
  ::control::planning::StopReasonCode reason_code() const;
  void set_reason_code(::control::planning::StopReasonCode value);
  private:
  ::control::planning::StopReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::control::planning::StopReasonCode value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wait_for_obstacle_;
  ::control::common::PointENU* stop_point_;
  double distance_s_;
  double stop_heading_;
  int reason_code_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectNudge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectNudge) */ {
 public:
  inline ObjectNudge() : ObjectNudge(nullptr) {};
  virtual ~ObjectNudge();

  ObjectNudge(const ObjectNudge& from);
  ObjectNudge(ObjectNudge&& from) noexcept
    : ObjectNudge() {
    *this = ::std::move(from);
  }

  inline ObjectNudge& operator=(const ObjectNudge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectNudge& operator=(ObjectNudge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectNudge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectNudge* internal_default_instance() {
    return reinterpret_cast<const ObjectNudge*>(
               &_ObjectNudge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObjectNudge& a, ObjectNudge& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectNudge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectNudge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectNudge* New() const final {
    return CreateMaybeMessage<ObjectNudge>(nullptr);
  }

  ObjectNudge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectNudge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectNudge& from);
  void MergeFrom(const ObjectNudge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectNudge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectNudge";
  }
  protected:
  explicit ObjectNudge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ObjectNudge_Type Type;
  static constexpr Type LEFT_NUDGE =
    ObjectNudge_Type_LEFT_NUDGE;
  static constexpr Type RIGHT_NUDGE =
    ObjectNudge_Type_RIGHT_NUDGE;
  static constexpr Type DYNAMIC_LEFT_NUDGE =
    ObjectNudge_Type_DYNAMIC_LEFT_NUDGE;
  static constexpr Type DYNAMIC_RIGHT_NUDGE =
    ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
  static inline bool Type_IsValid(int value) {
    return ObjectNudge_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ObjectNudge_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ObjectNudge_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ObjectNudge_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ObjectNudge_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ObjectNudge_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ObjectNudge_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceLFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional double distance_l = 2;
  bool has_distance_l() const;
  private:
  bool _internal_has_distance_l() const;
  public:
  void clear_distance_l();
  double distance_l() const;
  void set_distance_l(double value);
  private:
  double _internal_distance_l() const;
  void _internal_set_distance_l(double value);
  public:

  // optional .control.planning.ObjectNudge.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::control::planning::ObjectNudge_Type type() const;
  void set_type(::control::planning::ObjectNudge_Type value);
  private:
  ::control::planning::ObjectNudge_Type _internal_type() const;
  void _internal_set_type(::control::planning::ObjectNudge_Type value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectNudge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double distance_l_;
  int type_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectYield PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectYield) */ {
 public:
  inline ObjectYield() : ObjectYield(nullptr) {};
  virtual ~ObjectYield();

  ObjectYield(const ObjectYield& from);
  ObjectYield(ObjectYield&& from) noexcept
    : ObjectYield() {
    *this = ::std::move(from);
  }

  inline ObjectYield& operator=(const ObjectYield& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectYield& operator=(ObjectYield&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectYield& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectYield* internal_default_instance() {
    return reinterpret_cast<const ObjectYield*>(
               &_ObjectYield_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObjectYield& a, ObjectYield& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectYield* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectYield* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectYield* New() const final {
    return CreateMaybeMessage<ObjectYield>(nullptr);
  }

  ObjectYield* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectYield>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectYield& from);
  void MergeFrom(const ObjectYield& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectYield* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectYield";
  }
  protected:
  explicit ObjectYield(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
    kTimeBufferFieldNumber = 4,
  };
  // optional .control.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  private:
  bool _internal_has_fence_point() const;
  public:
  void clear_fence_point();
  const ::control::common::PointENU& fence_point() const;
  ::control::common::PointENU* release_fence_point();
  ::control::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::control::common::PointENU* fence_point);
  private:
  const ::control::common::PointENU& _internal_fence_point() const;
  ::control::common::PointENU* _internal_mutable_fence_point();
  public:
  void unsafe_arena_set_allocated_fence_point(
      ::control::common::PointENU* fence_point);
  ::control::common::PointENU* unsafe_arena_release_fence_point();

  // optional double distance_s = 1;
  bool has_distance_s() const;
  private:
  bool _internal_has_distance_s() const;
  public:
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  private:
  bool _internal_has_fence_heading() const;
  public:
  void clear_fence_heading();
  double fence_heading() const;
  void set_fence_heading(double value);
  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);
  public:

  // optional double time_buffer = 4;
  bool has_time_buffer() const;
  private:
  bool _internal_has_time_buffer() const;
  public:
  void clear_time_buffer();
  double time_buffer() const;
  void set_time_buffer(double value);
  private:
  double _internal_time_buffer() const;
  void _internal_set_time_buffer(double value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectYield)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::control::common::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  double time_buffer_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectFollow PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectFollow) */ {
 public:
  inline ObjectFollow() : ObjectFollow(nullptr) {};
  virtual ~ObjectFollow();

  ObjectFollow(const ObjectFollow& from);
  ObjectFollow(ObjectFollow&& from) noexcept
    : ObjectFollow() {
    *this = ::std::move(from);
  }

  inline ObjectFollow& operator=(const ObjectFollow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectFollow& operator=(ObjectFollow&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectFollow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectFollow* internal_default_instance() {
    return reinterpret_cast<const ObjectFollow*>(
               &_ObjectFollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ObjectFollow& a, ObjectFollow& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectFollow* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectFollow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectFollow* New() const final {
    return CreateMaybeMessage<ObjectFollow>(nullptr);
  }

  ObjectFollow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectFollow>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectFollow& from);
  void MergeFrom(const ObjectFollow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectFollow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectFollow";
  }
  protected:
  explicit ObjectFollow(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
  };
  // optional .control.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  private:
  bool _internal_has_fence_point() const;
  public:
  void clear_fence_point();
  const ::control::common::PointENU& fence_point() const;
  ::control::common::PointENU* release_fence_point();
  ::control::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::control::common::PointENU* fence_point);
  private:
  const ::control::common::PointENU& _internal_fence_point() const;
  ::control::common::PointENU* _internal_mutable_fence_point();
  public:
  void unsafe_arena_set_allocated_fence_point(
      ::control::common::PointENU* fence_point);
  ::control::common::PointENU* unsafe_arena_release_fence_point();

  // optional double distance_s = 1;
  bool has_distance_s() const;
  private:
  bool _internal_has_distance_s() const;
  public:
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  private:
  bool _internal_has_fence_heading() const;
  public:
  void clear_fence_heading();
  double fence_heading() const;
  void set_fence_heading(double value);
  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectFollow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::control::common::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectOvertake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectOvertake) */ {
 public:
  inline ObjectOvertake() : ObjectOvertake(nullptr) {};
  virtual ~ObjectOvertake();

  ObjectOvertake(const ObjectOvertake& from);
  ObjectOvertake(ObjectOvertake&& from) noexcept
    : ObjectOvertake() {
    *this = ::std::move(from);
  }

  inline ObjectOvertake& operator=(const ObjectOvertake& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectOvertake& operator=(ObjectOvertake&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectOvertake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectOvertake* internal_default_instance() {
    return reinterpret_cast<const ObjectOvertake*>(
               &_ObjectOvertake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ObjectOvertake& a, ObjectOvertake& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectOvertake* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectOvertake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectOvertake* New() const final {
    return CreateMaybeMessage<ObjectOvertake>(nullptr);
  }

  ObjectOvertake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectOvertake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectOvertake& from);
  void MergeFrom(const ObjectOvertake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOvertake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectOvertake";
  }
  protected:
  explicit ObjectOvertake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
    kTimeBufferFieldNumber = 4,
  };
  // optional .control.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  private:
  bool _internal_has_fence_point() const;
  public:
  void clear_fence_point();
  const ::control::common::PointENU& fence_point() const;
  ::control::common::PointENU* release_fence_point();
  ::control::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::control::common::PointENU* fence_point);
  private:
  const ::control::common::PointENU& _internal_fence_point() const;
  ::control::common::PointENU* _internal_mutable_fence_point();
  public:
  void unsafe_arena_set_allocated_fence_point(
      ::control::common::PointENU* fence_point);
  ::control::common::PointENU* unsafe_arena_release_fence_point();

  // optional double distance_s = 1;
  bool has_distance_s() const;
  private:
  bool _internal_has_distance_s() const;
  public:
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  private:
  bool _internal_has_fence_heading() const;
  public:
  void clear_fence_heading();
  double fence_heading() const;
  void set_fence_heading(double value);
  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);
  public:

  // optional double time_buffer = 4;
  bool has_time_buffer() const;
  private:
  bool _internal_has_time_buffer() const;
  public:
  void clear_time_buffer();
  double time_buffer() const;
  void set_time_buffer(double value);
  private:
  double _internal_time_buffer() const;
  void _internal_set_time_buffer(double value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectOvertake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::control::common::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  double time_buffer_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectSidePass PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectSidePass) */ {
 public:
  inline ObjectSidePass() : ObjectSidePass(nullptr) {};
  virtual ~ObjectSidePass();

  ObjectSidePass(const ObjectSidePass& from);
  ObjectSidePass(ObjectSidePass&& from) noexcept
    : ObjectSidePass() {
    *this = ::std::move(from);
  }

  inline ObjectSidePass& operator=(const ObjectSidePass& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectSidePass& operator=(ObjectSidePass&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectSidePass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectSidePass* internal_default_instance() {
    return reinterpret_cast<const ObjectSidePass*>(
               &_ObjectSidePass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ObjectSidePass& a, ObjectSidePass& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectSidePass* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectSidePass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectSidePass* New() const final {
    return CreateMaybeMessage<ObjectSidePass>(nullptr);
  }

  ObjectSidePass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectSidePass>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectSidePass& from);
  void MergeFrom(const ObjectSidePass& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectSidePass* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectSidePass";
  }
  protected:
  explicit ObjectSidePass(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ObjectSidePass_Type Type;
  static constexpr Type LEFT =
    ObjectSidePass_Type_LEFT;
  static constexpr Type RIGHT =
    ObjectSidePass_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return ObjectSidePass_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ObjectSidePass_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ObjectSidePass_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ObjectSidePass_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ObjectSidePass_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ObjectSidePass_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ObjectSidePass_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .control.planning.ObjectSidePass.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::control::planning::ObjectSidePass_Type type() const;
  void set_type(::control::planning::ObjectSidePass_Type value);
  private:
  ::control::planning::ObjectSidePass_Type _internal_type() const;
  void _internal_set_type(::control::planning::ObjectSidePass_Type value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectSidePass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectAvoid PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectAvoid) */ {
 public:
  inline ObjectAvoid() : ObjectAvoid(nullptr) {};
  virtual ~ObjectAvoid();

  ObjectAvoid(const ObjectAvoid& from);
  ObjectAvoid(ObjectAvoid&& from) noexcept
    : ObjectAvoid() {
    *this = ::std::move(from);
  }

  inline ObjectAvoid& operator=(const ObjectAvoid& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectAvoid& operator=(ObjectAvoid&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectAvoid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectAvoid* internal_default_instance() {
    return reinterpret_cast<const ObjectAvoid*>(
               &_ObjectAvoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObjectAvoid& a, ObjectAvoid& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectAvoid* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectAvoid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectAvoid* New() const final {
    return CreateMaybeMessage<ObjectAvoid>(nullptr);
  }

  ObjectAvoid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectAvoid>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectAvoid& from);
  void MergeFrom(const ObjectAvoid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectAvoid* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectAvoid";
  }
  protected:
  explicit ObjectAvoid(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.ObjectAvoid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectStatus) */ {
 public:
  inline ObjectStatus() : ObjectStatus(nullptr) {};
  virtual ~ObjectStatus();

  ObjectStatus(const ObjectStatus& from);
  ObjectStatus(ObjectStatus&& from) noexcept
    : ObjectStatus() {
    *this = ::std::move(from);
  }

  inline ObjectStatus& operator=(const ObjectStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStatus& operator=(ObjectStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectStatus* internal_default_instance() {
    return reinterpret_cast<const ObjectStatus*>(
               &_ObjectStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObjectStatus& a, ObjectStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectStatus* New() const final {
    return CreateMaybeMessage<ObjectStatus>(nullptr);
  }

  ObjectStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectStatus& from);
  void MergeFrom(const ObjectStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectStatus";
  }
  protected:
  explicit ObjectStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotionTypeFieldNumber = 1,
    kDecisionTypeFieldNumber = 2,
  };
  // optional .control.planning.ObjectMotionType motion_type = 1;
  bool has_motion_type() const;
  private:
  bool _internal_has_motion_type() const;
  public:
  void clear_motion_type();
  const ::control::planning::ObjectMotionType& motion_type() const;
  ::control::planning::ObjectMotionType* release_motion_type();
  ::control::planning::ObjectMotionType* mutable_motion_type();
  void set_allocated_motion_type(::control::planning::ObjectMotionType* motion_type);
  private:
  const ::control::planning::ObjectMotionType& _internal_motion_type() const;
  ::control::planning::ObjectMotionType* _internal_mutable_motion_type();
  public:
  void unsafe_arena_set_allocated_motion_type(
      ::control::planning::ObjectMotionType* motion_type);
  ::control::planning::ObjectMotionType* unsafe_arena_release_motion_type();

  // optional .control.planning.ObjectDecisionType decision_type = 2;
  bool has_decision_type() const;
  private:
  bool _internal_has_decision_type() const;
  public:
  void clear_decision_type();
  const ::control::planning::ObjectDecisionType& decision_type() const;
  ::control::planning::ObjectDecisionType* release_decision_type();
  ::control::planning::ObjectDecisionType* mutable_decision_type();
  void set_allocated_decision_type(::control::planning::ObjectDecisionType* decision_type);
  private:
  const ::control::planning::ObjectDecisionType& _internal_decision_type() const;
  ::control::planning::ObjectDecisionType* _internal_mutable_decision_type();
  public:
  void unsafe_arena_set_allocated_decision_type(
      ::control::planning::ObjectDecisionType* decision_type);
  ::control::planning::ObjectDecisionType* unsafe_arena_release_decision_type();

  // @@protoc_insertion_point(class_scope:control.planning.ObjectStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::control::planning::ObjectMotionType* motion_type_;
  ::control::planning::ObjectDecisionType* decision_type_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectStatic) */ {
 public:
  inline ObjectStatic() : ObjectStatic(nullptr) {};
  virtual ~ObjectStatic();

  ObjectStatic(const ObjectStatic& from);
  ObjectStatic(ObjectStatic&& from) noexcept
    : ObjectStatic() {
    *this = ::std::move(from);
  }

  inline ObjectStatic& operator=(const ObjectStatic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStatic& operator=(ObjectStatic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectStatic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectStatic* internal_default_instance() {
    return reinterpret_cast<const ObjectStatic*>(
               &_ObjectStatic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ObjectStatic& a, ObjectStatic& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectStatic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStatic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectStatic* New() const final {
    return CreateMaybeMessage<ObjectStatic>(nullptr);
  }

  ObjectStatic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectStatic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectStatic& from);
  void MergeFrom(const ObjectStatic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStatic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectStatic";
  }
  protected:
  explicit ObjectStatic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.ObjectStatic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDynamic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectDynamic) */ {
 public:
  inline ObjectDynamic() : ObjectDynamic(nullptr) {};
  virtual ~ObjectDynamic();

  ObjectDynamic(const ObjectDynamic& from);
  ObjectDynamic(ObjectDynamic&& from) noexcept
    : ObjectDynamic() {
    *this = ::std::move(from);
  }

  inline ObjectDynamic& operator=(const ObjectDynamic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDynamic& operator=(ObjectDynamic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectDynamic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDynamic* internal_default_instance() {
    return reinterpret_cast<const ObjectDynamic*>(
               &_ObjectDynamic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ObjectDynamic& a, ObjectDynamic& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDynamic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDynamic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectDynamic* New() const final {
    return CreateMaybeMessage<ObjectDynamic>(nullptr);
  }

  ObjectDynamic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDynamic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectDynamic& from);
  void MergeFrom(const ObjectDynamic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDynamic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectDynamic";
  }
  protected:
  explicit ObjectDynamic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.ObjectDynamic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectMotionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectMotionType) */ {
 public:
  inline ObjectMotionType() : ObjectMotionType(nullptr) {};
  virtual ~ObjectMotionType();

  ObjectMotionType(const ObjectMotionType& from);
  ObjectMotionType(ObjectMotionType&& from) noexcept
    : ObjectMotionType() {
    *this = ::std::move(from);
  }

  inline ObjectMotionType& operator=(const ObjectMotionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectMotionType& operator=(ObjectMotionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectMotionType& default_instance();

  enum MotionTagCase {
    kStatic = 1,
    kDynamic = 2,
    MOTION_TAG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectMotionType* internal_default_instance() {
    return reinterpret_cast<const ObjectMotionType*>(
               &_ObjectMotionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ObjectMotionType& a, ObjectMotionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectMotionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectMotionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectMotionType* New() const final {
    return CreateMaybeMessage<ObjectMotionType>(nullptr);
  }

  ObjectMotionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectMotionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectMotionType& from);
  void MergeFrom(const ObjectMotionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectMotionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectMotionType";
  }
  protected:
  explicit ObjectMotionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaticFieldNumber = 1,
    kDynamicFieldNumber = 2,
  };
  // .control.planning.ObjectStatic static = 1;
  bool has_static_() const;
  private:
  bool _internal_has_static_() const;
  public:
  void clear_static_();
  const ::control::planning::ObjectStatic& static_() const;
  ::control::planning::ObjectStatic* release_static_();
  ::control::planning::ObjectStatic* mutable_static_();
  void set_allocated_static_(::control::planning::ObjectStatic* static_);
  private:
  const ::control::planning::ObjectStatic& _internal_static_() const;
  ::control::planning::ObjectStatic* _internal_mutable_static_();
  public:
  void unsafe_arena_set_allocated_static_(
      ::control::planning::ObjectStatic* static_);
  ::control::planning::ObjectStatic* unsafe_arena_release_static_();

  // .control.planning.ObjectDynamic dynamic = 2;
  bool has_dynamic() const;
  private:
  bool _internal_has_dynamic() const;
  public:
  void clear_dynamic();
  const ::control::planning::ObjectDynamic& dynamic() const;
  ::control::planning::ObjectDynamic* release_dynamic();
  ::control::planning::ObjectDynamic* mutable_dynamic();
  void set_allocated_dynamic(::control::planning::ObjectDynamic* dynamic);
  private:
  const ::control::planning::ObjectDynamic& _internal_dynamic() const;
  ::control::planning::ObjectDynamic* _internal_mutable_dynamic();
  public:
  void unsafe_arena_set_allocated_dynamic(
      ::control::planning::ObjectDynamic* dynamic);
  ::control::planning::ObjectDynamic* unsafe_arena_release_dynamic();

  void clear_motion_tag();
  MotionTagCase motion_tag_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.ObjectMotionType)
 private:
  class _Internal;
  void set_has_static_();
  void set_has_dynamic();

  inline bool has_motion_tag() const;
  inline void clear_has_motion_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MotionTagUnion {
    MotionTagUnion() {}
    ::control::planning::ObjectStatic* static__;
    ::control::planning::ObjectDynamic* dynamic_;
  } motion_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectDecisionType) */ {
 public:
  inline ObjectDecisionType() : ObjectDecisionType(nullptr) {};
  virtual ~ObjectDecisionType();

  ObjectDecisionType(const ObjectDecisionType& from);
  ObjectDecisionType(ObjectDecisionType&& from) noexcept
    : ObjectDecisionType() {
    *this = ::std::move(from);
  }

  inline ObjectDecisionType& operator=(const ObjectDecisionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecisionType& operator=(ObjectDecisionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectDecisionType& default_instance();

  enum ObjectTagCase {
    kIgnore = 1,
    kStop = 2,
    kFollow = 3,
    kYield = 4,
    kOvertake = 5,
    kNudge = 6,
    kAvoid = 7,
    kSidePass = 8,
    OBJECT_TAG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDecisionType* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisionType*>(
               &_ObjectDecisionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ObjectDecisionType& a, ObjectDecisionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDecisionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecisionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectDecisionType* New() const final {
    return CreateMaybeMessage<ObjectDecisionType>(nullptr);
  }

  ObjectDecisionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDecisionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectDecisionType& from);
  void MergeFrom(const ObjectDecisionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecisionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectDecisionType";
  }
  protected:
  explicit ObjectDecisionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIgnoreFieldNumber = 1,
    kStopFieldNumber = 2,
    kFollowFieldNumber = 3,
    kYieldFieldNumber = 4,
    kOvertakeFieldNumber = 5,
    kNudgeFieldNumber = 6,
    kAvoidFieldNumber = 7,
    kSidePassFieldNumber = 8,
  };
  // .control.planning.ObjectIgnore ignore = 1;
  bool has_ignore() const;
  private:
  bool _internal_has_ignore() const;
  public:
  void clear_ignore();
  const ::control::planning::ObjectIgnore& ignore() const;
  ::control::planning::ObjectIgnore* release_ignore();
  ::control::planning::ObjectIgnore* mutable_ignore();
  void set_allocated_ignore(::control::planning::ObjectIgnore* ignore);
  private:
  const ::control::planning::ObjectIgnore& _internal_ignore() const;
  ::control::planning::ObjectIgnore* _internal_mutable_ignore();
  public:
  void unsafe_arena_set_allocated_ignore(
      ::control::planning::ObjectIgnore* ignore);
  ::control::planning::ObjectIgnore* unsafe_arena_release_ignore();

  // .control.planning.ObjectStop stop = 2;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::control::planning::ObjectStop& stop() const;
  ::control::planning::ObjectStop* release_stop();
  ::control::planning::ObjectStop* mutable_stop();
  void set_allocated_stop(::control::planning::ObjectStop* stop);
  private:
  const ::control::planning::ObjectStop& _internal_stop() const;
  ::control::planning::ObjectStop* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::control::planning::ObjectStop* stop);
  ::control::planning::ObjectStop* unsafe_arena_release_stop();

  // .control.planning.ObjectFollow follow = 3;
  bool has_follow() const;
  private:
  bool _internal_has_follow() const;
  public:
  void clear_follow();
  const ::control::planning::ObjectFollow& follow() const;
  ::control::planning::ObjectFollow* release_follow();
  ::control::planning::ObjectFollow* mutable_follow();
  void set_allocated_follow(::control::planning::ObjectFollow* follow);
  private:
  const ::control::planning::ObjectFollow& _internal_follow() const;
  ::control::planning::ObjectFollow* _internal_mutable_follow();
  public:
  void unsafe_arena_set_allocated_follow(
      ::control::planning::ObjectFollow* follow);
  ::control::planning::ObjectFollow* unsafe_arena_release_follow();

  // .control.planning.ObjectYield yield = 4;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  const ::control::planning::ObjectYield& yield() const;
  ::control::planning::ObjectYield* release_yield();
  ::control::planning::ObjectYield* mutable_yield();
  void set_allocated_yield(::control::planning::ObjectYield* yield);
  private:
  const ::control::planning::ObjectYield& _internal_yield() const;
  ::control::planning::ObjectYield* _internal_mutable_yield();
  public:
  void unsafe_arena_set_allocated_yield(
      ::control::planning::ObjectYield* yield);
  ::control::planning::ObjectYield* unsafe_arena_release_yield();

  // .control.planning.ObjectOvertake overtake = 5;
  bool has_overtake() const;
  private:
  bool _internal_has_overtake() const;
  public:
  void clear_overtake();
  const ::control::planning::ObjectOvertake& overtake() const;
  ::control::planning::ObjectOvertake* release_overtake();
  ::control::planning::ObjectOvertake* mutable_overtake();
  void set_allocated_overtake(::control::planning::ObjectOvertake* overtake);
  private:
  const ::control::planning::ObjectOvertake& _internal_overtake() const;
  ::control::planning::ObjectOvertake* _internal_mutable_overtake();
  public:
  void unsafe_arena_set_allocated_overtake(
      ::control::planning::ObjectOvertake* overtake);
  ::control::planning::ObjectOvertake* unsafe_arena_release_overtake();

  // .control.planning.ObjectNudge nudge = 6;
  bool has_nudge() const;
  private:
  bool _internal_has_nudge() const;
  public:
  void clear_nudge();
  const ::control::planning::ObjectNudge& nudge() const;
  ::control::planning::ObjectNudge* release_nudge();
  ::control::planning::ObjectNudge* mutable_nudge();
  void set_allocated_nudge(::control::planning::ObjectNudge* nudge);
  private:
  const ::control::planning::ObjectNudge& _internal_nudge() const;
  ::control::planning::ObjectNudge* _internal_mutable_nudge();
  public:
  void unsafe_arena_set_allocated_nudge(
      ::control::planning::ObjectNudge* nudge);
  ::control::planning::ObjectNudge* unsafe_arena_release_nudge();

  // .control.planning.ObjectAvoid avoid = 7;
  bool has_avoid() const;
  private:
  bool _internal_has_avoid() const;
  public:
  void clear_avoid();
  const ::control::planning::ObjectAvoid& avoid() const;
  ::control::planning::ObjectAvoid* release_avoid();
  ::control::planning::ObjectAvoid* mutable_avoid();
  void set_allocated_avoid(::control::planning::ObjectAvoid* avoid);
  private:
  const ::control::planning::ObjectAvoid& _internal_avoid() const;
  ::control::planning::ObjectAvoid* _internal_mutable_avoid();
  public:
  void unsafe_arena_set_allocated_avoid(
      ::control::planning::ObjectAvoid* avoid);
  ::control::planning::ObjectAvoid* unsafe_arena_release_avoid();

  // .control.planning.ObjectSidePass side_pass = 8;
  bool has_side_pass() const;
  private:
  bool _internal_has_side_pass() const;
  public:
  void clear_side_pass();
  const ::control::planning::ObjectSidePass& side_pass() const;
  ::control::planning::ObjectSidePass* release_side_pass();
  ::control::planning::ObjectSidePass* mutable_side_pass();
  void set_allocated_side_pass(::control::planning::ObjectSidePass* side_pass);
  private:
  const ::control::planning::ObjectSidePass& _internal_side_pass() const;
  ::control::planning::ObjectSidePass* _internal_mutable_side_pass();
  public:
  void unsafe_arena_set_allocated_side_pass(
      ::control::planning::ObjectSidePass* side_pass);
  ::control::planning::ObjectSidePass* unsafe_arena_release_side_pass();

  void clear_object_tag();
  ObjectTagCase object_tag_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.ObjectDecisionType)
 private:
  class _Internal;
  void set_has_ignore();
  void set_has_stop();
  void set_has_follow();
  void set_has_yield();
  void set_has_overtake();
  void set_has_nudge();
  void set_has_avoid();
  void set_has_side_pass();

  inline bool has_object_tag() const;
  inline void clear_has_object_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ObjectTagUnion {
    ObjectTagUnion() {}
    ::control::planning::ObjectIgnore* ignore_;
    ::control::planning::ObjectStop* stop_;
    ::control::planning::ObjectFollow* follow_;
    ::control::planning::ObjectYield* yield_;
    ::control::planning::ObjectOvertake* overtake_;
    ::control::planning::ObjectNudge* nudge_;
    ::control::planning::ObjectAvoid* avoid_;
    ::control::planning::ObjectSidePass* side_pass_;
  } object_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecision PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectDecision) */ {
 public:
  inline ObjectDecision() : ObjectDecision(nullptr) {};
  virtual ~ObjectDecision();

  ObjectDecision(const ObjectDecision& from);
  ObjectDecision(ObjectDecision&& from) noexcept
    : ObjectDecision() {
    *this = ::std::move(from);
  }

  inline ObjectDecision& operator=(const ObjectDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecision& operator=(ObjectDecision&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDecision* internal_default_instance() {
    return reinterpret_cast<const ObjectDecision*>(
               &_ObjectDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ObjectDecision& a, ObjectDecision& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDecision* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectDecision* New() const final {
    return CreateMaybeMessage<ObjectDecision>(nullptr);
  }

  ObjectDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDecision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectDecision& from);
  void MergeFrom(const ObjectDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectDecision";
  }
  protected:
  explicit ObjectDecision(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectDecisionFieldNumber = 3,
    kIdFieldNumber = 1,
    kPerceptionIdFieldNumber = 2,
  };
  // repeated .control.planning.ObjectDecisionType object_decision = 3;
  int object_decision_size() const;
  private:
  int _internal_object_decision_size() const;
  public:
  void clear_object_decision();
  ::control::planning::ObjectDecisionType* mutable_object_decision(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecisionType >*
      mutable_object_decision();
  private:
  const ::control::planning::ObjectDecisionType& _internal_object_decision(int index) const;
  ::control::planning::ObjectDecisionType* _internal_add_object_decision();
  public:
  const ::control::planning::ObjectDecisionType& object_decision(int index) const;
  ::control::planning::ObjectDecisionType* add_object_decision();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecisionType >&
      object_decision() const;

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional int32 perception_id = 2;
  bool has_perception_id() const;
  private:
  bool _internal_has_perception_id() const;
  public:
  void clear_perception_id();
  ::PROTOBUF_NAMESPACE_ID::int32 perception_id() const;
  void set_perception_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_perception_id() const;
  void _internal_set_perception_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.ObjectDecision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecisionType > object_decision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::int32 perception_id_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.ObjectDecisions) */ {
 public:
  inline ObjectDecisions() : ObjectDecisions(nullptr) {};
  virtual ~ObjectDecisions();

  ObjectDecisions(const ObjectDecisions& from);
  ObjectDecisions(ObjectDecisions&& from) noexcept
    : ObjectDecisions() {
    *this = ::std::move(from);
  }

  inline ObjectDecisions& operator=(const ObjectDecisions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecisions& operator=(ObjectDecisions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectDecisions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDecisions* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisions*>(
               &_ObjectDecisions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ObjectDecisions& a, ObjectDecisions& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDecisions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecisions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectDecisions* New() const final {
    return CreateMaybeMessage<ObjectDecisions>(nullptr);
  }

  ObjectDecisions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDecisions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectDecisions& from);
  void MergeFrom(const ObjectDecisions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecisions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.ObjectDecisions";
  }
  protected:
  explicit ObjectDecisions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecisionFieldNumber = 1,
  };
  // repeated .control.planning.ObjectDecision decision = 1;
  int decision_size() const;
  private:
  int _internal_decision_size() const;
  public:
  void clear_decision();
  ::control::planning::ObjectDecision* mutable_decision(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecision >*
      mutable_decision();
  private:
  const ::control::planning::ObjectDecision& _internal_decision(int index) const;
  ::control::planning::ObjectDecision* _internal_add_decision();
  public:
  const ::control::planning::ObjectDecision& decision(int index) const;
  ::control::planning::ObjectDecision* add_decision();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecision >&
      decision() const;

  // @@protoc_insertion_point(class_scope:control.planning.ObjectDecisions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecision > decision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainStop PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainStop) */ {
 public:
  inline MainStop() : MainStop(nullptr) {};
  virtual ~MainStop();

  MainStop(const MainStop& from);
  MainStop(MainStop&& from) noexcept
    : MainStop() {
    *this = ::std::move(from);
  }

  inline MainStop& operator=(const MainStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainStop& operator=(MainStop&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainStop* internal_default_instance() {
    return reinterpret_cast<const MainStop*>(
               &_MainStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MainStop& a, MainStop& b) {
    a.Swap(&b);
  }
  inline void Swap(MainStop* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainStop* New() const final {
    return CreateMaybeMessage<MainStop>(nullptr);
  }

  MainStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainStop>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainStop& from);
  void MergeFrom(const MainStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainStop";
  }
  protected:
  explicit MainStop(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kStopPointFieldNumber = 3,
    kStopHeadingFieldNumber = 4,
    kReasonCodeFieldNumber = 1,
  };
  // optional string reason = 2;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reason(
      std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .control.common.PointENU stop_point = 3;
  bool has_stop_point() const;
  private:
  bool _internal_has_stop_point() const;
  public:
  void clear_stop_point();
  const ::control::common::PointENU& stop_point() const;
  ::control::common::PointENU* release_stop_point();
  ::control::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::control::common::PointENU* stop_point);
  private:
  const ::control::common::PointENU& _internal_stop_point() const;
  ::control::common::PointENU* _internal_mutable_stop_point();
  public:
  void unsafe_arena_set_allocated_stop_point(
      ::control::common::PointENU* stop_point);
  ::control::common::PointENU* unsafe_arena_release_stop_point();

  // optional double stop_heading = 4;
  bool has_stop_heading() const;
  private:
  bool _internal_has_stop_heading() const;
  public:
  void clear_stop_heading();
  double stop_heading() const;
  void set_stop_heading(double value);
  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);
  public:

  // optional .control.planning.StopReasonCode reason_code = 1;
  bool has_reason_code() const;
  private:
  bool _internal_has_reason_code() const;
  public:
  void clear_reason_code();
  ::control::planning::StopReasonCode reason_code() const;
  void set_reason_code(::control::planning::StopReasonCode value);
  private:
  ::control::planning::StopReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::control::planning::StopReasonCode value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.MainStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::control::common::PointENU* stop_point_;
  double stop_heading_;
  int reason_code_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class EmergencyStopHardBrake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.EmergencyStopHardBrake) */ {
 public:
  inline EmergencyStopHardBrake() : EmergencyStopHardBrake(nullptr) {};
  virtual ~EmergencyStopHardBrake();

  EmergencyStopHardBrake(const EmergencyStopHardBrake& from);
  EmergencyStopHardBrake(EmergencyStopHardBrake&& from) noexcept
    : EmergencyStopHardBrake() {
    *this = ::std::move(from);
  }

  inline EmergencyStopHardBrake& operator=(const EmergencyStopHardBrake& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyStopHardBrake& operator=(EmergencyStopHardBrake&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmergencyStopHardBrake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmergencyStopHardBrake* internal_default_instance() {
    return reinterpret_cast<const EmergencyStopHardBrake*>(
               &_EmergencyStopHardBrake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EmergencyStopHardBrake& a, EmergencyStopHardBrake& b) {
    a.Swap(&b);
  }
  inline void Swap(EmergencyStopHardBrake* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyStopHardBrake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmergencyStopHardBrake* New() const final {
    return CreateMaybeMessage<EmergencyStopHardBrake>(nullptr);
  }

  EmergencyStopHardBrake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmergencyStopHardBrake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmergencyStopHardBrake& from);
  void MergeFrom(const EmergencyStopHardBrake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmergencyStopHardBrake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.EmergencyStopHardBrake";
  }
  protected:
  explicit EmergencyStopHardBrake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.EmergencyStopHardBrake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class EmergencyStopCruiseToStop PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.EmergencyStopCruiseToStop) */ {
 public:
  inline EmergencyStopCruiseToStop() : EmergencyStopCruiseToStop(nullptr) {};
  virtual ~EmergencyStopCruiseToStop();

  EmergencyStopCruiseToStop(const EmergencyStopCruiseToStop& from);
  EmergencyStopCruiseToStop(EmergencyStopCruiseToStop&& from) noexcept
    : EmergencyStopCruiseToStop() {
    *this = ::std::move(from);
  }

  inline EmergencyStopCruiseToStop& operator=(const EmergencyStopCruiseToStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyStopCruiseToStop& operator=(EmergencyStopCruiseToStop&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmergencyStopCruiseToStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmergencyStopCruiseToStop* internal_default_instance() {
    return reinterpret_cast<const EmergencyStopCruiseToStop*>(
               &_EmergencyStopCruiseToStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EmergencyStopCruiseToStop& a, EmergencyStopCruiseToStop& b) {
    a.Swap(&b);
  }
  inline void Swap(EmergencyStopCruiseToStop* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyStopCruiseToStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmergencyStopCruiseToStop* New() const final {
    return CreateMaybeMessage<EmergencyStopCruiseToStop>(nullptr);
  }

  EmergencyStopCruiseToStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmergencyStopCruiseToStop>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmergencyStopCruiseToStop& from);
  void MergeFrom(const EmergencyStopCruiseToStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmergencyStopCruiseToStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.EmergencyStopCruiseToStop";
  }
  protected:
  explicit EmergencyStopCruiseToStop(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.EmergencyStopCruiseToStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainEmergencyStop PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainEmergencyStop) */ {
 public:
  inline MainEmergencyStop() : MainEmergencyStop(nullptr) {};
  virtual ~MainEmergencyStop();

  MainEmergencyStop(const MainEmergencyStop& from);
  MainEmergencyStop(MainEmergencyStop&& from) noexcept
    : MainEmergencyStop() {
    *this = ::std::move(from);
  }

  inline MainEmergencyStop& operator=(const MainEmergencyStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainEmergencyStop& operator=(MainEmergencyStop&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainEmergencyStop& default_instance();

  enum TaskCase {
    kHardBrake = 3,
    kCruiseToStop = 4,
    TASK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainEmergencyStop* internal_default_instance() {
    return reinterpret_cast<const MainEmergencyStop*>(
               &_MainEmergencyStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MainEmergencyStop& a, MainEmergencyStop& b) {
    a.Swap(&b);
  }
  inline void Swap(MainEmergencyStop* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainEmergencyStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainEmergencyStop* New() const final {
    return CreateMaybeMessage<MainEmergencyStop>(nullptr);
  }

  MainEmergencyStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainEmergencyStop>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainEmergencyStop& from);
  void MergeFrom(const MainEmergencyStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainEmergencyStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainEmergencyStop";
  }
  protected:
  explicit MainEmergencyStop(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MainEmergencyStop_ReasonCode ReasonCode;
  static constexpr ReasonCode ESTOP_REASON_INTERNAL_ERR =
    MainEmergencyStop_ReasonCode_ESTOP_REASON_INTERNAL_ERR;
  static constexpr ReasonCode ESTOP_REASON_COLLISION =
    MainEmergencyStop_ReasonCode_ESTOP_REASON_COLLISION;
  static constexpr ReasonCode ESTOP_REASON_ST_FIND_PATH =
    MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_FIND_PATH;
  static constexpr ReasonCode ESTOP_REASON_ST_MAKE_DECISION =
    MainEmergencyStop_ReasonCode_ESTOP_REASON_ST_MAKE_DECISION;
  static constexpr ReasonCode ESTOP_REASON_SENSOR_ERROR =
    MainEmergencyStop_ReasonCode_ESTOP_REASON_SENSOR_ERROR;
  static inline bool ReasonCode_IsValid(int value) {
    return MainEmergencyStop_ReasonCode_IsValid(value);
  }
  static constexpr ReasonCode ReasonCode_MIN =
    MainEmergencyStop_ReasonCode_ReasonCode_MIN;
  static constexpr ReasonCode ReasonCode_MAX =
    MainEmergencyStop_ReasonCode_ReasonCode_MAX;
  static constexpr int ReasonCode_ARRAYSIZE =
    MainEmergencyStop_ReasonCode_ReasonCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReasonCode_descriptor() {
    return MainEmergencyStop_ReasonCode_descriptor();
  }
  template<typename T>
  static inline const std::string& ReasonCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReasonCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReasonCode_Name.");
    return MainEmergencyStop_ReasonCode_Name(enum_t_value);
  }
  static inline bool ReasonCode_Parse(const std::string& name,
      ReasonCode* value) {
    return MainEmergencyStop_ReasonCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kReasonCodeFieldNumber = 1,
    kHardBrakeFieldNumber = 3,
    kCruiseToStopFieldNumber = 4,
  };
  // optional string reason = 2;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reason(
      std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .control.planning.MainEmergencyStop.ReasonCode reason_code = 1;
  bool has_reason_code() const;
  private:
  bool _internal_has_reason_code() const;
  public:
  void clear_reason_code();
  ::control::planning::MainEmergencyStop_ReasonCode reason_code() const;
  void set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value);
  private:
  ::control::planning::MainEmergencyStop_ReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value);
  public:

  // .control.planning.EmergencyStopHardBrake hard_brake = 3;
  bool has_hard_brake() const;
  private:
  bool _internal_has_hard_brake() const;
  public:
  void clear_hard_brake();
  const ::control::planning::EmergencyStopHardBrake& hard_brake() const;
  ::control::planning::EmergencyStopHardBrake* release_hard_brake();
  ::control::planning::EmergencyStopHardBrake* mutable_hard_brake();
  void set_allocated_hard_brake(::control::planning::EmergencyStopHardBrake* hard_brake);
  private:
  const ::control::planning::EmergencyStopHardBrake& _internal_hard_brake() const;
  ::control::planning::EmergencyStopHardBrake* _internal_mutable_hard_brake();
  public:
  void unsafe_arena_set_allocated_hard_brake(
      ::control::planning::EmergencyStopHardBrake* hard_brake);
  ::control::planning::EmergencyStopHardBrake* unsafe_arena_release_hard_brake();

  // .control.planning.EmergencyStopCruiseToStop cruise_to_stop = 4;
  bool has_cruise_to_stop() const;
  private:
  bool _internal_has_cruise_to_stop() const;
  public:
  void clear_cruise_to_stop();
  const ::control::planning::EmergencyStopCruiseToStop& cruise_to_stop() const;
  ::control::planning::EmergencyStopCruiseToStop* release_cruise_to_stop();
  ::control::planning::EmergencyStopCruiseToStop* mutable_cruise_to_stop();
  void set_allocated_cruise_to_stop(::control::planning::EmergencyStopCruiseToStop* cruise_to_stop);
  private:
  const ::control::planning::EmergencyStopCruiseToStop& _internal_cruise_to_stop() const;
  ::control::planning::EmergencyStopCruiseToStop* _internal_mutable_cruise_to_stop();
  public:
  void unsafe_arena_set_allocated_cruise_to_stop(
      ::control::planning::EmergencyStopCruiseToStop* cruise_to_stop);
  ::control::planning::EmergencyStopCruiseToStop* unsafe_arena_release_cruise_to_stop();

  void clear_task();
  TaskCase task_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.MainEmergencyStop)
 private:
  class _Internal;
  void set_has_hard_brake();
  void set_has_cruise_to_stop();

  inline bool has_task() const;
  inline void clear_has_task();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int reason_code_;
  union TaskUnion {
    TaskUnion() {}
    ::control::planning::EmergencyStopHardBrake* hard_brake_;
    ::control::planning::EmergencyStopCruiseToStop* cruise_to_stop_;
  } task_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainCruise PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainCruise) */ {
 public:
  inline MainCruise() : MainCruise(nullptr) {};
  virtual ~MainCruise();

  MainCruise(const MainCruise& from);
  MainCruise(MainCruise&& from) noexcept
    : MainCruise() {
    *this = ::std::move(from);
  }

  inline MainCruise& operator=(const MainCruise& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainCruise& operator=(MainCruise&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainCruise& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainCruise* internal_default_instance() {
    return reinterpret_cast<const MainCruise*>(
               &_MainCruise_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MainCruise& a, MainCruise& b) {
    a.Swap(&b);
  }
  inline void Swap(MainCruise* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainCruise* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainCruise* New() const final {
    return CreateMaybeMessage<MainCruise>(nullptr);
  }

  MainCruise* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainCruise>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainCruise& from);
  void MergeFrom(const MainCruise& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainCruise* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainCruise";
  }
  protected:
  explicit MainCruise(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:control.planning.MainCruise)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainChangeLane PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainChangeLane) */ {
 public:
  inline MainChangeLane() : MainChangeLane(nullptr) {};
  virtual ~MainChangeLane();

  MainChangeLane(const MainChangeLane& from);
  MainChangeLane(MainChangeLane&& from) noexcept
    : MainChangeLane() {
    *this = ::std::move(from);
  }

  inline MainChangeLane& operator=(const MainChangeLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainChangeLane& operator=(MainChangeLane&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainChangeLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainChangeLane* internal_default_instance() {
    return reinterpret_cast<const MainChangeLane*>(
               &_MainChangeLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MainChangeLane& a, MainChangeLane& b) {
    a.Swap(&b);
  }
  inline void Swap(MainChangeLane* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainChangeLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainChangeLane* New() const final {
    return CreateMaybeMessage<MainChangeLane>(nullptr);
  }

  MainChangeLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainChangeLane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainChangeLane& from);
  void MergeFrom(const MainChangeLane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainChangeLane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainChangeLane";
  }
  protected:
  explicit MainChangeLane(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MainChangeLane_Type Type;
  static constexpr Type LEFT =
    MainChangeLane_Type_LEFT;
  static constexpr Type RIGHT =
    MainChangeLane_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return MainChangeLane_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    MainChangeLane_Type_Type_MIN;
  static constexpr Type Type_MAX =
    MainChangeLane_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    MainChangeLane_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return MainChangeLane_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return MainChangeLane_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return MainChangeLane_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultLaneFieldNumber = 2,
    kDefaultLaneStopFieldNumber = 3,
    kTargetLaneStopFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .control.planning.TargetLane default_lane = 2;
  int default_lane_size() const;
  private:
  int _internal_default_lane_size() const;
  public:
  void clear_default_lane();
  ::control::planning::TargetLane* mutable_default_lane(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >*
      mutable_default_lane();
  private:
  const ::control::planning::TargetLane& _internal_default_lane(int index) const;
  ::control::planning::TargetLane* _internal_add_default_lane();
  public:
  const ::control::planning::TargetLane& default_lane(int index) const;
  ::control::planning::TargetLane* add_default_lane();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >&
      default_lane() const;

  // optional .control.planning.MainStop default_lane_stop = 3;
  bool has_default_lane_stop() const;
  private:
  bool _internal_has_default_lane_stop() const;
  public:
  void clear_default_lane_stop();
  const ::control::planning::MainStop& default_lane_stop() const;
  ::control::planning::MainStop* release_default_lane_stop();
  ::control::planning::MainStop* mutable_default_lane_stop();
  void set_allocated_default_lane_stop(::control::planning::MainStop* default_lane_stop);
  private:
  const ::control::planning::MainStop& _internal_default_lane_stop() const;
  ::control::planning::MainStop* _internal_mutable_default_lane_stop();
  public:
  void unsafe_arena_set_allocated_default_lane_stop(
      ::control::planning::MainStop* default_lane_stop);
  ::control::planning::MainStop* unsafe_arena_release_default_lane_stop();

  // optional .control.planning.MainStop target_lane_stop = 4;
  bool has_target_lane_stop() const;
  private:
  bool _internal_has_target_lane_stop() const;
  public:
  void clear_target_lane_stop();
  const ::control::planning::MainStop& target_lane_stop() const;
  ::control::planning::MainStop* release_target_lane_stop();
  ::control::planning::MainStop* mutable_target_lane_stop();
  void set_allocated_target_lane_stop(::control::planning::MainStop* target_lane_stop);
  private:
  const ::control::planning::MainStop& _internal_target_lane_stop() const;
  ::control::planning::MainStop* _internal_mutable_target_lane_stop();
  public:
  void unsafe_arena_set_allocated_target_lane_stop(
      ::control::planning::MainStop* target_lane_stop);
  ::control::planning::MainStop* unsafe_arena_release_target_lane_stop();

  // optional .control.planning.MainChangeLane.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::control::planning::MainChangeLane_Type type() const;
  void set_type(::control::planning::MainChangeLane_Type value);
  private:
  ::control::planning::MainChangeLane_Type _internal_type() const;
  void _internal_set_type(::control::planning::MainChangeLane_Type value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.MainChangeLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane > default_lane_;
  ::control::planning::MainStop* default_lane_stop_;
  ::control::planning::MainStop* target_lane_stop_;
  int type_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainMissionComplete PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainMissionComplete) */ {
 public:
  inline MainMissionComplete() : MainMissionComplete(nullptr) {};
  virtual ~MainMissionComplete();

  MainMissionComplete(const MainMissionComplete& from);
  MainMissionComplete(MainMissionComplete&& from) noexcept
    : MainMissionComplete() {
    *this = ::std::move(from);
  }

  inline MainMissionComplete& operator=(const MainMissionComplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainMissionComplete& operator=(MainMissionComplete&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainMissionComplete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainMissionComplete* internal_default_instance() {
    return reinterpret_cast<const MainMissionComplete*>(
               &_MainMissionComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MainMissionComplete& a, MainMissionComplete& b) {
    a.Swap(&b);
  }
  inline void Swap(MainMissionComplete* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainMissionComplete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainMissionComplete* New() const final {
    return CreateMaybeMessage<MainMissionComplete>(nullptr);
  }

  MainMissionComplete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainMissionComplete>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainMissionComplete& from);
  void MergeFrom(const MainMissionComplete& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainMissionComplete* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainMissionComplete";
  }
  protected:
  explicit MainMissionComplete(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopPointFieldNumber = 1,
    kStopHeadingFieldNumber = 2,
  };
  // optional .control.common.PointENU stop_point = 1;
  bool has_stop_point() const;
  private:
  bool _internal_has_stop_point() const;
  public:
  void clear_stop_point();
  const ::control::common::PointENU& stop_point() const;
  ::control::common::PointENU* release_stop_point();
  ::control::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::control::common::PointENU* stop_point);
  private:
  const ::control::common::PointENU& _internal_stop_point() const;
  ::control::common::PointENU* _internal_mutable_stop_point();
  public:
  void unsafe_arena_set_allocated_stop_point(
      ::control::common::PointENU* stop_point);
  ::control::common::PointENU* unsafe_arena_release_stop_point();

  // optional double stop_heading = 2;
  bool has_stop_heading() const;
  private:
  bool _internal_has_stop_heading() const;
  public:
  void clear_stop_heading();
  double stop_heading() const;
  void set_stop_heading(double value);
  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.MainMissionComplete)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::control::common::PointENU* stop_point_;
  double stop_heading_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainNotReady PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainNotReady) */ {
 public:
  inline MainNotReady() : MainNotReady(nullptr) {};
  virtual ~MainNotReady();

  MainNotReady(const MainNotReady& from);
  MainNotReady(MainNotReady&& from) noexcept
    : MainNotReady() {
    *this = ::std::move(from);
  }

  inline MainNotReady& operator=(const MainNotReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainNotReady& operator=(MainNotReady&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainNotReady& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainNotReady* internal_default_instance() {
    return reinterpret_cast<const MainNotReady*>(
               &_MainNotReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MainNotReady& a, MainNotReady& b) {
    a.Swap(&b);
  }
  inline void Swap(MainNotReady* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainNotReady* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainNotReady* New() const final {
    return CreateMaybeMessage<MainNotReady>(nullptr);
  }

  MainNotReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainNotReady>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainNotReady& from);
  void MergeFrom(const MainNotReady& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainNotReady* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainNotReady";
  }
  protected:
  explicit MainNotReady(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // optional string reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reason(
      std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:control.planning.MainNotReady)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainParking PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainParking) */ {
 public:
  inline MainParking() : MainParking(nullptr) {};
  virtual ~MainParking();

  MainParking(const MainParking& from);
  MainParking(MainParking&& from) noexcept
    : MainParking() {
    *this = ::std::move(from);
  }

  inline MainParking& operator=(const MainParking& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainParking& operator=(MainParking&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainParking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainParking* internal_default_instance() {
    return reinterpret_cast<const MainParking*>(
               &_MainParking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MainParking& a, MainParking& b) {
    a.Swap(&b);
  }
  inline void Swap(MainParking* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainParking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainParking* New() const final {
    return CreateMaybeMessage<MainParking>(nullptr);
  }

  MainParking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainParking>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainParking& from);
  void MergeFrom(const MainParking& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainParking* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainParking";
  }
  protected:
  explicit MainParking(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MainParking_ParkingStatus ParkingStatus;
  static constexpr ParkingStatus IN_PARKING =
    MainParking_ParkingStatus_IN_PARKING;
  static inline bool ParkingStatus_IsValid(int value) {
    return MainParking_ParkingStatus_IsValid(value);
  }
  static constexpr ParkingStatus ParkingStatus_MIN =
    MainParking_ParkingStatus_ParkingStatus_MIN;
  static constexpr ParkingStatus ParkingStatus_MAX =
    MainParking_ParkingStatus_ParkingStatus_MAX;
  static constexpr int ParkingStatus_ARRAYSIZE =
    MainParking_ParkingStatus_ParkingStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ParkingStatus_descriptor() {
    return MainParking_ParkingStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ParkingStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ParkingStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ParkingStatus_Name.");
    return MainParking_ParkingStatus_Name(enum_t_value);
  }
  static inline bool ParkingStatus_Parse(const std::string& name,
      ParkingStatus* value) {
    return MainParking_ParkingStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .control.planning.MainParking.ParkingStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::control::planning::MainParking_ParkingStatus status() const;
  void set_status(::control::planning::MainParking_ParkingStatus value);
  private:
  ::control::planning::MainParking_ParkingStatus _internal_status() const;
  void _internal_set_status(::control::planning::MainParking_ParkingStatus value);
  public:

  // @@protoc_insertion_point(class_scope:control.planning.MainParking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class MainDecision PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.MainDecision) */ {
 public:
  inline MainDecision() : MainDecision(nullptr) {};
  virtual ~MainDecision();

  MainDecision(const MainDecision& from);
  MainDecision(MainDecision&& from) noexcept
    : MainDecision() {
    *this = ::std::move(from);
  }

  inline MainDecision& operator=(const MainDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainDecision& operator=(MainDecision&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainDecision& default_instance();

  enum TaskCase {
    kCruise = 1,
    kStop = 2,
    kEstop = 3,
    kChangeLane = 4,
    kMissionComplete = 6,
    kNotReady = 7,
    kParking = 8,
    TASK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainDecision* internal_default_instance() {
    return reinterpret_cast<const MainDecision*>(
               &_MainDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MainDecision& a, MainDecision& b) {
    a.Swap(&b);
  }
  inline void Swap(MainDecision* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainDecision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainDecision* New() const final {
    return CreateMaybeMessage<MainDecision>(nullptr);
  }

  MainDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainDecision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainDecision& from);
  void MergeFrom(const MainDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainDecision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.MainDecision";
  }
  protected:
  explicit MainDecision(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetLaneFieldNumber = 5,
    kCruiseFieldNumber = 1,
    kStopFieldNumber = 2,
    kEstopFieldNumber = 3,
    kChangeLaneFieldNumber = 4,
    kMissionCompleteFieldNumber = 6,
    kNotReadyFieldNumber = 7,
    kParkingFieldNumber = 8,
  };
  // repeated .control.planning.TargetLane target_lane = 5 [deprecated = true];
  PROTOBUF_DEPRECATED int target_lane_size() const;
  private:
  int _internal_target_lane_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_target_lane();
  PROTOBUF_DEPRECATED ::control::planning::TargetLane* mutable_target_lane(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >*
      mutable_target_lane();
  private:
  const ::control::planning::TargetLane& _internal_target_lane(int index) const;
  ::control::planning::TargetLane* _internal_add_target_lane();
  public:
  PROTOBUF_DEPRECATED const ::control::planning::TargetLane& target_lane(int index) const;
  PROTOBUF_DEPRECATED ::control::planning::TargetLane* add_target_lane();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >&
      target_lane() const;

  // .control.planning.MainCruise cruise = 1;
  bool has_cruise() const;
  private:
  bool _internal_has_cruise() const;
  public:
  void clear_cruise();
  const ::control::planning::MainCruise& cruise() const;
  ::control::planning::MainCruise* release_cruise();
  ::control::planning::MainCruise* mutable_cruise();
  void set_allocated_cruise(::control::planning::MainCruise* cruise);
  private:
  const ::control::planning::MainCruise& _internal_cruise() const;
  ::control::planning::MainCruise* _internal_mutable_cruise();
  public:
  void unsafe_arena_set_allocated_cruise(
      ::control::planning::MainCruise* cruise);
  ::control::planning::MainCruise* unsafe_arena_release_cruise();

  // .control.planning.MainStop stop = 2;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::control::planning::MainStop& stop() const;
  ::control::planning::MainStop* release_stop();
  ::control::planning::MainStop* mutable_stop();
  void set_allocated_stop(::control::planning::MainStop* stop);
  private:
  const ::control::planning::MainStop& _internal_stop() const;
  ::control::planning::MainStop* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::control::planning::MainStop* stop);
  ::control::planning::MainStop* unsafe_arena_release_stop();

  // .control.planning.MainEmergencyStop estop = 3;
  bool has_estop() const;
  private:
  bool _internal_has_estop() const;
  public:
  void clear_estop();
  const ::control::planning::MainEmergencyStop& estop() const;
  ::control::planning::MainEmergencyStop* release_estop();
  ::control::planning::MainEmergencyStop* mutable_estop();
  void set_allocated_estop(::control::planning::MainEmergencyStop* estop);
  private:
  const ::control::planning::MainEmergencyStop& _internal_estop() const;
  ::control::planning::MainEmergencyStop* _internal_mutable_estop();
  public:
  void unsafe_arena_set_allocated_estop(
      ::control::planning::MainEmergencyStop* estop);
  ::control::planning::MainEmergencyStop* unsafe_arena_release_estop();

  // .control.planning.MainChangeLane change_lane = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;
  public:
  PROTOBUF_DEPRECATED void clear_change_lane();
  PROTOBUF_DEPRECATED const ::control::planning::MainChangeLane& change_lane() const;
  PROTOBUF_DEPRECATED ::control::planning::MainChangeLane* release_change_lane();
  PROTOBUF_DEPRECATED ::control::planning::MainChangeLane* mutable_change_lane();
  PROTOBUF_DEPRECATED void set_allocated_change_lane(::control::planning::MainChangeLane* change_lane);
  private:
  const ::control::planning::MainChangeLane& _internal_change_lane() const;
  ::control::planning::MainChangeLane* _internal_mutable_change_lane();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_change_lane(
      ::control::planning::MainChangeLane* change_lane);
  PROTOBUF_DEPRECATED ::control::planning::MainChangeLane* unsafe_arena_release_change_lane();

  // .control.planning.MainMissionComplete mission_complete = 6;
  bool has_mission_complete() const;
  private:
  bool _internal_has_mission_complete() const;
  public:
  void clear_mission_complete();
  const ::control::planning::MainMissionComplete& mission_complete() const;
  ::control::planning::MainMissionComplete* release_mission_complete();
  ::control::planning::MainMissionComplete* mutable_mission_complete();
  void set_allocated_mission_complete(::control::planning::MainMissionComplete* mission_complete);
  private:
  const ::control::planning::MainMissionComplete& _internal_mission_complete() const;
  ::control::planning::MainMissionComplete* _internal_mutable_mission_complete();
  public:
  void unsafe_arena_set_allocated_mission_complete(
      ::control::planning::MainMissionComplete* mission_complete);
  ::control::planning::MainMissionComplete* unsafe_arena_release_mission_complete();

  // .control.planning.MainNotReady not_ready = 7;
  bool has_not_ready() const;
  private:
  bool _internal_has_not_ready() const;
  public:
  void clear_not_ready();
  const ::control::planning::MainNotReady& not_ready() const;
  ::control::planning::MainNotReady* release_not_ready();
  ::control::planning::MainNotReady* mutable_not_ready();
  void set_allocated_not_ready(::control::planning::MainNotReady* not_ready);
  private:
  const ::control::planning::MainNotReady& _internal_not_ready() const;
  ::control::planning::MainNotReady* _internal_mutable_not_ready();
  public:
  void unsafe_arena_set_allocated_not_ready(
      ::control::planning::MainNotReady* not_ready);
  ::control::planning::MainNotReady* unsafe_arena_release_not_ready();

  // .control.planning.MainParking parking = 8;
  bool has_parking() const;
  private:
  bool _internal_has_parking() const;
  public:
  void clear_parking();
  const ::control::planning::MainParking& parking() const;
  ::control::planning::MainParking* release_parking();
  ::control::planning::MainParking* mutable_parking();
  void set_allocated_parking(::control::planning::MainParking* parking);
  private:
  const ::control::planning::MainParking& _internal_parking() const;
  ::control::planning::MainParking* _internal_mutable_parking();
  public:
  void unsafe_arena_set_allocated_parking(
      ::control::planning::MainParking* parking);
  ::control::planning::MainParking* unsafe_arena_release_parking();

  void clear_task();
  TaskCase task_case() const;
  // @@protoc_insertion_point(class_scope:control.planning.MainDecision)
 private:
  class _Internal;
  void set_has_cruise();
  void set_has_stop();
  void set_has_estop();
  void set_has_change_lane();
  void set_has_mission_complete();
  void set_has_not_ready();
  void set_has_parking();

  inline bool has_task() const;
  inline void clear_has_task();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane > target_lane_;
  union TaskUnion {
    TaskUnion() {}
    ::control::planning::MainCruise* cruise_;
    ::control::planning::MainStop* stop_;
    ::control::planning::MainEmergencyStop* estop_;
    ::control::planning::MainChangeLane* change_lane_;
    ::control::planning::MainMissionComplete* mission_complete_;
    ::control::planning::MainNotReady* not_ready_;
    ::control::planning::MainParking* parking_;
  } task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class DecisionResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:control.planning.DecisionResult) */ {
 public:
  inline DecisionResult() : DecisionResult(nullptr) {};
  virtual ~DecisionResult();

  DecisionResult(const DecisionResult& from);
  DecisionResult(DecisionResult&& from) noexcept
    : DecisionResult() {
    *this = ::std::move(from);
  }

  inline DecisionResult& operator=(const DecisionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionResult& operator=(DecisionResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DecisionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionResult* internal_default_instance() {
    return reinterpret_cast<const DecisionResult*>(
               &_DecisionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DecisionResult& a, DecisionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DecisionResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecisionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecisionResult* New() const final {
    return CreateMaybeMessage<DecisionResult>(nullptr);
  }

  DecisionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecisionResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DecisionResult& from);
  void MergeFrom(const DecisionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "control.planning.DecisionResult";
  }
  protected:
  explicit DecisionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_planning_5fmsgs_2fdecision_2eproto);
    return ::descriptor_table_planning_5fmsgs_2fdecision_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMainDecisionFieldNumber = 1,
    kObjectDecisionFieldNumber = 2,
    kVehicleSignalFieldNumber = 3,
  };
  // optional .control.planning.MainDecision main_decision = 1;
  bool has_main_decision() const;
  private:
  bool _internal_has_main_decision() const;
  public:
  void clear_main_decision();
  const ::control::planning::MainDecision& main_decision() const;
  ::control::planning::MainDecision* release_main_decision();
  ::control::planning::MainDecision* mutable_main_decision();
  void set_allocated_main_decision(::control::planning::MainDecision* main_decision);
  private:
  const ::control::planning::MainDecision& _internal_main_decision() const;
  ::control::planning::MainDecision* _internal_mutable_main_decision();
  public:
  void unsafe_arena_set_allocated_main_decision(
      ::control::planning::MainDecision* main_decision);
  ::control::planning::MainDecision* unsafe_arena_release_main_decision();

  // optional .control.planning.ObjectDecisions object_decision = 2;
  bool has_object_decision() const;
  private:
  bool _internal_has_object_decision() const;
  public:
  void clear_object_decision();
  const ::control::planning::ObjectDecisions& object_decision() const;
  ::control::planning::ObjectDecisions* release_object_decision();
  ::control::planning::ObjectDecisions* mutable_object_decision();
  void set_allocated_object_decision(::control::planning::ObjectDecisions* object_decision);
  private:
  const ::control::planning::ObjectDecisions& _internal_object_decision() const;
  ::control::planning::ObjectDecisions* _internal_mutable_object_decision();
  public:
  void unsafe_arena_set_allocated_object_decision(
      ::control::planning::ObjectDecisions* object_decision);
  ::control::planning::ObjectDecisions* unsafe_arena_release_object_decision();

  // optional .control.common.VehicleSignal vehicle_signal = 3;
  bool has_vehicle_signal() const;
  private:
  bool _internal_has_vehicle_signal() const;
  public:
  void clear_vehicle_signal();
  const ::control::common::VehicleSignal& vehicle_signal() const;
  ::control::common::VehicleSignal* release_vehicle_signal();
  ::control::common::VehicleSignal* mutable_vehicle_signal();
  void set_allocated_vehicle_signal(::control::common::VehicleSignal* vehicle_signal);
  private:
  const ::control::common::VehicleSignal& _internal_vehicle_signal() const;
  ::control::common::VehicleSignal* _internal_mutable_vehicle_signal();
  public:
  void unsafe_arena_set_allocated_vehicle_signal(
      ::control::common::VehicleSignal* vehicle_signal);
  ::control::common::VehicleSignal* unsafe_arena_release_vehicle_signal();

  // @@protoc_insertion_point(class_scope:control.planning.DecisionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::control::planning::MainDecision* main_decision_;
  ::control::planning::ObjectDecisions* object_decision_;
  ::control::common::VehicleSignal* vehicle_signal_;
  friend struct ::TableStruct_planning_5fmsgs_2fdecision_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TargetLane

// optional string id = 1;
inline bool TargetLane::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TargetLane::has_id() const {
  return _internal_has_id();
}
inline void TargetLane::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TargetLane::id() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.id)
  return _internal_id();
}
inline void TargetLane::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.id)
}
inline std::string* TargetLane::mutable_id() {
  // @@protoc_insertion_point(field_mutable:control.planning.TargetLane.id)
  return _internal_mutable_id();
}
inline const std::string& TargetLane::_internal_id() const {
  return id_.Get();
}
inline void TargetLane::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TargetLane::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:control.planning.TargetLane.id)
}
inline void TargetLane::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:control.planning.TargetLane.id)
}
inline void TargetLane::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:control.planning.TargetLane.id)
}
inline std::string* TargetLane::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TargetLane::release_id() {
  // @@protoc_insertion_point(field_release:control.planning.TargetLane.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TargetLane::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:control.planning.TargetLane.id)
}
inline std::string* TargetLane::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.TargetLane.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TargetLane::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.TargetLane.id)
}

// optional double start_s = 2;
inline bool TargetLane::_internal_has_start_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TargetLane::has_start_s() const {
  return _internal_has_start_s();
}
inline void TargetLane::clear_start_s() {
  start_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TargetLane::_internal_start_s() const {
  return start_s_;
}
inline double TargetLane::start_s() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.start_s)
  return _internal_start_s();
}
inline void TargetLane::_internal_set_start_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_s_ = value;
}
inline void TargetLane::set_start_s(double value) {
  _internal_set_start_s(value);
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.start_s)
}

// optional double end_s = 3;
inline bool TargetLane::_internal_has_end_s() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TargetLane::has_end_s() const {
  return _internal_has_end_s();
}
inline void TargetLane::clear_end_s() {
  end_s_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double TargetLane::_internal_end_s() const {
  return end_s_;
}
inline double TargetLane::end_s() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.end_s)
  return _internal_end_s();
}
inline void TargetLane::_internal_set_end_s(double value) {
  _has_bits_[0] |= 0x00000004u;
  end_s_ = value;
}
inline void TargetLane::set_end_s(double value) {
  _internal_set_end_s(value);
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.end_s)
}

// optional double speed_limit = 4;
inline bool TargetLane::_internal_has_speed_limit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TargetLane::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void TargetLane::clear_speed_limit() {
  speed_limit_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double TargetLane::_internal_speed_limit() const {
  return speed_limit_;
}
inline double TargetLane::speed_limit() const {
  // @@protoc_insertion_point(field_get:control.planning.TargetLane.speed_limit)
  return _internal_speed_limit();
}
inline void TargetLane::_internal_set_speed_limit(double value) {
  _has_bits_[0] |= 0x00000008u;
  speed_limit_ = value;
}
inline void TargetLane::set_speed_limit(double value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:control.planning.TargetLane.speed_limit)
}

// -------------------------------------------------------------------

// ObjectIgnore

// -------------------------------------------------------------------

// ObjectStop

// optional .control.planning.StopReasonCode reason_code = 1;
inline bool ObjectStop::_internal_has_reason_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObjectStop::has_reason_code() const {
  return _internal_has_reason_code();
}
inline void ObjectStop::clear_reason_code() {
  reason_code_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::control::planning::StopReasonCode ObjectStop::_internal_reason_code() const {
  return static_cast< ::control::planning::StopReasonCode >(reason_code_);
}
inline ::control::planning::StopReasonCode ObjectStop::reason_code() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.reason_code)
  return _internal_reason_code();
}
inline void ObjectStop::_internal_set_reason_code(::control::planning::StopReasonCode value) {
  assert(::control::planning::StopReasonCode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  reason_code_ = value;
}
inline void ObjectStop::set_reason_code(::control::planning::StopReasonCode value) {
  _internal_set_reason_code(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.reason_code)
}

// optional double distance_s = 2;
inline bool ObjectStop::_internal_has_distance_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectStop::has_distance_s() const {
  return _internal_has_distance_s();
}
inline void ObjectStop::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectStop::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectStop::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.distance_s)
  return _internal_distance_s();
}
inline void ObjectStop::_internal_set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
}
inline void ObjectStop::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.distance_s)
}

// optional .control.common.PointENU stop_point = 3;
inline bool ObjectStop::_internal_has_stop_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || stop_point_ != nullptr);
  return value;
}
inline bool ObjectStop::has_stop_point() const {
  return _internal_has_stop_point();
}
inline const ::control::common::PointENU& ObjectStop::_internal_stop_point() const {
  const ::control::common::PointENU* p = stop_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::PointENU*>(
      &::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectStop::stop_point() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.stop_point)
  return _internal_stop_point();
}
inline void ObjectStop::unsafe_arena_set_allocated_stop_point(
    ::control::common::PointENU* stop_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  stop_point_ = stop_point;
  if (stop_point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectStop.stop_point)
}
inline ::control::common::PointENU* ObjectStop::release_stop_point() {
  auto temp = unsafe_arena_release_stop_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::PointENU* ObjectStop::unsafe_arena_release_stop_point() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectStop.stop_point)
  _has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = stop_point_;
  stop_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectStop::_internal_mutable_stop_point() {
  _has_bits_[0] |= 0x00000001u;
  if (stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::PointENU>(GetArena());
    stop_point_ = p;
  }
  return stop_point_;
}
inline ::control::common::PointENU* ObjectStop::mutable_stop_point() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStop.stop_point)
  return _internal_mutable_stop_point();
}
inline void ObjectStop::set_allocated_stop_point(::control::common::PointENU* stop_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  if (stop_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point)->GetArena();
    if (message_arena != submessage_arena) {
      stop_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectStop.stop_point)
}

// optional double stop_heading = 4;
inline bool ObjectStop::_internal_has_stop_heading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectStop::has_stop_heading() const {
  return _internal_has_stop_heading();
}
inline void ObjectStop::clear_stop_heading() {
  stop_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectStop::_internal_stop_heading() const {
  return stop_heading_;
}
inline double ObjectStop::stop_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.stop_heading)
  return _internal_stop_heading();
}
inline void ObjectStop::_internal_set_stop_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  stop_heading_ = value;
}
inline void ObjectStop::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.stop_heading)
}

// repeated string wait_for_obstacle = 5;
inline int ObjectStop::_internal_wait_for_obstacle_size() const {
  return wait_for_obstacle_.size();
}
inline int ObjectStop::wait_for_obstacle_size() const {
  return _internal_wait_for_obstacle_size();
}
inline void ObjectStop::clear_wait_for_obstacle() {
  wait_for_obstacle_.Clear();
}
inline std::string* ObjectStop::add_wait_for_obstacle() {
  // @@protoc_insertion_point(field_add_mutable:control.planning.ObjectStop.wait_for_obstacle)
  return _internal_add_wait_for_obstacle();
}
inline const std::string& ObjectStop::_internal_wait_for_obstacle(int index) const {
  return wait_for_obstacle_.Get(index);
}
inline const std::string& ObjectStop::wait_for_obstacle(int index) const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStop.wait_for_obstacle)
  return _internal_wait_for_obstacle(index);
}
inline std::string* ObjectStop::mutable_wait_for_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_.Mutable(index);
}
inline void ObjectStop::set_wait_for_obstacle(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.wait_for_obstacle)
  wait_for_obstacle_.Mutable(index)->assign(value);
}
inline void ObjectStop::set_wait_for_obstacle(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:control.planning.ObjectStop.wait_for_obstacle)
  wait_for_obstacle_.Mutable(index)->assign(std::move(value));
}
inline void ObjectStop::set_wait_for_obstacle(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:control.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::set_wait_for_obstacle(int index, const char* value, size_t size) {
  wait_for_obstacle_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:control.planning.ObjectStop.wait_for_obstacle)
}
inline std::string* ObjectStop::_internal_add_wait_for_obstacle() {
  return wait_for_obstacle_.Add();
}
inline void ObjectStop::add_wait_for_obstacle(const std::string& value) {
  wait_for_obstacle_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:control.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(std::string&& value) {
  wait_for_obstacle_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:control.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:control.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(const char* value, size_t size) {
  wait_for_obstacle_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:control.planning.ObjectStop.wait_for_obstacle)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectStop::wait_for_obstacle() const {
  // @@protoc_insertion_point(field_list:control.planning.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectStop::mutable_wait_for_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:control.planning.ObjectStop.wait_for_obstacle)
  return &wait_for_obstacle_;
}

// -------------------------------------------------------------------

// ObjectNudge

// optional .control.planning.ObjectNudge.Type type = 1;
inline bool ObjectNudge::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectNudge::has_type() const {
  return _internal_has_type();
}
inline void ObjectNudge::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::control::planning::ObjectNudge_Type ObjectNudge::_internal_type() const {
  return static_cast< ::control::planning::ObjectNudge_Type >(type_);
}
inline ::control::planning::ObjectNudge_Type ObjectNudge::type() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectNudge.type)
  return _internal_type();
}
inline void ObjectNudge::_internal_set_type(::control::planning::ObjectNudge_Type value) {
  assert(::control::planning::ObjectNudge_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ObjectNudge::set_type(::control::planning::ObjectNudge_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectNudge.type)
}

// optional double distance_l = 2;
inline bool ObjectNudge::_internal_has_distance_l() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectNudge::has_distance_l() const {
  return _internal_has_distance_l();
}
inline void ObjectNudge::clear_distance_l() {
  distance_l_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ObjectNudge::_internal_distance_l() const {
  return distance_l_;
}
inline double ObjectNudge::distance_l() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectNudge.distance_l)
  return _internal_distance_l();
}
inline void ObjectNudge::_internal_set_distance_l(double value) {
  _has_bits_[0] |= 0x00000001u;
  distance_l_ = value;
}
inline void ObjectNudge::set_distance_l(double value) {
  _internal_set_distance_l(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectNudge.distance_l)
}

// -------------------------------------------------------------------

// ObjectYield

// optional double distance_s = 1;
inline bool ObjectYield::_internal_has_distance_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectYield::has_distance_s() const {
  return _internal_has_distance_s();
}
inline void ObjectYield::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectYield::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectYield::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.distance_s)
  return _internal_distance_s();
}
inline void ObjectYield::_internal_set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
}
inline void ObjectYield::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectYield.distance_s)
}

// optional .control.common.PointENU fence_point = 2;
inline bool ObjectYield::_internal_has_fence_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || fence_point_ != nullptr);
  return value;
}
inline bool ObjectYield::has_fence_point() const {
  return _internal_has_fence_point();
}
inline const ::control::common::PointENU& ObjectYield::_internal_fence_point() const {
  const ::control::common::PointENU* p = fence_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::PointENU*>(
      &::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectYield::fence_point() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.fence_point)
  return _internal_fence_point();
}
inline void ObjectYield::unsafe_arena_set_allocated_fence_point(
    ::control::common::PointENU* fence_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  fence_point_ = fence_point;
  if (fence_point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectYield.fence_point)
}
inline ::control::common::PointENU* ObjectYield::release_fence_point() {
  auto temp = unsafe_arena_release_fence_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::PointENU* ObjectYield::unsafe_arena_release_fence_point() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectYield.fence_point)
  _has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectYield::_internal_mutable_fence_point() {
  _has_bits_[0] |= 0x00000001u;
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::PointENU>(GetArena());
    fence_point_ = p;
  }
  return fence_point_;
}
inline ::control::common::PointENU* ObjectYield::mutable_fence_point() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectYield.fence_point)
  return _internal_mutable_fence_point();
}
inline void ObjectYield::set_allocated_fence_point(::control::common::PointENU* fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point)->GetArena();
    if (message_arena != submessage_arena) {
      fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectYield.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectYield::_internal_has_fence_heading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectYield::has_fence_heading() const {
  return _internal_has_fence_heading();
}
inline void ObjectYield::clear_fence_heading() {
  fence_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectYield::_internal_fence_heading() const {
  return fence_heading_;
}
inline double ObjectYield::fence_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectYield::_internal_set_fence_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  fence_heading_ = value;
}
inline void ObjectYield::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectYield.fence_heading)
}

// optional double time_buffer = 4;
inline bool ObjectYield::_internal_has_time_buffer() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObjectYield::has_time_buffer() const {
  return _internal_has_time_buffer();
}
inline void ObjectYield::clear_time_buffer() {
  time_buffer_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ObjectYield::_internal_time_buffer() const {
  return time_buffer_;
}
inline double ObjectYield::time_buffer() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectYield.time_buffer)
  return _internal_time_buffer();
}
inline void ObjectYield::_internal_set_time_buffer(double value) {
  _has_bits_[0] |= 0x00000008u;
  time_buffer_ = value;
}
inline void ObjectYield::set_time_buffer(double value) {
  _internal_set_time_buffer(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectYield.time_buffer)
}

// -------------------------------------------------------------------

// ObjectFollow

// optional double distance_s = 1;
inline bool ObjectFollow::_internal_has_distance_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectFollow::has_distance_s() const {
  return _internal_has_distance_s();
}
inline void ObjectFollow::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectFollow::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectFollow::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectFollow.distance_s)
  return _internal_distance_s();
}
inline void ObjectFollow::_internal_set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
}
inline void ObjectFollow::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectFollow.distance_s)
}

// optional .control.common.PointENU fence_point = 2;
inline bool ObjectFollow::_internal_has_fence_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || fence_point_ != nullptr);
  return value;
}
inline bool ObjectFollow::has_fence_point() const {
  return _internal_has_fence_point();
}
inline const ::control::common::PointENU& ObjectFollow::_internal_fence_point() const {
  const ::control::common::PointENU* p = fence_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::PointENU*>(
      &::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectFollow::fence_point() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectFollow.fence_point)
  return _internal_fence_point();
}
inline void ObjectFollow::unsafe_arena_set_allocated_fence_point(
    ::control::common::PointENU* fence_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  fence_point_ = fence_point;
  if (fence_point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectFollow.fence_point)
}
inline ::control::common::PointENU* ObjectFollow::release_fence_point() {
  auto temp = unsafe_arena_release_fence_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::PointENU* ObjectFollow::unsafe_arena_release_fence_point() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectFollow.fence_point)
  _has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectFollow::_internal_mutable_fence_point() {
  _has_bits_[0] |= 0x00000001u;
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::PointENU>(GetArena());
    fence_point_ = p;
  }
  return fence_point_;
}
inline ::control::common::PointENU* ObjectFollow::mutable_fence_point() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectFollow.fence_point)
  return _internal_mutable_fence_point();
}
inline void ObjectFollow::set_allocated_fence_point(::control::common::PointENU* fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point)->GetArena();
    if (message_arena != submessage_arena) {
      fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectFollow.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectFollow::_internal_has_fence_heading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectFollow::has_fence_heading() const {
  return _internal_has_fence_heading();
}
inline void ObjectFollow::clear_fence_heading() {
  fence_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectFollow::_internal_fence_heading() const {
  return fence_heading_;
}
inline double ObjectFollow::fence_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectFollow.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectFollow::_internal_set_fence_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  fence_heading_ = value;
}
inline void ObjectFollow::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectFollow.fence_heading)
}

// -------------------------------------------------------------------

// ObjectOvertake

// optional double distance_s = 1;
inline bool ObjectOvertake::_internal_has_distance_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectOvertake::has_distance_s() const {
  return _internal_has_distance_s();
}
inline void ObjectOvertake::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectOvertake::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectOvertake::distance_s() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.distance_s)
  return _internal_distance_s();
}
inline void ObjectOvertake::_internal_set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
}
inline void ObjectOvertake::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectOvertake.distance_s)
}

// optional .control.common.PointENU fence_point = 2;
inline bool ObjectOvertake::_internal_has_fence_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || fence_point_ != nullptr);
  return value;
}
inline bool ObjectOvertake::has_fence_point() const {
  return _internal_has_fence_point();
}
inline const ::control::common::PointENU& ObjectOvertake::_internal_fence_point() const {
  const ::control::common::PointENU* p = fence_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::PointENU*>(
      &::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& ObjectOvertake::fence_point() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.fence_point)
  return _internal_fence_point();
}
inline void ObjectOvertake::unsafe_arena_set_allocated_fence_point(
    ::control::common::PointENU* fence_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  fence_point_ = fence_point;
  if (fence_point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectOvertake.fence_point)
}
inline ::control::common::PointENU* ObjectOvertake::release_fence_point() {
  auto temp = unsafe_arena_release_fence_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::PointENU* ObjectOvertake::unsafe_arena_release_fence_point() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectOvertake.fence_point)
  _has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* ObjectOvertake::_internal_mutable_fence_point() {
  _has_bits_[0] |= 0x00000001u;
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::PointENU>(GetArena());
    fence_point_ = p;
  }
  return fence_point_;
}
inline ::control::common::PointENU* ObjectOvertake::mutable_fence_point() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectOvertake.fence_point)
  return _internal_mutable_fence_point();
}
inline void ObjectOvertake::set_allocated_fence_point(::control::common::PointENU* fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point)->GetArena();
    if (message_arena != submessage_arena) {
      fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectOvertake.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectOvertake::_internal_has_fence_heading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectOvertake::has_fence_heading() const {
  return _internal_has_fence_heading();
}
inline void ObjectOvertake::clear_fence_heading() {
  fence_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectOvertake::_internal_fence_heading() const {
  return fence_heading_;
}
inline double ObjectOvertake::fence_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectOvertake::_internal_set_fence_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  fence_heading_ = value;
}
inline void ObjectOvertake::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectOvertake.fence_heading)
}

// optional double time_buffer = 4;
inline bool ObjectOvertake::_internal_has_time_buffer() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObjectOvertake::has_time_buffer() const {
  return _internal_has_time_buffer();
}
inline void ObjectOvertake::clear_time_buffer() {
  time_buffer_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ObjectOvertake::_internal_time_buffer() const {
  return time_buffer_;
}
inline double ObjectOvertake::time_buffer() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectOvertake.time_buffer)
  return _internal_time_buffer();
}
inline void ObjectOvertake::_internal_set_time_buffer(double value) {
  _has_bits_[0] |= 0x00000008u;
  time_buffer_ = value;
}
inline void ObjectOvertake::set_time_buffer(double value) {
  _internal_set_time_buffer(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectOvertake.time_buffer)
}

// -------------------------------------------------------------------

// ObjectSidePass

// optional .control.planning.ObjectSidePass.Type type = 1;
inline bool ObjectSidePass::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectSidePass::has_type() const {
  return _internal_has_type();
}
inline void ObjectSidePass::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::control::planning::ObjectSidePass_Type ObjectSidePass::_internal_type() const {
  return static_cast< ::control::planning::ObjectSidePass_Type >(type_);
}
inline ::control::planning::ObjectSidePass_Type ObjectSidePass::type() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectSidePass.type)
  return _internal_type();
}
inline void ObjectSidePass::_internal_set_type(::control::planning::ObjectSidePass_Type value) {
  assert(::control::planning::ObjectSidePass_Type_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void ObjectSidePass::set_type(::control::planning::ObjectSidePass_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectSidePass.type)
}

// -------------------------------------------------------------------

// ObjectAvoid

// -------------------------------------------------------------------

// ObjectStatus

// optional .control.planning.ObjectMotionType motion_type = 1;
inline bool ObjectStatus::_internal_has_motion_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || motion_type_ != nullptr);
  return value;
}
inline bool ObjectStatus::has_motion_type() const {
  return _internal_has_motion_type();
}
inline void ObjectStatus::clear_motion_type() {
  if (motion_type_ != nullptr) motion_type_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning::ObjectMotionType& ObjectStatus::_internal_motion_type() const {
  const ::control::planning::ObjectMotionType* p = motion_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::planning::ObjectMotionType*>(
      &::control::planning::_ObjectMotionType_default_instance_);
}
inline const ::control::planning::ObjectMotionType& ObjectStatus::motion_type() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStatus.motion_type)
  return _internal_motion_type();
}
inline void ObjectStatus::unsafe_arena_set_allocated_motion_type(
    ::control::planning::ObjectMotionType* motion_type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_type_);
  }
  motion_type_ = motion_type;
  if (motion_type) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectStatus.motion_type)
}
inline ::control::planning::ObjectMotionType* ObjectStatus::release_motion_type() {
  auto temp = unsafe_arena_release_motion_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::planning::ObjectMotionType* ObjectStatus::unsafe_arena_release_motion_type() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectStatus.motion_type)
  _has_bits_[0] &= ~0x00000001u;
  ::control::planning::ObjectMotionType* temp = motion_type_;
  motion_type_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectMotionType* ObjectStatus::_internal_mutable_motion_type() {
  _has_bits_[0] |= 0x00000001u;
  if (motion_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::planning::ObjectMotionType>(GetArena());
    motion_type_ = p;
  }
  return motion_type_;
}
inline ::control::planning::ObjectMotionType* ObjectStatus::mutable_motion_type() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStatus.motion_type)
  return _internal_mutable_motion_type();
}
inline void ObjectStatus::set_allocated_motion_type(::control::planning::ObjectMotionType* motion_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete motion_type_;
  }
  if (motion_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(motion_type);
    if (message_arena != submessage_arena) {
      motion_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  motion_type_ = motion_type;
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectStatus.motion_type)
}

// optional .control.planning.ObjectDecisionType decision_type = 2;
inline bool ObjectStatus::_internal_has_decision_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || decision_type_ != nullptr);
  return value;
}
inline bool ObjectStatus::has_decision_type() const {
  return _internal_has_decision_type();
}
inline void ObjectStatus::clear_decision_type() {
  if (decision_type_ != nullptr) decision_type_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning::ObjectDecisionType& ObjectStatus::_internal_decision_type() const {
  const ::control::planning::ObjectDecisionType* p = decision_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::planning::ObjectDecisionType*>(
      &::control::planning::_ObjectDecisionType_default_instance_);
}
inline const ::control::planning::ObjectDecisionType& ObjectStatus::decision_type() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectStatus.decision_type)
  return _internal_decision_type();
}
inline void ObjectStatus::unsafe_arena_set_allocated_decision_type(
    ::control::planning::ObjectDecisionType* decision_type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(decision_type_);
  }
  decision_type_ = decision_type;
  if (decision_type) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectStatus.decision_type)
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::release_decision_type() {
  auto temp = unsafe_arena_release_decision_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::unsafe_arena_release_decision_type() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectStatus.decision_type)
  _has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisionType* temp = decision_type_;
  decision_type_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::_internal_mutable_decision_type() {
  _has_bits_[0] |= 0x00000002u;
  if (decision_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::planning::ObjectDecisionType>(GetArena());
    decision_type_ = p;
  }
  return decision_type_;
}
inline ::control::planning::ObjectDecisionType* ObjectStatus::mutable_decision_type() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectStatus.decision_type)
  return _internal_mutable_decision_type();
}
inline void ObjectStatus::set_allocated_decision_type(::control::planning::ObjectDecisionType* decision_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete decision_type_;
  }
  if (decision_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(decision_type);
    if (message_arena != submessage_arena) {
      decision_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decision_type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  decision_type_ = decision_type;
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectStatus.decision_type)
}

// -------------------------------------------------------------------

// ObjectStatic

// -------------------------------------------------------------------

// ObjectDynamic

// -------------------------------------------------------------------

// ObjectMotionType

// .control.planning.ObjectStatic static = 1;
inline bool ObjectMotionType::_internal_has_static_() const {
  return motion_tag_case() == kStatic;
}
inline bool ObjectMotionType::has_static_() const {
  return _internal_has_static_();
}
inline void ObjectMotionType::set_has_static_() {
  _oneof_case_[0] = kStatic;
}
inline void ObjectMotionType::clear_static_() {
  if (_internal_has_static_()) {
    if (GetArena() == nullptr) {
      delete motion_tag_.static__;
    }
    clear_has_motion_tag();
  }
}
inline ::control::planning::ObjectStatic* ObjectMotionType::release_static_() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectMotionType.static)
  if (_internal_has_static_()) {
    clear_has_motion_tag();
      ::control::planning::ObjectStatic* temp = motion_tag_.static__;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectStatic& ObjectMotionType::_internal_static_() const {
  return _internal_has_static_()
      ? *motion_tag_.static__
      : *reinterpret_cast< ::control::planning::ObjectStatic*>(&::control::planning::_ObjectStatic_default_instance_);
}
inline const ::control::planning::ObjectStatic& ObjectMotionType::static_() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectMotionType.static)
  return _internal_static_();
}
inline ::control::planning::ObjectStatic* ObjectMotionType::unsafe_arena_release_static_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectMotionType.static)
  if (_internal_has_static_()) {
    clear_has_motion_tag();
    ::control::planning::ObjectStatic* temp = motion_tag_.static__;
    motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectMotionType::unsafe_arena_set_allocated_static_(::control::planning::ObjectStatic* static_) {
  clear_motion_tag();
  if (static_) {
    set_has_static_();
    motion_tag_.static__ = static_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectMotionType.static)
}
inline ::control::planning::ObjectStatic* ObjectMotionType::_internal_mutable_static_() {
  if (!_internal_has_static_()) {
    clear_motion_tag();
    set_has_static_();
    motion_tag_.static__ = CreateMaybeMessage< ::control::planning::ObjectStatic >(GetArena());
  }
  return motion_tag_.static__;
}
inline ::control::planning::ObjectStatic* ObjectMotionType::mutable_static_() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectMotionType.static)
  return _internal_mutable_static_();
}

// .control.planning.ObjectDynamic dynamic = 2;
inline bool ObjectMotionType::_internal_has_dynamic() const {
  return motion_tag_case() == kDynamic;
}
inline bool ObjectMotionType::has_dynamic() const {
  return _internal_has_dynamic();
}
inline void ObjectMotionType::set_has_dynamic() {
  _oneof_case_[0] = kDynamic;
}
inline void ObjectMotionType::clear_dynamic() {
  if (_internal_has_dynamic()) {
    if (GetArena() == nullptr) {
      delete motion_tag_.dynamic_;
    }
    clear_has_motion_tag();
  }
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::release_dynamic() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectMotionType.dynamic)
  if (_internal_has_dynamic()) {
    clear_has_motion_tag();
      ::control::planning::ObjectDynamic* temp = motion_tag_.dynamic_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectDynamic& ObjectMotionType::_internal_dynamic() const {
  return _internal_has_dynamic()
      ? *motion_tag_.dynamic_
      : *reinterpret_cast< ::control::planning::ObjectDynamic*>(&::control::planning::_ObjectDynamic_default_instance_);
}
inline const ::control::planning::ObjectDynamic& ObjectMotionType::dynamic() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectMotionType.dynamic)
  return _internal_dynamic();
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::unsafe_arena_release_dynamic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectMotionType.dynamic)
  if (_internal_has_dynamic()) {
    clear_has_motion_tag();
    ::control::planning::ObjectDynamic* temp = motion_tag_.dynamic_;
    motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectMotionType::unsafe_arena_set_allocated_dynamic(::control::planning::ObjectDynamic* dynamic) {
  clear_motion_tag();
  if (dynamic) {
    set_has_dynamic();
    motion_tag_.dynamic_ = dynamic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectMotionType.dynamic)
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::_internal_mutable_dynamic() {
  if (!_internal_has_dynamic()) {
    clear_motion_tag();
    set_has_dynamic();
    motion_tag_.dynamic_ = CreateMaybeMessage< ::control::planning::ObjectDynamic >(GetArena());
  }
  return motion_tag_.dynamic_;
}
inline ::control::planning::ObjectDynamic* ObjectMotionType::mutable_dynamic() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectMotionType.dynamic)
  return _internal_mutable_dynamic();
}

inline bool ObjectMotionType::has_motion_tag() const {
  return motion_tag_case() != MOTION_TAG_NOT_SET;
}
inline void ObjectMotionType::clear_has_motion_tag() {
  _oneof_case_[0] = MOTION_TAG_NOT_SET;
}
inline ObjectMotionType::MotionTagCase ObjectMotionType::motion_tag_case() const {
  return ObjectMotionType::MotionTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecisionType

// .control.planning.ObjectIgnore ignore = 1;
inline bool ObjectDecisionType::_internal_has_ignore() const {
  return object_tag_case() == kIgnore;
}
inline bool ObjectDecisionType::has_ignore() const {
  return _internal_has_ignore();
}
inline void ObjectDecisionType::set_has_ignore() {
  _oneof_case_[0] = kIgnore;
}
inline void ObjectDecisionType::clear_ignore() {
  if (_internal_has_ignore()) {
    if (GetArena() == nullptr) {
      delete object_tag_.ignore_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::release_ignore() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.ignore)
  if (_internal_has_ignore()) {
    clear_has_object_tag();
      ::control::planning::ObjectIgnore* temp = object_tag_.ignore_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectIgnore& ObjectDecisionType::_internal_ignore() const {
  return _internal_has_ignore()
      ? *object_tag_.ignore_
      : *reinterpret_cast< ::control::planning::ObjectIgnore*>(&::control::planning::_ObjectIgnore_default_instance_);
}
inline const ::control::planning::ObjectIgnore& ObjectDecisionType::ignore() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.ignore)
  return _internal_ignore();
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::unsafe_arena_release_ignore() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.ignore)
  if (_internal_has_ignore()) {
    clear_has_object_tag();
    ::control::planning::ObjectIgnore* temp = object_tag_.ignore_;
    object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_ignore(::control::planning::ObjectIgnore* ignore) {
  clear_object_tag();
  if (ignore) {
    set_has_ignore();
    object_tag_.ignore_ = ignore;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.ignore)
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::_internal_mutable_ignore() {
  if (!_internal_has_ignore()) {
    clear_object_tag();
    set_has_ignore();
    object_tag_.ignore_ = CreateMaybeMessage< ::control::planning::ObjectIgnore >(GetArena());
  }
  return object_tag_.ignore_;
}
inline ::control::planning::ObjectIgnore* ObjectDecisionType::mutable_ignore() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.ignore)
  return _internal_mutable_ignore();
}

// .control.planning.ObjectStop stop = 2;
inline bool ObjectDecisionType::_internal_has_stop() const {
  return object_tag_case() == kStop;
}
inline bool ObjectDecisionType::has_stop() const {
  return _internal_has_stop();
}
inline void ObjectDecisionType::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void ObjectDecisionType::clear_stop() {
  if (_internal_has_stop()) {
    if (GetArena() == nullptr) {
      delete object_tag_.stop_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectStop* ObjectDecisionType::release_stop() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.stop)
  if (_internal_has_stop()) {
    clear_has_object_tag();
      ::control::planning::ObjectStop* temp = object_tag_.stop_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectStop& ObjectDecisionType::_internal_stop() const {
  return _internal_has_stop()
      ? *object_tag_.stop_
      : *reinterpret_cast< ::control::planning::ObjectStop*>(&::control::planning::_ObjectStop_default_instance_);
}
inline const ::control::planning::ObjectStop& ObjectDecisionType::stop() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.stop)
  return _internal_stop();
}
inline ::control::planning::ObjectStop* ObjectDecisionType::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.stop)
  if (_internal_has_stop()) {
    clear_has_object_tag();
    ::control::planning::ObjectStop* temp = object_tag_.stop_;
    object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_stop(::control::planning::ObjectStop* stop) {
  clear_object_tag();
  if (stop) {
    set_has_stop();
    object_tag_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.stop)
}
inline ::control::planning::ObjectStop* ObjectDecisionType::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_object_tag();
    set_has_stop();
    object_tag_.stop_ = CreateMaybeMessage< ::control::planning::ObjectStop >(GetArena());
  }
  return object_tag_.stop_;
}
inline ::control::planning::ObjectStop* ObjectDecisionType::mutable_stop() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.stop)
  return _internal_mutable_stop();
}

// .control.planning.ObjectFollow follow = 3;
inline bool ObjectDecisionType::_internal_has_follow() const {
  return object_tag_case() == kFollow;
}
inline bool ObjectDecisionType::has_follow() const {
  return _internal_has_follow();
}
inline void ObjectDecisionType::set_has_follow() {
  _oneof_case_[0] = kFollow;
}
inline void ObjectDecisionType::clear_follow() {
  if (_internal_has_follow()) {
    if (GetArena() == nullptr) {
      delete object_tag_.follow_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::release_follow() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.follow)
  if (_internal_has_follow()) {
    clear_has_object_tag();
      ::control::planning::ObjectFollow* temp = object_tag_.follow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectFollow& ObjectDecisionType::_internal_follow() const {
  return _internal_has_follow()
      ? *object_tag_.follow_
      : *reinterpret_cast< ::control::planning::ObjectFollow*>(&::control::planning::_ObjectFollow_default_instance_);
}
inline const ::control::planning::ObjectFollow& ObjectDecisionType::follow() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.follow)
  return _internal_follow();
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::unsafe_arena_release_follow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.follow)
  if (_internal_has_follow()) {
    clear_has_object_tag();
    ::control::planning::ObjectFollow* temp = object_tag_.follow_;
    object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_follow(::control::planning::ObjectFollow* follow) {
  clear_object_tag();
  if (follow) {
    set_has_follow();
    object_tag_.follow_ = follow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.follow)
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::_internal_mutable_follow() {
  if (!_internal_has_follow()) {
    clear_object_tag();
    set_has_follow();
    object_tag_.follow_ = CreateMaybeMessage< ::control::planning::ObjectFollow >(GetArena());
  }
  return object_tag_.follow_;
}
inline ::control::planning::ObjectFollow* ObjectDecisionType::mutable_follow() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.follow)
  return _internal_mutable_follow();
}

// .control.planning.ObjectYield yield = 4;
inline bool ObjectDecisionType::_internal_has_yield() const {
  return object_tag_case() == kYield;
}
inline bool ObjectDecisionType::has_yield() const {
  return _internal_has_yield();
}
inline void ObjectDecisionType::set_has_yield() {
  _oneof_case_[0] = kYield;
}
inline void ObjectDecisionType::clear_yield() {
  if (_internal_has_yield()) {
    if (GetArena() == nullptr) {
      delete object_tag_.yield_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectYield* ObjectDecisionType::release_yield() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.yield)
  if (_internal_has_yield()) {
    clear_has_object_tag();
      ::control::planning::ObjectYield* temp = object_tag_.yield_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectYield& ObjectDecisionType::_internal_yield() const {
  return _internal_has_yield()
      ? *object_tag_.yield_
      : *reinterpret_cast< ::control::planning::ObjectYield*>(&::control::planning::_ObjectYield_default_instance_);
}
inline const ::control::planning::ObjectYield& ObjectDecisionType::yield() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.yield)
  return _internal_yield();
}
inline ::control::planning::ObjectYield* ObjectDecisionType::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.yield)
  if (_internal_has_yield()) {
    clear_has_object_tag();
    ::control::planning::ObjectYield* temp = object_tag_.yield_;
    object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_yield(::control::planning::ObjectYield* yield) {
  clear_object_tag();
  if (yield) {
    set_has_yield();
    object_tag_.yield_ = yield;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.yield)
}
inline ::control::planning::ObjectYield* ObjectDecisionType::_internal_mutable_yield() {
  if (!_internal_has_yield()) {
    clear_object_tag();
    set_has_yield();
    object_tag_.yield_ = CreateMaybeMessage< ::control::planning::ObjectYield >(GetArena());
  }
  return object_tag_.yield_;
}
inline ::control::planning::ObjectYield* ObjectDecisionType::mutable_yield() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.yield)
  return _internal_mutable_yield();
}

// .control.planning.ObjectOvertake overtake = 5;
inline bool ObjectDecisionType::_internal_has_overtake() const {
  return object_tag_case() == kOvertake;
}
inline bool ObjectDecisionType::has_overtake() const {
  return _internal_has_overtake();
}
inline void ObjectDecisionType::set_has_overtake() {
  _oneof_case_[0] = kOvertake;
}
inline void ObjectDecisionType::clear_overtake() {
  if (_internal_has_overtake()) {
    if (GetArena() == nullptr) {
      delete object_tag_.overtake_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::release_overtake() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.overtake)
  if (_internal_has_overtake()) {
    clear_has_object_tag();
      ::control::planning::ObjectOvertake* temp = object_tag_.overtake_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectOvertake& ObjectDecisionType::_internal_overtake() const {
  return _internal_has_overtake()
      ? *object_tag_.overtake_
      : *reinterpret_cast< ::control::planning::ObjectOvertake*>(&::control::planning::_ObjectOvertake_default_instance_);
}
inline const ::control::planning::ObjectOvertake& ObjectDecisionType::overtake() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.overtake)
  return _internal_overtake();
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::unsafe_arena_release_overtake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.overtake)
  if (_internal_has_overtake()) {
    clear_has_object_tag();
    ::control::planning::ObjectOvertake* temp = object_tag_.overtake_;
    object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_overtake(::control::planning::ObjectOvertake* overtake) {
  clear_object_tag();
  if (overtake) {
    set_has_overtake();
    object_tag_.overtake_ = overtake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.overtake)
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::_internal_mutable_overtake() {
  if (!_internal_has_overtake()) {
    clear_object_tag();
    set_has_overtake();
    object_tag_.overtake_ = CreateMaybeMessage< ::control::planning::ObjectOvertake >(GetArena());
  }
  return object_tag_.overtake_;
}
inline ::control::planning::ObjectOvertake* ObjectDecisionType::mutable_overtake() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.overtake)
  return _internal_mutable_overtake();
}

// .control.planning.ObjectNudge nudge = 6;
inline bool ObjectDecisionType::_internal_has_nudge() const {
  return object_tag_case() == kNudge;
}
inline bool ObjectDecisionType::has_nudge() const {
  return _internal_has_nudge();
}
inline void ObjectDecisionType::set_has_nudge() {
  _oneof_case_[0] = kNudge;
}
inline void ObjectDecisionType::clear_nudge() {
  if (_internal_has_nudge()) {
    if (GetArena() == nullptr) {
      delete object_tag_.nudge_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::release_nudge() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.nudge)
  if (_internal_has_nudge()) {
    clear_has_object_tag();
      ::control::planning::ObjectNudge* temp = object_tag_.nudge_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectNudge& ObjectDecisionType::_internal_nudge() const {
  return _internal_has_nudge()
      ? *object_tag_.nudge_
      : *reinterpret_cast< ::control::planning::ObjectNudge*>(&::control::planning::_ObjectNudge_default_instance_);
}
inline const ::control::planning::ObjectNudge& ObjectDecisionType::nudge() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.nudge)
  return _internal_nudge();
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::unsafe_arena_release_nudge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.nudge)
  if (_internal_has_nudge()) {
    clear_has_object_tag();
    ::control::planning::ObjectNudge* temp = object_tag_.nudge_;
    object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_nudge(::control::planning::ObjectNudge* nudge) {
  clear_object_tag();
  if (nudge) {
    set_has_nudge();
    object_tag_.nudge_ = nudge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.nudge)
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::_internal_mutable_nudge() {
  if (!_internal_has_nudge()) {
    clear_object_tag();
    set_has_nudge();
    object_tag_.nudge_ = CreateMaybeMessage< ::control::planning::ObjectNudge >(GetArena());
  }
  return object_tag_.nudge_;
}
inline ::control::planning::ObjectNudge* ObjectDecisionType::mutable_nudge() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.nudge)
  return _internal_mutable_nudge();
}

// .control.planning.ObjectAvoid avoid = 7;
inline bool ObjectDecisionType::_internal_has_avoid() const {
  return object_tag_case() == kAvoid;
}
inline bool ObjectDecisionType::has_avoid() const {
  return _internal_has_avoid();
}
inline void ObjectDecisionType::set_has_avoid() {
  _oneof_case_[0] = kAvoid;
}
inline void ObjectDecisionType::clear_avoid() {
  if (_internal_has_avoid()) {
    if (GetArena() == nullptr) {
      delete object_tag_.avoid_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::release_avoid() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.avoid)
  if (_internal_has_avoid()) {
    clear_has_object_tag();
      ::control::planning::ObjectAvoid* temp = object_tag_.avoid_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectAvoid& ObjectDecisionType::_internal_avoid() const {
  return _internal_has_avoid()
      ? *object_tag_.avoid_
      : *reinterpret_cast< ::control::planning::ObjectAvoid*>(&::control::planning::_ObjectAvoid_default_instance_);
}
inline const ::control::planning::ObjectAvoid& ObjectDecisionType::avoid() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.avoid)
  return _internal_avoid();
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::unsafe_arena_release_avoid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.avoid)
  if (_internal_has_avoid()) {
    clear_has_object_tag();
    ::control::planning::ObjectAvoid* temp = object_tag_.avoid_;
    object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_avoid(::control::planning::ObjectAvoid* avoid) {
  clear_object_tag();
  if (avoid) {
    set_has_avoid();
    object_tag_.avoid_ = avoid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.avoid)
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::_internal_mutable_avoid() {
  if (!_internal_has_avoid()) {
    clear_object_tag();
    set_has_avoid();
    object_tag_.avoid_ = CreateMaybeMessage< ::control::planning::ObjectAvoid >(GetArena());
  }
  return object_tag_.avoid_;
}
inline ::control::planning::ObjectAvoid* ObjectDecisionType::mutable_avoid() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.avoid)
  return _internal_mutable_avoid();
}

// .control.planning.ObjectSidePass side_pass = 8;
inline bool ObjectDecisionType::_internal_has_side_pass() const {
  return object_tag_case() == kSidePass;
}
inline bool ObjectDecisionType::has_side_pass() const {
  return _internal_has_side_pass();
}
inline void ObjectDecisionType::set_has_side_pass() {
  _oneof_case_[0] = kSidePass;
}
inline void ObjectDecisionType::clear_side_pass() {
  if (_internal_has_side_pass()) {
    if (GetArena() == nullptr) {
      delete object_tag_.side_pass_;
    }
    clear_has_object_tag();
  }
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::release_side_pass() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecisionType.side_pass)
  if (_internal_has_side_pass()) {
    clear_has_object_tag();
      ::control::planning::ObjectSidePass* temp = object_tag_.side_pass_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::ObjectSidePass& ObjectDecisionType::_internal_side_pass() const {
  return _internal_has_side_pass()
      ? *object_tag_.side_pass_
      : *reinterpret_cast< ::control::planning::ObjectSidePass*>(&::control::planning::_ObjectSidePass_default_instance_);
}
inline const ::control::planning::ObjectSidePass& ObjectDecisionType::side_pass() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisionType.side_pass)
  return _internal_side_pass();
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::unsafe_arena_release_side_pass() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecisionType.side_pass)
  if (_internal_has_side_pass()) {
    clear_has_object_tag();
    ::control::planning::ObjectSidePass* temp = object_tag_.side_pass_;
    object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_side_pass(::control::planning::ObjectSidePass* side_pass) {
  clear_object_tag();
  if (side_pass) {
    set_has_side_pass();
    object_tag_.side_pass_ = side_pass;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecisionType.side_pass)
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::_internal_mutable_side_pass() {
  if (!_internal_has_side_pass()) {
    clear_object_tag();
    set_has_side_pass();
    object_tag_.side_pass_ = CreateMaybeMessage< ::control::planning::ObjectSidePass >(GetArena());
  }
  return object_tag_.side_pass_;
}
inline ::control::planning::ObjectSidePass* ObjectDecisionType::mutable_side_pass() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisionType.side_pass)
  return _internal_mutable_side_pass();
}

inline bool ObjectDecisionType::has_object_tag() const {
  return object_tag_case() != OBJECT_TAG_NOT_SET;
}
inline void ObjectDecisionType::clear_has_object_tag() {
  _oneof_case_[0] = OBJECT_TAG_NOT_SET;
}
inline ObjectDecisionType::ObjectTagCase ObjectDecisionType::object_tag_case() const {
  return ObjectDecisionType::ObjectTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecision

// optional string id = 1;
inline bool ObjectDecision::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectDecision::has_id() const {
  return _internal_has_id();
}
inline void ObjectDecision::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObjectDecision::id() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecision.id)
  return _internal_id();
}
inline void ObjectDecision::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectDecision.id)
}
inline std::string* ObjectDecision::mutable_id() {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecision.id)
  return _internal_mutable_id();
}
inline const std::string& ObjectDecision::_internal_id() const {
  return id_.Get();
}
inline void ObjectDecision::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ObjectDecision::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:control.planning.ObjectDecision.id)
}
inline void ObjectDecision::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:control.planning.ObjectDecision.id)
}
inline void ObjectDecision::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:control.planning.ObjectDecision.id)
}
inline std::string* ObjectDecision::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ObjectDecision::release_id() {
  // @@protoc_insertion_point(field_release:control.planning.ObjectDecision.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ObjectDecision::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:control.planning.ObjectDecision.id)
}
inline std::string* ObjectDecision::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.ObjectDecision.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ObjectDecision::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.ObjectDecision.id)
}

// optional int32 perception_id = 2;
inline bool ObjectDecision::_internal_has_perception_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectDecision::has_perception_id() const {
  return _internal_has_perception_id();
}
inline void ObjectDecision::clear_perception_id() {
  perception_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ObjectDecision::_internal_perception_id() const {
  return perception_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ObjectDecision::perception_id() const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecision.perception_id)
  return _internal_perception_id();
}
inline void ObjectDecision::_internal_set_perception_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  perception_id_ = value;
}
inline void ObjectDecision::set_perception_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_perception_id(value);
  // @@protoc_insertion_point(field_set:control.planning.ObjectDecision.perception_id)
}

// repeated .control.planning.ObjectDecisionType object_decision = 3;
inline int ObjectDecision::_internal_object_decision_size() const {
  return object_decision_.size();
}
inline int ObjectDecision::object_decision_size() const {
  return _internal_object_decision_size();
}
inline void ObjectDecision::clear_object_decision() {
  object_decision_.Clear();
}
inline ::control::planning::ObjectDecisionType* ObjectDecision::mutable_object_decision(int index) {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecision.object_decision)
  return object_decision_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecisionType >*
ObjectDecision::mutable_object_decision() {
  // @@protoc_insertion_point(field_mutable_list:control.planning.ObjectDecision.object_decision)
  return &object_decision_;
}
inline const ::control::planning::ObjectDecisionType& ObjectDecision::_internal_object_decision(int index) const {
  return object_decision_.Get(index);
}
inline const ::control::planning::ObjectDecisionType& ObjectDecision::object_decision(int index) const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecision.object_decision)
  return _internal_object_decision(index);
}
inline ::control::planning::ObjectDecisionType* ObjectDecision::_internal_add_object_decision() {
  return object_decision_.Add();
}
inline ::control::planning::ObjectDecisionType* ObjectDecision::add_object_decision() {
  // @@protoc_insertion_point(field_add:control.planning.ObjectDecision.object_decision)
  return _internal_add_object_decision();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecisionType >&
ObjectDecision::object_decision() const {
  // @@protoc_insertion_point(field_list:control.planning.ObjectDecision.object_decision)
  return object_decision_;
}

// -------------------------------------------------------------------

// ObjectDecisions

// repeated .control.planning.ObjectDecision decision = 1;
inline int ObjectDecisions::_internal_decision_size() const {
  return decision_.size();
}
inline int ObjectDecisions::decision_size() const {
  return _internal_decision_size();
}
inline void ObjectDecisions::clear_decision() {
  decision_.Clear();
}
inline ::control::planning::ObjectDecision* ObjectDecisions::mutable_decision(int index) {
  // @@protoc_insertion_point(field_mutable:control.planning.ObjectDecisions.decision)
  return decision_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecision >*
ObjectDecisions::mutable_decision() {
  // @@protoc_insertion_point(field_mutable_list:control.planning.ObjectDecisions.decision)
  return &decision_;
}
inline const ::control::planning::ObjectDecision& ObjectDecisions::_internal_decision(int index) const {
  return decision_.Get(index);
}
inline const ::control::planning::ObjectDecision& ObjectDecisions::decision(int index) const {
  // @@protoc_insertion_point(field_get:control.planning.ObjectDecisions.decision)
  return _internal_decision(index);
}
inline ::control::planning::ObjectDecision* ObjectDecisions::_internal_add_decision() {
  return decision_.Add();
}
inline ::control::planning::ObjectDecision* ObjectDecisions::add_decision() {
  // @@protoc_insertion_point(field_add:control.planning.ObjectDecisions.decision)
  return _internal_add_decision();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::ObjectDecision >&
ObjectDecisions::decision() const {
  // @@protoc_insertion_point(field_list:control.planning.ObjectDecisions.decision)
  return decision_;
}

// -------------------------------------------------------------------

// MainStop

// optional .control.planning.StopReasonCode reason_code = 1;
inline bool MainStop::_internal_has_reason_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MainStop::has_reason_code() const {
  return _internal_has_reason_code();
}
inline void MainStop::clear_reason_code() {
  reason_code_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::control::planning::StopReasonCode MainStop::_internal_reason_code() const {
  return static_cast< ::control::planning::StopReasonCode >(reason_code_);
}
inline ::control::planning::StopReasonCode MainStop::reason_code() const {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.reason_code)
  return _internal_reason_code();
}
inline void MainStop::_internal_set_reason_code(::control::planning::StopReasonCode value) {
  assert(::control::planning::StopReasonCode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  reason_code_ = value;
}
inline void MainStop::set_reason_code(::control::planning::StopReasonCode value) {
  _internal_set_reason_code(value);
  // @@protoc_insertion_point(field_set:control.planning.MainStop.reason_code)
}

// optional string reason = 2;
inline bool MainStop::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MainStop::has_reason() const {
  return _internal_has_reason();
}
inline void MainStop::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MainStop::reason() const {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.reason)
  return _internal_reason();
}
inline void MainStop::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:control.planning.MainStop.reason)
}
inline std::string* MainStop::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainStop.reason)
  return _internal_mutable_reason();
}
inline const std::string& MainStop::_internal_reason() const {
  return reason_.Get();
}
inline void MainStop::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MainStop::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:control.planning.MainStop.reason)
}
inline void MainStop::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:control.planning.MainStop.reason)
}
inline void MainStop::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:control.planning.MainStop.reason)
}
inline std::string* MainStop::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MainStop::release_reason() {
  // @@protoc_insertion_point(field_release:control.planning.MainStop.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MainStop::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainStop.reason)
}
inline std::string* MainStop::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainStop.reason)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MainStop::unsafe_arena_set_allocated_reason(
    std::string* reason) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reason, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainStop.reason)
}

// optional .control.common.PointENU stop_point = 3;
inline bool MainStop::_internal_has_stop_point() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || stop_point_ != nullptr);
  return value;
}
inline bool MainStop::has_stop_point() const {
  return _internal_has_stop_point();
}
inline const ::control::common::PointENU& MainStop::_internal_stop_point() const {
  const ::control::common::PointENU* p = stop_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::PointENU*>(
      &::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& MainStop::stop_point() const {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.stop_point)
  return _internal_stop_point();
}
inline void MainStop::unsafe_arena_set_allocated_stop_point(
    ::control::common::PointENU* stop_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  stop_point_ = stop_point;
  if (stop_point) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainStop.stop_point)
}
inline ::control::common::PointENU* MainStop::release_stop_point() {
  auto temp = unsafe_arena_release_stop_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::PointENU* MainStop::unsafe_arena_release_stop_point() {
  // @@protoc_insertion_point(field_release:control.planning.MainStop.stop_point)
  _has_bits_[0] &= ~0x00000002u;
  ::control::common::PointENU* temp = stop_point_;
  stop_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* MainStop::_internal_mutable_stop_point() {
  _has_bits_[0] |= 0x00000002u;
  if (stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::PointENU>(GetArena());
    stop_point_ = p;
  }
  return stop_point_;
}
inline ::control::common::PointENU* MainStop::mutable_stop_point() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainStop.stop_point)
  return _internal_mutable_stop_point();
}
inline void MainStop::set_allocated_stop_point(::control::common::PointENU* stop_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  if (stop_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point)->GetArena();
    if (message_arena != submessage_arena) {
      stop_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainStop.stop_point)
}

// optional double stop_heading = 4;
inline bool MainStop::_internal_has_stop_heading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MainStop::has_stop_heading() const {
  return _internal_has_stop_heading();
}
inline void MainStop::clear_stop_heading() {
  stop_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double MainStop::_internal_stop_heading() const {
  return stop_heading_;
}
inline double MainStop::stop_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.MainStop.stop_heading)
  return _internal_stop_heading();
}
inline void MainStop::_internal_set_stop_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  stop_heading_ = value;
}
inline void MainStop::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  // @@protoc_insertion_point(field_set:control.planning.MainStop.stop_heading)
}

// -------------------------------------------------------------------

// EmergencyStopHardBrake

// -------------------------------------------------------------------

// EmergencyStopCruiseToStop

// -------------------------------------------------------------------

// MainEmergencyStop

// optional .control.planning.MainEmergencyStop.ReasonCode reason_code = 1;
inline bool MainEmergencyStop::_internal_has_reason_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MainEmergencyStop::has_reason_code() const {
  return _internal_has_reason_code();
}
inline void MainEmergencyStop::clear_reason_code() {
  reason_code_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::control::planning::MainEmergencyStop_ReasonCode MainEmergencyStop::_internal_reason_code() const {
  return static_cast< ::control::planning::MainEmergencyStop_ReasonCode >(reason_code_);
}
inline ::control::planning::MainEmergencyStop_ReasonCode MainEmergencyStop::reason_code() const {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.reason_code)
  return _internal_reason_code();
}
inline void MainEmergencyStop::_internal_set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value) {
  assert(::control::planning::MainEmergencyStop_ReasonCode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  reason_code_ = value;
}
inline void MainEmergencyStop::set_reason_code(::control::planning::MainEmergencyStop_ReasonCode value) {
  _internal_set_reason_code(value);
  // @@protoc_insertion_point(field_set:control.planning.MainEmergencyStop.reason_code)
}

// optional string reason = 2;
inline bool MainEmergencyStop::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MainEmergencyStop::has_reason() const {
  return _internal_has_reason();
}
inline void MainEmergencyStop::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MainEmergencyStop::reason() const {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.reason)
  return _internal_reason();
}
inline void MainEmergencyStop::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:control.planning.MainEmergencyStop.reason)
}
inline std::string* MainEmergencyStop::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainEmergencyStop.reason)
  return _internal_mutable_reason();
}
inline const std::string& MainEmergencyStop::_internal_reason() const {
  return reason_.Get();
}
inline void MainEmergencyStop::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MainEmergencyStop::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:control.planning.MainEmergencyStop.reason)
}
inline void MainEmergencyStop::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:control.planning.MainEmergencyStop.reason)
}
inline void MainEmergencyStop::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:control.planning.MainEmergencyStop.reason)
}
inline std::string* MainEmergencyStop::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MainEmergencyStop::release_reason() {
  // @@protoc_insertion_point(field_release:control.planning.MainEmergencyStop.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MainEmergencyStop::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainEmergencyStop.reason)
}
inline std::string* MainEmergencyStop::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainEmergencyStop.reason)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MainEmergencyStop::unsafe_arena_set_allocated_reason(
    std::string* reason) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reason, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainEmergencyStop.reason)
}

// .control.planning.EmergencyStopHardBrake hard_brake = 3;
inline bool MainEmergencyStop::_internal_has_hard_brake() const {
  return task_case() == kHardBrake;
}
inline bool MainEmergencyStop::has_hard_brake() const {
  return _internal_has_hard_brake();
}
inline void MainEmergencyStop::set_has_hard_brake() {
  _oneof_case_[0] = kHardBrake;
}
inline void MainEmergencyStop::clear_hard_brake() {
  if (_internal_has_hard_brake()) {
    if (GetArena() == nullptr) {
      delete task_.hard_brake_;
    }
    clear_has_task();
  }
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::release_hard_brake() {
  // @@protoc_insertion_point(field_release:control.planning.MainEmergencyStop.hard_brake)
  if (_internal_has_hard_brake()) {
    clear_has_task();
      ::control::planning::EmergencyStopHardBrake* temp = task_.hard_brake_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.hard_brake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::EmergencyStopHardBrake& MainEmergencyStop::_internal_hard_brake() const {
  return _internal_has_hard_brake()
      ? *task_.hard_brake_
      : *reinterpret_cast< ::control::planning::EmergencyStopHardBrake*>(&::control::planning::_EmergencyStopHardBrake_default_instance_);
}
inline const ::control::planning::EmergencyStopHardBrake& MainEmergencyStop::hard_brake() const {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.hard_brake)
  return _internal_hard_brake();
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::unsafe_arena_release_hard_brake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainEmergencyStop.hard_brake)
  if (_internal_has_hard_brake()) {
    clear_has_task();
    ::control::planning::EmergencyStopHardBrake* temp = task_.hard_brake_;
    task_.hard_brake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainEmergencyStop::unsafe_arena_set_allocated_hard_brake(::control::planning::EmergencyStopHardBrake* hard_brake) {
  clear_task();
  if (hard_brake) {
    set_has_hard_brake();
    task_.hard_brake_ = hard_brake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainEmergencyStop.hard_brake)
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::_internal_mutable_hard_brake() {
  if (!_internal_has_hard_brake()) {
    clear_task();
    set_has_hard_brake();
    task_.hard_brake_ = CreateMaybeMessage< ::control::planning::EmergencyStopHardBrake >(GetArena());
  }
  return task_.hard_brake_;
}
inline ::control::planning::EmergencyStopHardBrake* MainEmergencyStop::mutable_hard_brake() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainEmergencyStop.hard_brake)
  return _internal_mutable_hard_brake();
}

// .control.planning.EmergencyStopCruiseToStop cruise_to_stop = 4;
inline bool MainEmergencyStop::_internal_has_cruise_to_stop() const {
  return task_case() == kCruiseToStop;
}
inline bool MainEmergencyStop::has_cruise_to_stop() const {
  return _internal_has_cruise_to_stop();
}
inline void MainEmergencyStop::set_has_cruise_to_stop() {
  _oneof_case_[0] = kCruiseToStop;
}
inline void MainEmergencyStop::clear_cruise_to_stop() {
  if (_internal_has_cruise_to_stop()) {
    if (GetArena() == nullptr) {
      delete task_.cruise_to_stop_;
    }
    clear_has_task();
  }
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::release_cruise_to_stop() {
  // @@protoc_insertion_point(field_release:control.planning.MainEmergencyStop.cruise_to_stop)
  if (_internal_has_cruise_to_stop()) {
    clear_has_task();
      ::control::planning::EmergencyStopCruiseToStop* temp = task_.cruise_to_stop_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.cruise_to_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::EmergencyStopCruiseToStop& MainEmergencyStop::_internal_cruise_to_stop() const {
  return _internal_has_cruise_to_stop()
      ? *task_.cruise_to_stop_
      : *reinterpret_cast< ::control::planning::EmergencyStopCruiseToStop*>(&::control::planning::_EmergencyStopCruiseToStop_default_instance_);
}
inline const ::control::planning::EmergencyStopCruiseToStop& MainEmergencyStop::cruise_to_stop() const {
  // @@protoc_insertion_point(field_get:control.planning.MainEmergencyStop.cruise_to_stop)
  return _internal_cruise_to_stop();
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::unsafe_arena_release_cruise_to_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainEmergencyStop.cruise_to_stop)
  if (_internal_has_cruise_to_stop()) {
    clear_has_task();
    ::control::planning::EmergencyStopCruiseToStop* temp = task_.cruise_to_stop_;
    task_.cruise_to_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainEmergencyStop::unsafe_arena_set_allocated_cruise_to_stop(::control::planning::EmergencyStopCruiseToStop* cruise_to_stop) {
  clear_task();
  if (cruise_to_stop) {
    set_has_cruise_to_stop();
    task_.cruise_to_stop_ = cruise_to_stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainEmergencyStop.cruise_to_stop)
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::_internal_mutable_cruise_to_stop() {
  if (!_internal_has_cruise_to_stop()) {
    clear_task();
    set_has_cruise_to_stop();
    task_.cruise_to_stop_ = CreateMaybeMessage< ::control::planning::EmergencyStopCruiseToStop >(GetArena());
  }
  return task_.cruise_to_stop_;
}
inline ::control::planning::EmergencyStopCruiseToStop* MainEmergencyStop::mutable_cruise_to_stop() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainEmergencyStop.cruise_to_stop)
  return _internal_mutable_cruise_to_stop();
}

inline bool MainEmergencyStop::has_task() const {
  return task_case() != TASK_NOT_SET;
}
inline void MainEmergencyStop::clear_has_task() {
  _oneof_case_[0] = TASK_NOT_SET;
}
inline MainEmergencyStop::TaskCase MainEmergencyStop::task_case() const {
  return MainEmergencyStop::TaskCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MainCruise

// -------------------------------------------------------------------

// MainChangeLane

// optional .control.planning.MainChangeLane.Type type = 1;
inline bool MainChangeLane::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MainChangeLane::has_type() const {
  return _internal_has_type();
}
inline void MainChangeLane::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::control::planning::MainChangeLane_Type MainChangeLane::_internal_type() const {
  return static_cast< ::control::planning::MainChangeLane_Type >(type_);
}
inline ::control::planning::MainChangeLane_Type MainChangeLane::type() const {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.type)
  return _internal_type();
}
inline void MainChangeLane::_internal_set_type(::control::planning::MainChangeLane_Type value) {
  assert(::control::planning::MainChangeLane_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void MainChangeLane::set_type(::control::planning::MainChangeLane_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:control.planning.MainChangeLane.type)
}

// repeated .control.planning.TargetLane default_lane = 2;
inline int MainChangeLane::_internal_default_lane_size() const {
  return default_lane_.size();
}
inline int MainChangeLane::default_lane_size() const {
  return _internal_default_lane_size();
}
inline void MainChangeLane::clear_default_lane() {
  default_lane_.Clear();
}
inline ::control::planning::TargetLane* MainChangeLane::mutable_default_lane(int index) {
  // @@protoc_insertion_point(field_mutable:control.planning.MainChangeLane.default_lane)
  return default_lane_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >*
MainChangeLane::mutable_default_lane() {
  // @@protoc_insertion_point(field_mutable_list:control.planning.MainChangeLane.default_lane)
  return &default_lane_;
}
inline const ::control::planning::TargetLane& MainChangeLane::_internal_default_lane(int index) const {
  return default_lane_.Get(index);
}
inline const ::control::planning::TargetLane& MainChangeLane::default_lane(int index) const {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.default_lane)
  return _internal_default_lane(index);
}
inline ::control::planning::TargetLane* MainChangeLane::_internal_add_default_lane() {
  return default_lane_.Add();
}
inline ::control::planning::TargetLane* MainChangeLane::add_default_lane() {
  // @@protoc_insertion_point(field_add:control.planning.MainChangeLane.default_lane)
  return _internal_add_default_lane();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >&
MainChangeLane::default_lane() const {
  // @@protoc_insertion_point(field_list:control.planning.MainChangeLane.default_lane)
  return default_lane_;
}

// optional .control.planning.MainStop default_lane_stop = 3;
inline bool MainChangeLane::_internal_has_default_lane_stop() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || default_lane_stop_ != nullptr);
  return value;
}
inline bool MainChangeLane::has_default_lane_stop() const {
  return _internal_has_default_lane_stop();
}
inline void MainChangeLane::clear_default_lane_stop() {
  if (default_lane_stop_ != nullptr) default_lane_stop_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning::MainStop& MainChangeLane::_internal_default_lane_stop() const {
  const ::control::planning::MainStop* p = default_lane_stop_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::planning::MainStop*>(
      &::control::planning::_MainStop_default_instance_);
}
inline const ::control::planning::MainStop& MainChangeLane::default_lane_stop() const {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.default_lane_stop)
  return _internal_default_lane_stop();
}
inline void MainChangeLane::unsafe_arena_set_allocated_default_lane_stop(
    ::control::planning::MainStop* default_lane_stop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_lane_stop_);
  }
  default_lane_stop_ = default_lane_stop;
  if (default_lane_stop) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainChangeLane.default_lane_stop)
}
inline ::control::planning::MainStop* MainChangeLane::release_default_lane_stop() {
  auto temp = unsafe_arena_release_default_lane_stop();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::planning::MainStop* MainChangeLane::unsafe_arena_release_default_lane_stop() {
  // @@protoc_insertion_point(field_release:control.planning.MainChangeLane.default_lane_stop)
  _has_bits_[0] &= ~0x00000001u;
  ::control::planning::MainStop* temp = default_lane_stop_;
  default_lane_stop_ = nullptr;
  return temp;
}
inline ::control::planning::MainStop* MainChangeLane::_internal_mutable_default_lane_stop() {
  _has_bits_[0] |= 0x00000001u;
  if (default_lane_stop_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::planning::MainStop>(GetArena());
    default_lane_stop_ = p;
  }
  return default_lane_stop_;
}
inline ::control::planning::MainStop* MainChangeLane::mutable_default_lane_stop() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainChangeLane.default_lane_stop)
  return _internal_mutable_default_lane_stop();
}
inline void MainChangeLane::set_allocated_default_lane_stop(::control::planning::MainStop* default_lane_stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete default_lane_stop_;
  }
  if (default_lane_stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(default_lane_stop);
    if (message_arena != submessage_arena) {
      default_lane_stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_lane_stop, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  default_lane_stop_ = default_lane_stop;
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainChangeLane.default_lane_stop)
}

// optional .control.planning.MainStop target_lane_stop = 4;
inline bool MainChangeLane::_internal_has_target_lane_stop() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || target_lane_stop_ != nullptr);
  return value;
}
inline bool MainChangeLane::has_target_lane_stop() const {
  return _internal_has_target_lane_stop();
}
inline void MainChangeLane::clear_target_lane_stop() {
  if (target_lane_stop_ != nullptr) target_lane_stop_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning::MainStop& MainChangeLane::_internal_target_lane_stop() const {
  const ::control::planning::MainStop* p = target_lane_stop_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::planning::MainStop*>(
      &::control::planning::_MainStop_default_instance_);
}
inline const ::control::planning::MainStop& MainChangeLane::target_lane_stop() const {
  // @@protoc_insertion_point(field_get:control.planning.MainChangeLane.target_lane_stop)
  return _internal_target_lane_stop();
}
inline void MainChangeLane::unsafe_arena_set_allocated_target_lane_stop(
    ::control::planning::MainStop* target_lane_stop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_lane_stop_);
  }
  target_lane_stop_ = target_lane_stop;
  if (target_lane_stop) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainChangeLane.target_lane_stop)
}
inline ::control::planning::MainStop* MainChangeLane::release_target_lane_stop() {
  auto temp = unsafe_arena_release_target_lane_stop();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::planning::MainStop* MainChangeLane::unsafe_arena_release_target_lane_stop() {
  // @@protoc_insertion_point(field_release:control.planning.MainChangeLane.target_lane_stop)
  _has_bits_[0] &= ~0x00000002u;
  ::control::planning::MainStop* temp = target_lane_stop_;
  target_lane_stop_ = nullptr;
  return temp;
}
inline ::control::planning::MainStop* MainChangeLane::_internal_mutable_target_lane_stop() {
  _has_bits_[0] |= 0x00000002u;
  if (target_lane_stop_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::planning::MainStop>(GetArena());
    target_lane_stop_ = p;
  }
  return target_lane_stop_;
}
inline ::control::planning::MainStop* MainChangeLane::mutable_target_lane_stop() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainChangeLane.target_lane_stop)
  return _internal_mutable_target_lane_stop();
}
inline void MainChangeLane::set_allocated_target_lane_stop(::control::planning::MainStop* target_lane_stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_lane_stop_;
  }
  if (target_lane_stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target_lane_stop);
    if (message_arena != submessage_arena) {
      target_lane_stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_lane_stop, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  target_lane_stop_ = target_lane_stop;
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainChangeLane.target_lane_stop)
}

// -------------------------------------------------------------------

// MainMissionComplete

// optional .control.common.PointENU stop_point = 1;
inline bool MainMissionComplete::_internal_has_stop_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || stop_point_ != nullptr);
  return value;
}
inline bool MainMissionComplete::has_stop_point() const {
  return _internal_has_stop_point();
}
inline const ::control::common::PointENU& MainMissionComplete::_internal_stop_point() const {
  const ::control::common::PointENU* p = stop_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::PointENU*>(
      &::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& MainMissionComplete::stop_point() const {
  // @@protoc_insertion_point(field_get:control.planning.MainMissionComplete.stop_point)
  return _internal_stop_point();
}
inline void MainMissionComplete::unsafe_arena_set_allocated_stop_point(
    ::control::common::PointENU* stop_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  stop_point_ = stop_point;
  if (stop_point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainMissionComplete.stop_point)
}
inline ::control::common::PointENU* MainMissionComplete::release_stop_point() {
  auto temp = unsafe_arena_release_stop_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::PointENU* MainMissionComplete::unsafe_arena_release_stop_point() {
  // @@protoc_insertion_point(field_release:control.planning.MainMissionComplete.stop_point)
  _has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = stop_point_;
  stop_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* MainMissionComplete::_internal_mutable_stop_point() {
  _has_bits_[0] |= 0x00000001u;
  if (stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::PointENU>(GetArena());
    stop_point_ = p;
  }
  return stop_point_;
}
inline ::control::common::PointENU* MainMissionComplete::mutable_stop_point() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainMissionComplete.stop_point)
  return _internal_mutable_stop_point();
}
inline void MainMissionComplete::set_allocated_stop_point(::control::common::PointENU* stop_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  if (stop_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point)->GetArena();
    if (message_arena != submessage_arena) {
      stop_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainMissionComplete.stop_point)
}

// optional double stop_heading = 2;
inline bool MainMissionComplete::_internal_has_stop_heading() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MainMissionComplete::has_stop_heading() const {
  return _internal_has_stop_heading();
}
inline void MainMissionComplete::clear_stop_heading() {
  stop_heading_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double MainMissionComplete::_internal_stop_heading() const {
  return stop_heading_;
}
inline double MainMissionComplete::stop_heading() const {
  // @@protoc_insertion_point(field_get:control.planning.MainMissionComplete.stop_heading)
  return _internal_stop_heading();
}
inline void MainMissionComplete::_internal_set_stop_heading(double value) {
  _has_bits_[0] |= 0x00000002u;
  stop_heading_ = value;
}
inline void MainMissionComplete::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  // @@protoc_insertion_point(field_set:control.planning.MainMissionComplete.stop_heading)
}

// -------------------------------------------------------------------

// MainNotReady

// optional string reason = 1;
inline bool MainNotReady::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MainNotReady::has_reason() const {
  return _internal_has_reason();
}
inline void MainNotReady::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MainNotReady::reason() const {
  // @@protoc_insertion_point(field_get:control.planning.MainNotReady.reason)
  return _internal_reason();
}
inline void MainNotReady::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:control.planning.MainNotReady.reason)
}
inline std::string* MainNotReady::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainNotReady.reason)
  return _internal_mutable_reason();
}
inline const std::string& MainNotReady::_internal_reason() const {
  return reason_.Get();
}
inline void MainNotReady::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MainNotReady::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:control.planning.MainNotReady.reason)
}
inline void MainNotReady::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:control.planning.MainNotReady.reason)
}
inline void MainNotReady::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:control.planning.MainNotReady.reason)
}
inline std::string* MainNotReady::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MainNotReady::release_reason() {
  // @@protoc_insertion_point(field_release:control.planning.MainNotReady.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MainNotReady::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:control.planning.MainNotReady.reason)
}
inline std::string* MainNotReady::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainNotReady.reason)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MainNotReady::unsafe_arena_set_allocated_reason(
    std::string* reason) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reason, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainNotReady.reason)
}

// -------------------------------------------------------------------

// MainParking

// optional .control.planning.MainParking.ParkingStatus status = 1;
inline bool MainParking::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MainParking::has_status() const {
  return _internal_has_status();
}
inline void MainParking::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::control::planning::MainParking_ParkingStatus MainParking::_internal_status() const {
  return static_cast< ::control::planning::MainParking_ParkingStatus >(status_);
}
inline ::control::planning::MainParking_ParkingStatus MainParking::status() const {
  // @@protoc_insertion_point(field_get:control.planning.MainParking.status)
  return _internal_status();
}
inline void MainParking::_internal_set_status(::control::planning::MainParking_ParkingStatus value) {
  assert(::control::planning::MainParking_ParkingStatus_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void MainParking::set_status(::control::planning::MainParking_ParkingStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:control.planning.MainParking.status)
}

// -------------------------------------------------------------------

// MainDecision

// .control.planning.MainCruise cruise = 1;
inline bool MainDecision::_internal_has_cruise() const {
  return task_case() == kCruise;
}
inline bool MainDecision::has_cruise() const {
  return _internal_has_cruise();
}
inline void MainDecision::set_has_cruise() {
  _oneof_case_[0] = kCruise;
}
inline void MainDecision::clear_cruise() {
  if (_internal_has_cruise()) {
    if (GetArena() == nullptr) {
      delete task_.cruise_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainCruise* MainDecision::release_cruise() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.cruise)
  if (_internal_has_cruise()) {
    clear_has_task();
      ::control::planning::MainCruise* temp = task_.cruise_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.cruise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainCruise& MainDecision::_internal_cruise() const {
  return _internal_has_cruise()
      ? *task_.cruise_
      : *reinterpret_cast< ::control::planning::MainCruise*>(&::control::planning::_MainCruise_default_instance_);
}
inline const ::control::planning::MainCruise& MainDecision::cruise() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.cruise)
  return _internal_cruise();
}
inline ::control::planning::MainCruise* MainDecision::unsafe_arena_release_cruise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.cruise)
  if (_internal_has_cruise()) {
    clear_has_task();
    ::control::planning::MainCruise* temp = task_.cruise_;
    task_.cruise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_cruise(::control::planning::MainCruise* cruise) {
  clear_task();
  if (cruise) {
    set_has_cruise();
    task_.cruise_ = cruise;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.cruise)
}
inline ::control::planning::MainCruise* MainDecision::_internal_mutable_cruise() {
  if (!_internal_has_cruise()) {
    clear_task();
    set_has_cruise();
    task_.cruise_ = CreateMaybeMessage< ::control::planning::MainCruise >(GetArena());
  }
  return task_.cruise_;
}
inline ::control::planning::MainCruise* MainDecision::mutable_cruise() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.cruise)
  return _internal_mutable_cruise();
}

// .control.planning.MainStop stop = 2;
inline bool MainDecision::_internal_has_stop() const {
  return task_case() == kStop;
}
inline bool MainDecision::has_stop() const {
  return _internal_has_stop();
}
inline void MainDecision::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void MainDecision::clear_stop() {
  if (_internal_has_stop()) {
    if (GetArena() == nullptr) {
      delete task_.stop_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainStop* MainDecision::release_stop() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.stop)
  if (_internal_has_stop()) {
    clear_has_task();
      ::control::planning::MainStop* temp = task_.stop_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainStop& MainDecision::_internal_stop() const {
  return _internal_has_stop()
      ? *task_.stop_
      : *reinterpret_cast< ::control::planning::MainStop*>(&::control::planning::_MainStop_default_instance_);
}
inline const ::control::planning::MainStop& MainDecision::stop() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.stop)
  return _internal_stop();
}
inline ::control::planning::MainStop* MainDecision::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.stop)
  if (_internal_has_stop()) {
    clear_has_task();
    ::control::planning::MainStop* temp = task_.stop_;
    task_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_stop(::control::planning::MainStop* stop) {
  clear_task();
  if (stop) {
    set_has_stop();
    task_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.stop)
}
inline ::control::planning::MainStop* MainDecision::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_task();
    set_has_stop();
    task_.stop_ = CreateMaybeMessage< ::control::planning::MainStop >(GetArena());
  }
  return task_.stop_;
}
inline ::control::planning::MainStop* MainDecision::mutable_stop() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.stop)
  return _internal_mutable_stop();
}

// .control.planning.MainEmergencyStop estop = 3;
inline bool MainDecision::_internal_has_estop() const {
  return task_case() == kEstop;
}
inline bool MainDecision::has_estop() const {
  return _internal_has_estop();
}
inline void MainDecision::set_has_estop() {
  _oneof_case_[0] = kEstop;
}
inline void MainDecision::clear_estop() {
  if (_internal_has_estop()) {
    if (GetArena() == nullptr) {
      delete task_.estop_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainEmergencyStop* MainDecision::release_estop() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.estop)
  if (_internal_has_estop()) {
    clear_has_task();
      ::control::planning::MainEmergencyStop* temp = task_.estop_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.estop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainEmergencyStop& MainDecision::_internal_estop() const {
  return _internal_has_estop()
      ? *task_.estop_
      : *reinterpret_cast< ::control::planning::MainEmergencyStop*>(&::control::planning::_MainEmergencyStop_default_instance_);
}
inline const ::control::planning::MainEmergencyStop& MainDecision::estop() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.estop)
  return _internal_estop();
}
inline ::control::planning::MainEmergencyStop* MainDecision::unsafe_arena_release_estop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.estop)
  if (_internal_has_estop()) {
    clear_has_task();
    ::control::planning::MainEmergencyStop* temp = task_.estop_;
    task_.estop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_estop(::control::planning::MainEmergencyStop* estop) {
  clear_task();
  if (estop) {
    set_has_estop();
    task_.estop_ = estop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.estop)
}
inline ::control::planning::MainEmergencyStop* MainDecision::_internal_mutable_estop() {
  if (!_internal_has_estop()) {
    clear_task();
    set_has_estop();
    task_.estop_ = CreateMaybeMessage< ::control::planning::MainEmergencyStop >(GetArena());
  }
  return task_.estop_;
}
inline ::control::planning::MainEmergencyStop* MainDecision::mutable_estop() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.estop)
  return _internal_mutable_estop();
}

// .control.planning.MainChangeLane change_lane = 4 [deprecated = true];
inline bool MainDecision::_internal_has_change_lane() const {
  return task_case() == kChangeLane;
}
inline bool MainDecision::has_change_lane() const {
  return _internal_has_change_lane();
}
inline void MainDecision::set_has_change_lane() {
  _oneof_case_[0] = kChangeLane;
}
inline void MainDecision::clear_change_lane() {
  if (_internal_has_change_lane()) {
    if (GetArena() == nullptr) {
      delete task_.change_lane_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainChangeLane* MainDecision::release_change_lane() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.change_lane)
  if (_internal_has_change_lane()) {
    clear_has_task();
      ::control::planning::MainChangeLane* temp = task_.change_lane_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainChangeLane& MainDecision::_internal_change_lane() const {
  return _internal_has_change_lane()
      ? *task_.change_lane_
      : *reinterpret_cast< ::control::planning::MainChangeLane*>(&::control::planning::_MainChangeLane_default_instance_);
}
inline const ::control::planning::MainChangeLane& MainDecision::change_lane() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.change_lane)
  return _internal_change_lane();
}
inline ::control::planning::MainChangeLane* MainDecision::unsafe_arena_release_change_lane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.change_lane)
  if (_internal_has_change_lane()) {
    clear_has_task();
    ::control::planning::MainChangeLane* temp = task_.change_lane_;
    task_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_change_lane(::control::planning::MainChangeLane* change_lane) {
  clear_task();
  if (change_lane) {
    set_has_change_lane();
    task_.change_lane_ = change_lane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.change_lane)
}
inline ::control::planning::MainChangeLane* MainDecision::_internal_mutable_change_lane() {
  if (!_internal_has_change_lane()) {
    clear_task();
    set_has_change_lane();
    task_.change_lane_ = CreateMaybeMessage< ::control::planning::MainChangeLane >(GetArena());
  }
  return task_.change_lane_;
}
inline ::control::planning::MainChangeLane* MainDecision::mutable_change_lane() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.change_lane)
  return _internal_mutable_change_lane();
}

// .control.planning.MainMissionComplete mission_complete = 6;
inline bool MainDecision::_internal_has_mission_complete() const {
  return task_case() == kMissionComplete;
}
inline bool MainDecision::has_mission_complete() const {
  return _internal_has_mission_complete();
}
inline void MainDecision::set_has_mission_complete() {
  _oneof_case_[0] = kMissionComplete;
}
inline void MainDecision::clear_mission_complete() {
  if (_internal_has_mission_complete()) {
    if (GetArena() == nullptr) {
      delete task_.mission_complete_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainMissionComplete* MainDecision::release_mission_complete() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.mission_complete)
  if (_internal_has_mission_complete()) {
    clear_has_task();
      ::control::planning::MainMissionComplete* temp = task_.mission_complete_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.mission_complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainMissionComplete& MainDecision::_internal_mission_complete() const {
  return _internal_has_mission_complete()
      ? *task_.mission_complete_
      : *reinterpret_cast< ::control::planning::MainMissionComplete*>(&::control::planning::_MainMissionComplete_default_instance_);
}
inline const ::control::planning::MainMissionComplete& MainDecision::mission_complete() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.mission_complete)
  return _internal_mission_complete();
}
inline ::control::planning::MainMissionComplete* MainDecision::unsafe_arena_release_mission_complete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.mission_complete)
  if (_internal_has_mission_complete()) {
    clear_has_task();
    ::control::planning::MainMissionComplete* temp = task_.mission_complete_;
    task_.mission_complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_mission_complete(::control::planning::MainMissionComplete* mission_complete) {
  clear_task();
  if (mission_complete) {
    set_has_mission_complete();
    task_.mission_complete_ = mission_complete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.mission_complete)
}
inline ::control::planning::MainMissionComplete* MainDecision::_internal_mutable_mission_complete() {
  if (!_internal_has_mission_complete()) {
    clear_task();
    set_has_mission_complete();
    task_.mission_complete_ = CreateMaybeMessage< ::control::planning::MainMissionComplete >(GetArena());
  }
  return task_.mission_complete_;
}
inline ::control::planning::MainMissionComplete* MainDecision::mutable_mission_complete() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.mission_complete)
  return _internal_mutable_mission_complete();
}

// .control.planning.MainNotReady not_ready = 7;
inline bool MainDecision::_internal_has_not_ready() const {
  return task_case() == kNotReady;
}
inline bool MainDecision::has_not_ready() const {
  return _internal_has_not_ready();
}
inline void MainDecision::set_has_not_ready() {
  _oneof_case_[0] = kNotReady;
}
inline void MainDecision::clear_not_ready() {
  if (_internal_has_not_ready()) {
    if (GetArena() == nullptr) {
      delete task_.not_ready_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainNotReady* MainDecision::release_not_ready() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.not_ready)
  if (_internal_has_not_ready()) {
    clear_has_task();
      ::control::planning::MainNotReady* temp = task_.not_ready_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.not_ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainNotReady& MainDecision::_internal_not_ready() const {
  return _internal_has_not_ready()
      ? *task_.not_ready_
      : *reinterpret_cast< ::control::planning::MainNotReady*>(&::control::planning::_MainNotReady_default_instance_);
}
inline const ::control::planning::MainNotReady& MainDecision::not_ready() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.not_ready)
  return _internal_not_ready();
}
inline ::control::planning::MainNotReady* MainDecision::unsafe_arena_release_not_ready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.not_ready)
  if (_internal_has_not_ready()) {
    clear_has_task();
    ::control::planning::MainNotReady* temp = task_.not_ready_;
    task_.not_ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_not_ready(::control::planning::MainNotReady* not_ready) {
  clear_task();
  if (not_ready) {
    set_has_not_ready();
    task_.not_ready_ = not_ready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.not_ready)
}
inline ::control::planning::MainNotReady* MainDecision::_internal_mutable_not_ready() {
  if (!_internal_has_not_ready()) {
    clear_task();
    set_has_not_ready();
    task_.not_ready_ = CreateMaybeMessage< ::control::planning::MainNotReady >(GetArena());
  }
  return task_.not_ready_;
}
inline ::control::planning::MainNotReady* MainDecision::mutable_not_ready() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.not_ready)
  return _internal_mutable_not_ready();
}

// .control.planning.MainParking parking = 8;
inline bool MainDecision::_internal_has_parking() const {
  return task_case() == kParking;
}
inline bool MainDecision::has_parking() const {
  return _internal_has_parking();
}
inline void MainDecision::set_has_parking() {
  _oneof_case_[0] = kParking;
}
inline void MainDecision::clear_parking() {
  if (_internal_has_parking()) {
    if (GetArena() == nullptr) {
      delete task_.parking_;
    }
    clear_has_task();
  }
}
inline ::control::planning::MainParking* MainDecision::release_parking() {
  // @@protoc_insertion_point(field_release:control.planning.MainDecision.parking)
  if (_internal_has_parking()) {
    clear_has_task();
      ::control::planning::MainParking* temp = task_.parking_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    task_.parking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::control::planning::MainParking& MainDecision::_internal_parking() const {
  return _internal_has_parking()
      ? *task_.parking_
      : *reinterpret_cast< ::control::planning::MainParking*>(&::control::planning::_MainParking_default_instance_);
}
inline const ::control::planning::MainParking& MainDecision::parking() const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.parking)
  return _internal_parking();
}
inline ::control::planning::MainParking* MainDecision::unsafe_arena_release_parking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:control.planning.MainDecision.parking)
  if (_internal_has_parking()) {
    clear_has_task();
    ::control::planning::MainParking* temp = task_.parking_;
    task_.parking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MainDecision::unsafe_arena_set_allocated_parking(::control::planning::MainParking* parking) {
  clear_task();
  if (parking) {
    set_has_parking();
    task_.parking_ = parking;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.MainDecision.parking)
}
inline ::control::planning::MainParking* MainDecision::_internal_mutable_parking() {
  if (!_internal_has_parking()) {
    clear_task();
    set_has_parking();
    task_.parking_ = CreateMaybeMessage< ::control::planning::MainParking >(GetArena());
  }
  return task_.parking_;
}
inline ::control::planning::MainParking* MainDecision::mutable_parking() {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.parking)
  return _internal_mutable_parking();
}

// repeated .control.planning.TargetLane target_lane = 5 [deprecated = true];
inline int MainDecision::_internal_target_lane_size() const {
  return target_lane_.size();
}
inline int MainDecision::target_lane_size() const {
  return _internal_target_lane_size();
}
inline void MainDecision::clear_target_lane() {
  target_lane_.Clear();
}
inline ::control::planning::TargetLane* MainDecision::mutable_target_lane(int index) {
  // @@protoc_insertion_point(field_mutable:control.planning.MainDecision.target_lane)
  return target_lane_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >*
MainDecision::mutable_target_lane() {
  // @@protoc_insertion_point(field_mutable_list:control.planning.MainDecision.target_lane)
  return &target_lane_;
}
inline const ::control::planning::TargetLane& MainDecision::_internal_target_lane(int index) const {
  return target_lane_.Get(index);
}
inline const ::control::planning::TargetLane& MainDecision::target_lane(int index) const {
  // @@protoc_insertion_point(field_get:control.planning.MainDecision.target_lane)
  return _internal_target_lane(index);
}
inline ::control::planning::TargetLane* MainDecision::_internal_add_target_lane() {
  return target_lane_.Add();
}
inline ::control::planning::TargetLane* MainDecision::add_target_lane() {
  // @@protoc_insertion_point(field_add:control.planning.MainDecision.target_lane)
  return _internal_add_target_lane();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::control::planning::TargetLane >&
MainDecision::target_lane() const {
  // @@protoc_insertion_point(field_list:control.planning.MainDecision.target_lane)
  return target_lane_;
}

inline bool MainDecision::has_task() const {
  return task_case() != TASK_NOT_SET;
}
inline void MainDecision::clear_has_task() {
  _oneof_case_[0] = TASK_NOT_SET;
}
inline MainDecision::TaskCase MainDecision::task_case() const {
  return MainDecision::TaskCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DecisionResult

// optional .control.planning.MainDecision main_decision = 1;
inline bool DecisionResult::_internal_has_main_decision() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || main_decision_ != nullptr);
  return value;
}
inline bool DecisionResult::has_main_decision() const {
  return _internal_has_main_decision();
}
inline void DecisionResult::clear_main_decision() {
  if (main_decision_ != nullptr) main_decision_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning::MainDecision& DecisionResult::_internal_main_decision() const {
  const ::control::planning::MainDecision* p = main_decision_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::planning::MainDecision*>(
      &::control::planning::_MainDecision_default_instance_);
}
inline const ::control::planning::MainDecision& DecisionResult::main_decision() const {
  // @@protoc_insertion_point(field_get:control.planning.DecisionResult.main_decision)
  return _internal_main_decision();
}
inline void DecisionResult::unsafe_arena_set_allocated_main_decision(
    ::control::planning::MainDecision* main_decision) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(main_decision_);
  }
  main_decision_ = main_decision;
  if (main_decision) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.DecisionResult.main_decision)
}
inline ::control::planning::MainDecision* DecisionResult::release_main_decision() {
  auto temp = unsafe_arena_release_main_decision();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::planning::MainDecision* DecisionResult::unsafe_arena_release_main_decision() {
  // @@protoc_insertion_point(field_release:control.planning.DecisionResult.main_decision)
  _has_bits_[0] &= ~0x00000001u;
  ::control::planning::MainDecision* temp = main_decision_;
  main_decision_ = nullptr;
  return temp;
}
inline ::control::planning::MainDecision* DecisionResult::_internal_mutable_main_decision() {
  _has_bits_[0] |= 0x00000001u;
  if (main_decision_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::planning::MainDecision>(GetArena());
    main_decision_ = p;
  }
  return main_decision_;
}
inline ::control::planning::MainDecision* DecisionResult::mutable_main_decision() {
  // @@protoc_insertion_point(field_mutable:control.planning.DecisionResult.main_decision)
  return _internal_mutable_main_decision();
}
inline void DecisionResult::set_allocated_main_decision(::control::planning::MainDecision* main_decision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete main_decision_;
  }
  if (main_decision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(main_decision);
    if (message_arena != submessage_arena) {
      main_decision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main_decision, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  main_decision_ = main_decision;
  // @@protoc_insertion_point(field_set_allocated:control.planning.DecisionResult.main_decision)
}

// optional .control.planning.ObjectDecisions object_decision = 2;
inline bool DecisionResult::_internal_has_object_decision() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || object_decision_ != nullptr);
  return value;
}
inline bool DecisionResult::has_object_decision() const {
  return _internal_has_object_decision();
}
inline void DecisionResult::clear_object_decision() {
  if (object_decision_ != nullptr) object_decision_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning::ObjectDecisions& DecisionResult::_internal_object_decision() const {
  const ::control::planning::ObjectDecisions* p = object_decision_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::planning::ObjectDecisions*>(
      &::control::planning::_ObjectDecisions_default_instance_);
}
inline const ::control::planning::ObjectDecisions& DecisionResult::object_decision() const {
  // @@protoc_insertion_point(field_get:control.planning.DecisionResult.object_decision)
  return _internal_object_decision();
}
inline void DecisionResult::unsafe_arena_set_allocated_object_decision(
    ::control::planning::ObjectDecisions* object_decision) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_decision_);
  }
  object_decision_ = object_decision;
  if (object_decision) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.DecisionResult.object_decision)
}
inline ::control::planning::ObjectDecisions* DecisionResult::release_object_decision() {
  auto temp = unsafe_arena_release_object_decision();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::planning::ObjectDecisions* DecisionResult::unsafe_arena_release_object_decision() {
  // @@protoc_insertion_point(field_release:control.planning.DecisionResult.object_decision)
  _has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisions* temp = object_decision_;
  object_decision_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectDecisions* DecisionResult::_internal_mutable_object_decision() {
  _has_bits_[0] |= 0x00000002u;
  if (object_decision_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::planning::ObjectDecisions>(GetArena());
    object_decision_ = p;
  }
  return object_decision_;
}
inline ::control::planning::ObjectDecisions* DecisionResult::mutable_object_decision() {
  // @@protoc_insertion_point(field_mutable:control.planning.DecisionResult.object_decision)
  return _internal_mutable_object_decision();
}
inline void DecisionResult::set_allocated_object_decision(::control::planning::ObjectDecisions* object_decision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete object_decision_;
  }
  if (object_decision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(object_decision);
    if (message_arena != submessage_arena) {
      object_decision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_decision, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  object_decision_ = object_decision;
  // @@protoc_insertion_point(field_set_allocated:control.planning.DecisionResult.object_decision)
}

// optional .control.common.VehicleSignal vehicle_signal = 3;
inline bool DecisionResult::_internal_has_vehicle_signal() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || vehicle_signal_ != nullptr);
  return value;
}
inline bool DecisionResult::has_vehicle_signal() const {
  return _internal_has_vehicle_signal();
}
inline const ::control::common::VehicleSignal& DecisionResult::_internal_vehicle_signal() const {
  const ::control::common::VehicleSignal* p = vehicle_signal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::control::common::VehicleSignal*>(
      &::control::common::_VehicleSignal_default_instance_);
}
inline const ::control::common::VehicleSignal& DecisionResult::vehicle_signal() const {
  // @@protoc_insertion_point(field_get:control.planning.DecisionResult.vehicle_signal)
  return _internal_vehicle_signal();
}
inline void DecisionResult::unsafe_arena_set_allocated_vehicle_signal(
    ::control::common::VehicleSignal* vehicle_signal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_signal_);
  }
  vehicle_signal_ = vehicle_signal;
  if (vehicle_signal) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning.DecisionResult.vehicle_signal)
}
inline ::control::common::VehicleSignal* DecisionResult::release_vehicle_signal() {
  auto temp = unsafe_arena_release_vehicle_signal();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::control::common::VehicleSignal* DecisionResult::unsafe_arena_release_vehicle_signal() {
  // @@protoc_insertion_point(field_release:control.planning.DecisionResult.vehicle_signal)
  _has_bits_[0] &= ~0x00000004u;
  ::control::common::VehicleSignal* temp = vehicle_signal_;
  vehicle_signal_ = nullptr;
  return temp;
}
inline ::control::common::VehicleSignal* DecisionResult::_internal_mutable_vehicle_signal() {
  _has_bits_[0] |= 0x00000004u;
  if (vehicle_signal_ == nullptr) {
    auto* p = CreateMaybeMessage<::control::common::VehicleSignal>(GetArena());
    vehicle_signal_ = p;
  }
  return vehicle_signal_;
}
inline ::control::common::VehicleSignal* DecisionResult::mutable_vehicle_signal() {
  // @@protoc_insertion_point(field_mutable:control.planning.DecisionResult.vehicle_signal)
  return _internal_mutable_vehicle_signal();
}
inline void DecisionResult::set_allocated_vehicle_signal(::control::common::VehicleSignal* vehicle_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_signal_);
  }
  if (vehicle_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_signal)->GetArena();
    if (message_arena != submessage_arena) {
      vehicle_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_signal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  vehicle_signal_ = vehicle_signal;
  // @@protoc_insertion_point(field_set_allocated:control.planning.DecisionResult.vehicle_signal)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace control

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::control::planning::ObjectNudge_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::control::planning::ObjectNudge_Type>() {
  return ::control::planning::ObjectNudge_Type_descriptor();
}
template <> struct is_proto_enum< ::control::planning::ObjectSidePass_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::control::planning::ObjectSidePass_Type>() {
  return ::control::planning::ObjectSidePass_Type_descriptor();
}
template <> struct is_proto_enum< ::control::planning::MainEmergencyStop_ReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::control::planning::MainEmergencyStop_ReasonCode>() {
  return ::control::planning::MainEmergencyStop_ReasonCode_descriptor();
}
template <> struct is_proto_enum< ::control::planning::MainChangeLane_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::control::planning::MainChangeLane_Type>() {
  return ::control::planning::MainChangeLane_Type_descriptor();
}
template <> struct is_proto_enum< ::control::planning::MainParking_ParkingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::control::planning::MainParking_ParkingStatus>() {
  return ::control::planning::MainParking_ParkingStatus_descriptor();
}
template <> struct is_proto_enum< ::control::planning::StopReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::control::planning::StopReasonCode>() {
  return ::control::planning::StopReasonCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fdecision_2eproto
