// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: planning_msgs/planning_internal.proto
// Protobuf C++ Version: 5.28.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fplanning_5finternal_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fplanning_5finternal_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common_msgs/basic_msgs/geometry.pb.h"
#include "common_msgs/basic_msgs/header.pb.h"
#include "common_msgs/basic_msgs/pnc_point.pb.h"
#include "common_msgs/chassis_msgs/chassis.pb.h"
#include "localization_msgs/localization.pb.h"
#include "planning_msgs/decision.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_planning_5fmsgs_2fplanning_5finternal_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_planning_5fmsgs_2fplanning_5finternal_2eproto;
namespace control {
namespace planning_internal {
class AutoTuningTrainingData;
struct AutoTuningTrainingDataDefaultTypeInternal;
extern AutoTuningTrainingDataDefaultTypeInternal _AutoTuningTrainingData_default_instance_;
class CloudReferenceLineResponse;
struct CloudReferenceLineResponseDefaultTypeInternal;
extern CloudReferenceLineResponseDefaultTypeInternal _CloudReferenceLineResponse_default_instance_;
class CostComponents;
struct CostComponentsDefaultTypeInternal;
extern CostComponentsDefaultTypeInternal _CostComponents_default_instance_;
class Debug;
struct DebugDefaultTypeInternal;
extern DebugDefaultTypeInternal _Debug_default_instance_;
class DecisionTag;
struct DecisionTagDefaultTypeInternal;
extern DecisionTagDefaultTypeInternal _DecisionTag_default_instance_;
class DpPolyGraphDebug;
struct DpPolyGraphDebugDefaultTypeInternal;
extern DpPolyGraphDebugDefaultTypeInternal _DpPolyGraphDebug_default_instance_;
class HybridModelDebug;
struct HybridModelDebugDefaultTypeInternal;
extern HybridModelDebugDefaultTypeInternal _HybridModelDebug_default_instance_;
class LatticeStPixel;
struct LatticeStPixelDefaultTypeInternal;
extern LatticeStPixelDefaultTypeInternal _LatticeStPixel_default_instance_;
class LatticeStTraining;
struct LatticeStTrainingDefaultTypeInternal;
extern LatticeStTrainingDefaultTypeInternal _LatticeStTraining_default_instance_;
class ObstacleDebug;
struct ObstacleDebugDefaultTypeInternal;
extern ObstacleDebugDefaultTypeInternal _ObstacleDebug_default_instance_;
class OpenSpaceDebug;
struct OpenSpaceDebugDefaultTypeInternal;
extern OpenSpaceDebugDefaultTypeInternal _OpenSpaceDebug_default_instance_;
class PlanningData;
struct PlanningDataDefaultTypeInternal;
extern PlanningDataDefaultTypeInternal _PlanningData_default_instance_;
class PullOverDebug;
struct PullOverDebugDefaultTypeInternal;
extern PullOverDebugDefaultTypeInternal _PullOverDebug_default_instance_;
class ReferenceLineDebug;
struct ReferenceLineDebugDefaultTypeInternal;
extern ReferenceLineDebugDefaultTypeInternal _ReferenceLineDebug_default_instance_;
class SLFrameDebug;
struct SLFrameDebugDefaultTypeInternal;
extern SLFrameDebugDefaultTypeInternal _SLFrameDebug_default_instance_;
class STGraphDebug;
struct STGraphDebugDefaultTypeInternal;
extern STGraphDebugDefaultTypeInternal _STGraphDebug_default_instance_;
class STGraphDebug_STGraphKernelCuiseRef;
struct STGraphDebug_STGraphKernelCuiseRefDefaultTypeInternal;
extern STGraphDebug_STGraphKernelCuiseRefDefaultTypeInternal _STGraphDebug_STGraphKernelCuiseRef_default_instance_;
class STGraphDebug_STGraphKernelFollowRef;
struct STGraphDebug_STGraphKernelFollowRefDefaultTypeInternal;
extern STGraphDebug_STGraphKernelFollowRefDefaultTypeInternal _STGraphDebug_STGraphKernelFollowRef_default_instance_;
class STGraphDebug_STGraphSpeedConstraint;
struct STGraphDebug_STGraphSpeedConstraintDefaultTypeInternal;
extern STGraphDebug_STGraphSpeedConstraintDefaultTypeInternal _STGraphDebug_STGraphSpeedConstraint_default_instance_;
class SampleLayerDebug;
struct SampleLayerDebugDefaultTypeInternal;
extern SampleLayerDebugDefaultTypeInternal _SampleLayerDebug_default_instance_;
class ScenarioDebug;
struct ScenarioDebugDefaultTypeInternal;
extern ScenarioDebugDefaultTypeInternal _ScenarioDebug_default_instance_;
class SmootherDebug;
struct SmootherDebugDefaultTypeInternal;
extern SmootherDebugDefaultTypeInternal _SmootherDebug_default_instance_;
class SpeedPlan;
struct SpeedPlanDefaultTypeInternal;
extern SpeedPlanDefaultTypeInternal _SpeedPlan_default_instance_;
class StGraphBoundaryDebug;
struct StGraphBoundaryDebugDefaultTypeInternal;
extern StGraphBoundaryDebugDefaultTypeInternal _StGraphBoundaryDebug_default_instance_;
class Trajectories;
struct TrajectoriesDefaultTypeInternal;
extern TrajectoriesDefaultTypeInternal _Trajectories_default_instance_;
}  // namespace planning_internal
}  // namespace control
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace control {
namespace planning_internal {
enum StGraphBoundaryDebug_StBoundaryType : int {
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_UNKNOWN = 1,
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_STOP = 2,
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_FOLLOW = 3,
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_YIELD = 4,
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_OVERTAKE = 5,
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_KEEP_CLEAR = 6,
  StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_DRIVABLE_REGION = 7,
};

bool StGraphBoundaryDebug_StBoundaryType_IsValid(int value);
extern const uint32_t StGraphBoundaryDebug_StBoundaryType_internal_data_[];
constexpr StGraphBoundaryDebug_StBoundaryType StGraphBoundaryDebug_StBoundaryType_StBoundaryType_MIN = static_cast<StGraphBoundaryDebug_StBoundaryType>(1);
constexpr StGraphBoundaryDebug_StBoundaryType StGraphBoundaryDebug_StBoundaryType_StBoundaryType_MAX = static_cast<StGraphBoundaryDebug_StBoundaryType>(7);
constexpr int StGraphBoundaryDebug_StBoundaryType_StBoundaryType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
StGraphBoundaryDebug_StBoundaryType_descriptor();
template <typename T>
const std::string& StGraphBoundaryDebug_StBoundaryType_Name(T value) {
  static_assert(std::is_same<T, StGraphBoundaryDebug_StBoundaryType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StBoundaryType_Name().");
  return StGraphBoundaryDebug_StBoundaryType_Name(static_cast<StGraphBoundaryDebug_StBoundaryType>(value));
}
template <>
inline const std::string& StGraphBoundaryDebug_StBoundaryType_Name(StGraphBoundaryDebug_StBoundaryType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StGraphBoundaryDebug_StBoundaryType_descriptor,
                                                 1, 7>(
      static_cast<int>(value));
}
inline bool StGraphBoundaryDebug_StBoundaryType_Parse(absl::string_view name, StGraphBoundaryDebug_StBoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StGraphBoundaryDebug_StBoundaryType>(
      StGraphBoundaryDebug_StBoundaryType_descriptor(), name, value);
}
enum SmootherDebug_SmootherType : int {
  SmootherDebug_SmootherType_SMOOTHER_NONE = 1,
  SmootherDebug_SmootherType_SMOOTHER_CLOSE_STOP = 2,
};

bool SmootherDebug_SmootherType_IsValid(int value);
extern const uint32_t SmootherDebug_SmootherType_internal_data_[];
constexpr SmootherDebug_SmootherType SmootherDebug_SmootherType_SmootherType_MIN = static_cast<SmootherDebug_SmootherType>(1);
constexpr SmootherDebug_SmootherType SmootherDebug_SmootherType_SmootherType_MAX = static_cast<SmootherDebug_SmootherType>(2);
constexpr int SmootherDebug_SmootherType_SmootherType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SmootherDebug_SmootherType_descriptor();
template <typename T>
const std::string& SmootherDebug_SmootherType_Name(T value) {
  static_assert(std::is_same<T, SmootherDebug_SmootherType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SmootherType_Name().");
  return SmootherDebug_SmootherType_Name(static_cast<SmootherDebug_SmootherType>(value));
}
template <>
inline const std::string& SmootherDebug_SmootherType_Name(SmootherDebug_SmootherType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SmootherDebug_SmootherType_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool SmootherDebug_SmootherType_Parse(absl::string_view name, SmootherDebug_SmootherType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmootherDebug_SmootherType>(
      SmootherDebug_SmootherType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SmootherDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.SmootherDebug) */ {
 public:
  inline SmootherDebug() : SmootherDebug(nullptr) {}
  ~SmootherDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SmootherDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline SmootherDebug(const SmootherDebug& from) : SmootherDebug(nullptr, from) {}
  inline SmootherDebug(SmootherDebug&& from) noexcept
      : SmootherDebug(nullptr, std::move(from)) {}
  inline SmootherDebug& operator=(const SmootherDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmootherDebug& operator=(SmootherDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmootherDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmootherDebug* internal_default_instance() {
    return reinterpret_cast<const SmootherDebug*>(
        &_SmootherDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SmootherDebug& a, SmootherDebug& b) { a.Swap(&b); }
  inline void Swap(SmootherDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmootherDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmootherDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SmootherDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SmootherDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SmootherDebug& from) { SmootherDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SmootherDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.SmootherDebug"; }

 protected:
  explicit SmootherDebug(::google::protobuf::Arena* arena);
  SmootherDebug(::google::protobuf::Arena* arena, const SmootherDebug& from);
  SmootherDebug(::google::protobuf::Arena* arena, SmootherDebug&& from) noexcept
      : SmootherDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using SmootherType = SmootherDebug_SmootherType;
  static constexpr SmootherType SMOOTHER_NONE = SmootherDebug_SmootherType_SMOOTHER_NONE;
  static constexpr SmootherType SMOOTHER_CLOSE_STOP = SmootherDebug_SmootherType_SMOOTHER_CLOSE_STOP;
  static inline bool SmootherType_IsValid(int value) {
    return SmootherDebug_SmootherType_IsValid(value);
  }
  static constexpr SmootherType SmootherType_MIN = SmootherDebug_SmootherType_SmootherType_MIN;
  static constexpr SmootherType SmootherType_MAX = SmootherDebug_SmootherType_SmootherType_MAX;
  static constexpr int SmootherType_ARRAYSIZE = SmootherDebug_SmootherType_SmootherType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SmootherType_descriptor() {
    return SmootherDebug_SmootherType_descriptor();
  }
  template <typename T>
  static inline const std::string& SmootherType_Name(T value) {
    return SmootherDebug_SmootherType_Name(value);
  }
  static inline bool SmootherType_Parse(absl::string_view name, SmootherType* value) {
    return SmootherDebug_SmootherType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 3,
    kIsSmoothedFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string reason = 3;
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // optional bool is_smoothed = 1;
  bool has_is_smoothed() const;
  void clear_is_smoothed() ;
  bool is_smoothed() const;
  void set_is_smoothed(bool value);

  private:
  bool _internal_is_smoothed() const;
  void _internal_set_is_smoothed(bool value);

  public:
  // optional .control.planning_internal.SmootherDebug.SmootherType type = 2 [default = SMOOTHER_NONE];
  bool has_type() const;
  void clear_type() ;
  ::control::planning_internal::SmootherDebug_SmootherType type() const;
  void set_type(::control::planning_internal::SmootherDebug_SmootherType value);

  private:
  ::control::planning_internal::SmootherDebug_SmootherType _internal_type() const;
  void _internal_set_type(::control::planning_internal::SmootherDebug_SmootherType value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.SmootherDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      54, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SmootherDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SmootherDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    bool is_smoothed_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class ScenarioDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.ScenarioDebug) */ {
 public:
  inline ScenarioDebug() : ScenarioDebug(nullptr) {}
  ~ScenarioDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScenarioDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline ScenarioDebug(const ScenarioDebug& from) : ScenarioDebug(nullptr, from) {}
  inline ScenarioDebug(ScenarioDebug&& from) noexcept
      : ScenarioDebug(nullptr, std::move(from)) {}
  inline ScenarioDebug& operator=(const ScenarioDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioDebug& operator=(ScenarioDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScenarioDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScenarioDebug* internal_default_instance() {
    return reinterpret_cast<const ScenarioDebug*>(
        &_ScenarioDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ScenarioDebug& a, ScenarioDebug& b) { a.Swap(&b); }
  inline void Swap(ScenarioDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScenarioDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ScenarioDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScenarioDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScenarioDebug& from) { ScenarioDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ScenarioDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.ScenarioDebug"; }

 protected:
  explicit ScenarioDebug(::google::protobuf::Arena* arena);
  ScenarioDebug(::google::protobuf::Arena* arena, const ScenarioDebug& from);
  ScenarioDebug(::google::protobuf::Arena* arena, ScenarioDebug&& from) noexcept
      : ScenarioDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgFieldNumber = 3,
    kScenarioPluginTypeFieldNumber = 4,
    kStagePluginTypeFieldNumber = 5,
    kScenarioTypeFieldNumber = 1,
    kStageTypeFieldNumber = 2,
  };
  // optional string msg = 3;
  bool has_msg() const;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // optional string scenario_plugin_type = 4;
  bool has_scenario_plugin_type() const;
  void clear_scenario_plugin_type() ;
  const std::string& scenario_plugin_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_scenario_plugin_type(Arg_&& arg, Args_... args);
  std::string* mutable_scenario_plugin_type();
  PROTOBUF_NODISCARD std::string* release_scenario_plugin_type();
  void set_allocated_scenario_plugin_type(std::string* value);

  private:
  const std::string& _internal_scenario_plugin_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scenario_plugin_type(
      const std::string& value);
  std::string* _internal_mutable_scenario_plugin_type();

  public:
  // optional string stage_plugin_type = 5;
  bool has_stage_plugin_type() const;
  void clear_stage_plugin_type() ;
  const std::string& stage_plugin_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stage_plugin_type(Arg_&& arg, Args_... args);
  std::string* mutable_stage_plugin_type();
  PROTOBUF_NODISCARD std::string* release_stage_plugin_type();
  void set_allocated_stage_plugin_type(std::string* value);

  private:
  const std::string& _internal_stage_plugin_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_plugin_type(
      const std::string& value);
  std::string* _internal_mutable_stage_plugin_type();

  public:
  // optional int32 scenario_type = 1 [deprecated = true];
  [[deprecated]]  bool has_scenario_type() const;
  [[deprecated]]  void clear_scenario_type() ;
  [[deprecated]] ::int32_t scenario_type() const;
  [[deprecated]] void set_scenario_type(::int32_t value);

  private:
  ::int32_t _internal_scenario_type() const;
  void _internal_set_scenario_type(::int32_t value);

  public:
  // optional int32 stage_type = 2 [deprecated = true];
  [[deprecated]]  bool has_stage_type() const;
  [[deprecated]]  void clear_stage_type() ;
  [[deprecated]] ::int32_t stage_type() const;
  [[deprecated]] void set_stage_type(::int32_t value);

  private:
  ::int32_t _internal_stage_type() const;
  void _internal_set_stage_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.ScenarioDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      88, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ScenarioDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ScenarioDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    ::google::protobuf::internal::ArenaStringPtr scenario_plugin_type_;
    ::google::protobuf::internal::ArenaStringPtr stage_plugin_type_;
    ::int32_t scenario_type_;
    ::int32_t stage_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class STGraphDebug_STGraphSpeedConstraint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.STGraphDebug.STGraphSpeedConstraint) */ {
 public:
  inline STGraphDebug_STGraphSpeedConstraint() : STGraphDebug_STGraphSpeedConstraint(nullptr) {}
  ~STGraphDebug_STGraphSpeedConstraint() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR STGraphDebug_STGraphSpeedConstraint(
      ::google::protobuf::internal::ConstantInitialized);

  inline STGraphDebug_STGraphSpeedConstraint(const STGraphDebug_STGraphSpeedConstraint& from) : STGraphDebug_STGraphSpeedConstraint(nullptr, from) {}
  inline STGraphDebug_STGraphSpeedConstraint(STGraphDebug_STGraphSpeedConstraint&& from) noexcept
      : STGraphDebug_STGraphSpeedConstraint(nullptr, std::move(from)) {}
  inline STGraphDebug_STGraphSpeedConstraint& operator=(const STGraphDebug_STGraphSpeedConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline STGraphDebug_STGraphSpeedConstraint& operator=(STGraphDebug_STGraphSpeedConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STGraphDebug_STGraphSpeedConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const STGraphDebug_STGraphSpeedConstraint* internal_default_instance() {
    return reinterpret_cast<const STGraphDebug_STGraphSpeedConstraint*>(
        &_STGraphDebug_STGraphSpeedConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(STGraphDebug_STGraphSpeedConstraint& a, STGraphDebug_STGraphSpeedConstraint& b) { a.Swap(&b); }
  inline void Swap(STGraphDebug_STGraphSpeedConstraint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STGraphDebug_STGraphSpeedConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STGraphDebug_STGraphSpeedConstraint* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<STGraphDebug_STGraphSpeedConstraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const STGraphDebug_STGraphSpeedConstraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const STGraphDebug_STGraphSpeedConstraint& from) { STGraphDebug_STGraphSpeedConstraint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(STGraphDebug_STGraphSpeedConstraint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.STGraphDebug.STGraphSpeedConstraint"; }

 protected:
  explicit STGraphDebug_STGraphSpeedConstraint(::google::protobuf::Arena* arena);
  STGraphDebug_STGraphSpeedConstraint(::google::protobuf::Arena* arena, const STGraphDebug_STGraphSpeedConstraint& from);
  STGraphDebug_STGraphSpeedConstraint(::google::protobuf::Arena* arena, STGraphDebug_STGraphSpeedConstraint&& from) noexcept
      : STGraphDebug_STGraphSpeedConstraint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
    kLowerBoundFieldNumber = 2,
    kUpperBoundFieldNumber = 3,
  };
  // repeated double t = 1;
  int t_size() const;
  private:
  int _internal_t_size() const;

  public:
  void clear_t() ;
  double t(int index) const;
  void set_t(int index, double value);
  void add_t(double value);
  const ::google::protobuf::RepeatedField<double>& t() const;
  ::google::protobuf::RepeatedField<double>* mutable_t();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_t() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_t();

  public:
  // repeated double lower_bound = 2;
  int lower_bound_size() const;
  private:
  int _internal_lower_bound_size() const;

  public:
  void clear_lower_bound() ;
  double lower_bound(int index) const;
  void set_lower_bound(int index, double value);
  void add_lower_bound(double value);
  const ::google::protobuf::RepeatedField<double>& lower_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_lower_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_lower_bound();

  public:
  // repeated double upper_bound = 3;
  int upper_bound_size() const;
  private:
  int _internal_upper_bound_size() const;

  public:
  void clear_upper_bound() ;
  double upper_bound(int index) const;
  void set_upper_bound(int index, double value);
  void add_upper_bound(double value);
  const ::google::protobuf::RepeatedField<double>& upper_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_upper_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_upper_bound();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.STGraphDebug.STGraphSpeedConstraint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_STGraphDebug_STGraphSpeedConstraint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const STGraphDebug_STGraphSpeedConstraint& from_msg);
    ::google::protobuf::RepeatedField<double> t_;
    ::google::protobuf::RepeatedField<double> lower_bound_;
    ::google::protobuf::RepeatedField<double> upper_bound_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class STGraphDebug_STGraphKernelFollowRef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.STGraphDebug.STGraphKernelFollowRef) */ {
 public:
  inline STGraphDebug_STGraphKernelFollowRef() : STGraphDebug_STGraphKernelFollowRef(nullptr) {}
  ~STGraphDebug_STGraphKernelFollowRef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR STGraphDebug_STGraphKernelFollowRef(
      ::google::protobuf::internal::ConstantInitialized);

  inline STGraphDebug_STGraphKernelFollowRef(const STGraphDebug_STGraphKernelFollowRef& from) : STGraphDebug_STGraphKernelFollowRef(nullptr, from) {}
  inline STGraphDebug_STGraphKernelFollowRef(STGraphDebug_STGraphKernelFollowRef&& from) noexcept
      : STGraphDebug_STGraphKernelFollowRef(nullptr, std::move(from)) {}
  inline STGraphDebug_STGraphKernelFollowRef& operator=(const STGraphDebug_STGraphKernelFollowRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline STGraphDebug_STGraphKernelFollowRef& operator=(STGraphDebug_STGraphKernelFollowRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STGraphDebug_STGraphKernelFollowRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const STGraphDebug_STGraphKernelFollowRef* internal_default_instance() {
    return reinterpret_cast<const STGraphDebug_STGraphKernelFollowRef*>(
        &_STGraphDebug_STGraphKernelFollowRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(STGraphDebug_STGraphKernelFollowRef& a, STGraphDebug_STGraphKernelFollowRef& b) { a.Swap(&b); }
  inline void Swap(STGraphDebug_STGraphKernelFollowRef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STGraphDebug_STGraphKernelFollowRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STGraphDebug_STGraphKernelFollowRef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<STGraphDebug_STGraphKernelFollowRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const STGraphDebug_STGraphKernelFollowRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const STGraphDebug_STGraphKernelFollowRef& from) { STGraphDebug_STGraphKernelFollowRef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(STGraphDebug_STGraphKernelFollowRef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.STGraphDebug.STGraphKernelFollowRef"; }

 protected:
  explicit STGraphDebug_STGraphKernelFollowRef(::google::protobuf::Arena* arena);
  STGraphDebug_STGraphKernelFollowRef(::google::protobuf::Arena* arena, const STGraphDebug_STGraphKernelFollowRef& from);
  STGraphDebug_STGraphKernelFollowRef(::google::protobuf::Arena* arena, STGraphDebug_STGraphKernelFollowRef&& from) noexcept
      : STGraphDebug_STGraphKernelFollowRef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
    kFollowLineSFieldNumber = 2,
  };
  // repeated double t = 1;
  int t_size() const;
  private:
  int _internal_t_size() const;

  public:
  void clear_t() ;
  double t(int index) const;
  void set_t(int index, double value);
  void add_t(double value);
  const ::google::protobuf::RepeatedField<double>& t() const;
  ::google::protobuf::RepeatedField<double>* mutable_t();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_t() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_t();

  public:
  // repeated double follow_line_s = 2;
  int follow_line_s_size() const;
  private:
  int _internal_follow_line_s_size() const;

  public:
  void clear_follow_line_s() ;
  double follow_line_s(int index) const;
  void set_follow_line_s(int index, double value);
  void add_follow_line_s(double value);
  const ::google::protobuf::RepeatedField<double>& follow_line_s() const;
  ::google::protobuf::RepeatedField<double>* mutable_follow_line_s();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_follow_line_s() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_follow_line_s();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.STGraphDebug.STGraphKernelFollowRef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_STGraphDebug_STGraphKernelFollowRef_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const STGraphDebug_STGraphKernelFollowRef& from_msg);
    ::google::protobuf::RepeatedField<double> t_;
    ::google::protobuf::RepeatedField<double> follow_line_s_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class STGraphDebug_STGraphKernelCuiseRef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef) */ {
 public:
  inline STGraphDebug_STGraphKernelCuiseRef() : STGraphDebug_STGraphKernelCuiseRef(nullptr) {}
  ~STGraphDebug_STGraphKernelCuiseRef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR STGraphDebug_STGraphKernelCuiseRef(
      ::google::protobuf::internal::ConstantInitialized);

  inline STGraphDebug_STGraphKernelCuiseRef(const STGraphDebug_STGraphKernelCuiseRef& from) : STGraphDebug_STGraphKernelCuiseRef(nullptr, from) {}
  inline STGraphDebug_STGraphKernelCuiseRef(STGraphDebug_STGraphKernelCuiseRef&& from) noexcept
      : STGraphDebug_STGraphKernelCuiseRef(nullptr, std::move(from)) {}
  inline STGraphDebug_STGraphKernelCuiseRef& operator=(const STGraphDebug_STGraphKernelCuiseRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline STGraphDebug_STGraphKernelCuiseRef& operator=(STGraphDebug_STGraphKernelCuiseRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STGraphDebug_STGraphKernelCuiseRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const STGraphDebug_STGraphKernelCuiseRef* internal_default_instance() {
    return reinterpret_cast<const STGraphDebug_STGraphKernelCuiseRef*>(
        &_STGraphDebug_STGraphKernelCuiseRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(STGraphDebug_STGraphKernelCuiseRef& a, STGraphDebug_STGraphKernelCuiseRef& b) { a.Swap(&b); }
  inline void Swap(STGraphDebug_STGraphKernelCuiseRef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STGraphDebug_STGraphKernelCuiseRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STGraphDebug_STGraphKernelCuiseRef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<STGraphDebug_STGraphKernelCuiseRef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const STGraphDebug_STGraphKernelCuiseRef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const STGraphDebug_STGraphKernelCuiseRef& from) { STGraphDebug_STGraphKernelCuiseRef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(STGraphDebug_STGraphKernelCuiseRef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.STGraphDebug.STGraphKernelCuiseRef"; }

 protected:
  explicit STGraphDebug_STGraphKernelCuiseRef(::google::protobuf::Arena* arena);
  STGraphDebug_STGraphKernelCuiseRef(::google::protobuf::Arena* arena, const STGraphDebug_STGraphKernelCuiseRef& from);
  STGraphDebug_STGraphKernelCuiseRef(::google::protobuf::Arena* arena, STGraphDebug_STGraphKernelCuiseRef&& from) noexcept
      : STGraphDebug_STGraphKernelCuiseRef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
    kCruiseLineSFieldNumber = 2,
  };
  // repeated double t = 1;
  int t_size() const;
  private:
  int _internal_t_size() const;

  public:
  void clear_t() ;
  double t(int index) const;
  void set_t(int index, double value);
  void add_t(double value);
  const ::google::protobuf::RepeatedField<double>& t() const;
  ::google::protobuf::RepeatedField<double>* mutable_t();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_t() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_t();

  public:
  // repeated double cruise_line_s = 2;
  int cruise_line_s_size() const;
  private:
  int _internal_cruise_line_s_size() const;

  public:
  void clear_cruise_line_s() ;
  double cruise_line_s(int index) const;
  void set_cruise_line_s(int index, double value);
  void add_cruise_line_s(double value);
  const ::google::protobuf::RepeatedField<double>& cruise_line_s() const;
  ::google::protobuf::RepeatedField<double>* mutable_cruise_line_s();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_cruise_line_s() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_cruise_line_s();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_STGraphDebug_STGraphKernelCuiseRef_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const STGraphDebug_STGraphKernelCuiseRef& from_msg);
    ::google::protobuf::RepeatedField<double> t_;
    ::google::protobuf::RepeatedField<double> cruise_line_s_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class ReferenceLineDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.ReferenceLineDebug) */ {
 public:
  inline ReferenceLineDebug() : ReferenceLineDebug(nullptr) {}
  ~ReferenceLineDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReferenceLineDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReferenceLineDebug(const ReferenceLineDebug& from) : ReferenceLineDebug(nullptr, from) {}
  inline ReferenceLineDebug(ReferenceLineDebug&& from) noexcept
      : ReferenceLineDebug(nullptr, std::move(from)) {}
  inline ReferenceLineDebug& operator=(const ReferenceLineDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceLineDebug& operator=(ReferenceLineDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceLineDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceLineDebug* internal_default_instance() {
    return reinterpret_cast<const ReferenceLineDebug*>(
        &_ReferenceLineDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ReferenceLineDebug& a, ReferenceLineDebug& b) { a.Swap(&b); }
  inline void Swap(ReferenceLineDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceLineDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceLineDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ReferenceLineDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReferenceLineDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReferenceLineDebug& from) { ReferenceLineDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReferenceLineDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.ReferenceLineDebug"; }

 protected:
  explicit ReferenceLineDebug(::google::protobuf::Arena* arena);
  ReferenceLineDebug(::google::protobuf::Arena* arena, const ReferenceLineDebug& from);
  ReferenceLineDebug(::google::protobuf::Arena* arena, ReferenceLineDebug&& from) noexcept
      : ReferenceLineDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kLengthFieldNumber = 2,
    kCostFieldNumber = 3,
    kMinimumBoundaryFieldNumber = 8,
    kAverageKappaFieldNumber = 9,
    kAverageDkappaFieldNumber = 10,
    kKappaRmsFieldNumber = 11,
    kDkappaRmsFieldNumber = 12,
    kKappaMaxAbsFieldNumber = 13,
    kDkappaMaxAbsFieldNumber = 14,
    kAverageOffsetFieldNumber = 15,
    kIsChangeLanePathFieldNumber = 4,
    kIsDrivableFieldNumber = 5,
    kIsProtectedFieldNumber = 6,
    kIsOffroadFieldNumber = 7,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional double length = 2;
  bool has_length() const;
  void clear_length() ;
  double length() const;
  void set_length(double value);

  private:
  double _internal_length() const;
  void _internal_set_length(double value);

  public:
  // optional double cost = 3;
  bool has_cost() const;
  void clear_cost() ;
  double cost() const;
  void set_cost(double value);

  private:
  double _internal_cost() const;
  void _internal_set_cost(double value);

  public:
  // optional double minimum_boundary = 8;
  bool has_minimum_boundary() const;
  void clear_minimum_boundary() ;
  double minimum_boundary() const;
  void set_minimum_boundary(double value);

  private:
  double _internal_minimum_boundary() const;
  void _internal_set_minimum_boundary(double value);

  public:
  // optional double average_kappa = 9 [deprecated = true];
  [[deprecated]]  bool has_average_kappa() const;
  [[deprecated]]  void clear_average_kappa() ;
  [[deprecated]] double average_kappa() const;
  [[deprecated]] void set_average_kappa(double value);

  private:
  double _internal_average_kappa() const;
  void _internal_set_average_kappa(double value);

  public:
  // optional double average_dkappa = 10 [deprecated = true];
  [[deprecated]]  bool has_average_dkappa() const;
  [[deprecated]]  void clear_average_dkappa() ;
  [[deprecated]] double average_dkappa() const;
  [[deprecated]] void set_average_dkappa(double value);

  private:
  double _internal_average_dkappa() const;
  void _internal_set_average_dkappa(double value);

  public:
  // optional double kappa_rms = 11;
  bool has_kappa_rms() const;
  void clear_kappa_rms() ;
  double kappa_rms() const;
  void set_kappa_rms(double value);

  private:
  double _internal_kappa_rms() const;
  void _internal_set_kappa_rms(double value);

  public:
  // optional double dkappa_rms = 12;
  bool has_dkappa_rms() const;
  void clear_dkappa_rms() ;
  double dkappa_rms() const;
  void set_dkappa_rms(double value);

  private:
  double _internal_dkappa_rms() const;
  void _internal_set_dkappa_rms(double value);

  public:
  // optional double kappa_max_abs = 13;
  bool has_kappa_max_abs() const;
  void clear_kappa_max_abs() ;
  double kappa_max_abs() const;
  void set_kappa_max_abs(double value);

  private:
  double _internal_kappa_max_abs() const;
  void _internal_set_kappa_max_abs(double value);

  public:
  // optional double dkappa_max_abs = 14;
  bool has_dkappa_max_abs() const;
  void clear_dkappa_max_abs() ;
  double dkappa_max_abs() const;
  void set_dkappa_max_abs(double value);

  private:
  double _internal_dkappa_max_abs() const;
  void _internal_set_dkappa_max_abs(double value);

  public:
  // optional double average_offset = 15;
  bool has_average_offset() const;
  void clear_average_offset() ;
  double average_offset() const;
  void set_average_offset(double value);

  private:
  double _internal_average_offset() const;
  void _internal_set_average_offset(double value);

  public:
  // optional bool is_change_lane_path = 4;
  bool has_is_change_lane_path() const;
  void clear_is_change_lane_path() ;
  bool is_change_lane_path() const;
  void set_is_change_lane_path(bool value);

  private:
  bool _internal_is_change_lane_path() const;
  void _internal_set_is_change_lane_path(bool value);

  public:
  // optional bool is_drivable = 5;
  bool has_is_drivable() const;
  void clear_is_drivable() ;
  bool is_drivable() const;
  void set_is_drivable(bool value);

  private:
  bool _internal_is_drivable() const;
  void _internal_set_is_drivable(bool value);

  public:
  // optional bool is_protected = 6;
  bool has_is_protected() const;
  void clear_is_protected() ;
  bool is_protected() const;
  void set_is_protected(bool value);

  private:
  bool _internal_is_protected() const;
  void _internal_set_is_protected(bool value);

  public:
  // optional bool is_offroad = 7;
  bool has_is_offroad() const;
  void clear_is_offroad() ;
  bool is_offroad() const;
  void set_is_offroad(bool value);

  private:
  bool _internal_is_offroad() const;
  void _internal_set_is_offroad(bool value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.ReferenceLineDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 0,
      63, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReferenceLineDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReferenceLineDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    double length_;
    double cost_;
    double minimum_boundary_;
    double average_kappa_;
    double average_dkappa_;
    double kappa_rms_;
    double dkappa_rms_;
    double kappa_max_abs_;
    double dkappa_max_abs_;
    double average_offset_;
    bool is_change_lane_path_;
    bool is_drivable_;
    bool is_protected_;
    bool is_offroad_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class LatticeStPixel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.LatticeStPixel) */ {
 public:
  inline LatticeStPixel() : LatticeStPixel(nullptr) {}
  ~LatticeStPixel() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LatticeStPixel(
      ::google::protobuf::internal::ConstantInitialized);

  inline LatticeStPixel(const LatticeStPixel& from) : LatticeStPixel(nullptr, from) {}
  inline LatticeStPixel(LatticeStPixel&& from) noexcept
      : LatticeStPixel(nullptr, std::move(from)) {}
  inline LatticeStPixel& operator=(const LatticeStPixel& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatticeStPixel& operator=(LatticeStPixel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LatticeStPixel& default_instance() {
    return *internal_default_instance();
  }
  static inline const LatticeStPixel* internal_default_instance() {
    return reinterpret_cast<const LatticeStPixel*>(
        &_LatticeStPixel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(LatticeStPixel& a, LatticeStPixel& b) { a.Swap(&b); }
  inline void Swap(LatticeStPixel* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatticeStPixel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LatticeStPixel* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<LatticeStPixel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LatticeStPixel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LatticeStPixel& from) { LatticeStPixel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LatticeStPixel* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.LatticeStPixel"; }

 protected:
  explicit LatticeStPixel(::google::protobuf::Arena* arena);
  LatticeStPixel(::google::protobuf::Arena* arena, const LatticeStPixel& from);
  LatticeStPixel(::google::protobuf::Arena* arena, LatticeStPixel&& from) noexcept
      : LatticeStPixel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSFieldNumber = 1,
    kTFieldNumber = 2,
    kRFieldNumber = 3,
    kGFieldNumber = 4,
    kBFieldNumber = 5,
  };
  // optional int32 s = 1;
  bool has_s() const;
  void clear_s() ;
  ::int32_t s() const;
  void set_s(::int32_t value);

  private:
  ::int32_t _internal_s() const;
  void _internal_set_s(::int32_t value);

  public:
  // optional int32 t = 2;
  bool has_t() const;
  void clear_t() ;
  ::int32_t t() const;
  void set_t(::int32_t value);

  private:
  ::int32_t _internal_t() const;
  void _internal_set_t(::int32_t value);

  public:
  // optional uint32 r = 3;
  bool has_r() const;
  void clear_r() ;
  ::uint32_t r() const;
  void set_r(::uint32_t value);

  private:
  ::uint32_t _internal_r() const;
  void _internal_set_r(::uint32_t value);

  public:
  // optional uint32 g = 4;
  bool has_g() const;
  void clear_g() ;
  ::uint32_t g() const;
  void set_g(::uint32_t value);

  private:
  ::uint32_t _internal_g() const;
  void _internal_set_g(::uint32_t value);

  public:
  // optional uint32 b = 5;
  bool has_b() const;
  void clear_b() ;
  ::uint32_t b() const;
  void set_b(::uint32_t value);

  private:
  ::uint32_t _internal_b() const;
  void _internal_set_b(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.LatticeStPixel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LatticeStPixel_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LatticeStPixel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t s_;
    ::int32_t t_;
    ::uint32_t r_;
    ::uint32_t g_;
    ::uint32_t b_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class CostComponents final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.CostComponents) */ {
 public:
  inline CostComponents() : CostComponents(nullptr) {}
  ~CostComponents() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CostComponents(
      ::google::protobuf::internal::ConstantInitialized);

  inline CostComponents(const CostComponents& from) : CostComponents(nullptr, from) {}
  inline CostComponents(CostComponents&& from) noexcept
      : CostComponents(nullptr, std::move(from)) {}
  inline CostComponents& operator=(const CostComponents& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostComponents& operator=(CostComponents&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CostComponents& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostComponents* internal_default_instance() {
    return reinterpret_cast<const CostComponents*>(
        &_CostComponents_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(CostComponents& a, CostComponents& b) { a.Swap(&b); }
  inline void Swap(CostComponents* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostComponents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostComponents* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CostComponents>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CostComponents& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CostComponents& from) { CostComponents::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CostComponents* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.CostComponents"; }

 protected:
  explicit CostComponents(::google::protobuf::Arena* arena);
  CostComponents(::google::protobuf::Arena* arena, const CostComponents& from);
  CostComponents(::google::protobuf::Arena* arena, CostComponents&& from) noexcept
      : CostComponents(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCostComponentFieldNumber = 1,
  };
  // repeated double cost_component = 1;
  int cost_component_size() const;
  private:
  int _internal_cost_component_size() const;

  public:
  void clear_cost_component() ;
  double cost_component(int index) const;
  void set_cost_component(int index, double value);
  void add_cost_component(double value);
  const ::google::protobuf::RepeatedField<double>& cost_component() const;
  ::google::protobuf::RepeatedField<double>* mutable_cost_component();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_cost_component() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_cost_component();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.CostComponents)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CostComponents_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CostComponents& from_msg);
    ::google::protobuf::RepeatedField<double> cost_component_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class StGraphBoundaryDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.StGraphBoundaryDebug) */ {
 public:
  inline StGraphBoundaryDebug() : StGraphBoundaryDebug(nullptr) {}
  ~StGraphBoundaryDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StGraphBoundaryDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline StGraphBoundaryDebug(const StGraphBoundaryDebug& from) : StGraphBoundaryDebug(nullptr, from) {}
  inline StGraphBoundaryDebug(StGraphBoundaryDebug&& from) noexcept
      : StGraphBoundaryDebug(nullptr, std::move(from)) {}
  inline StGraphBoundaryDebug& operator=(const StGraphBoundaryDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline StGraphBoundaryDebug& operator=(StGraphBoundaryDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StGraphBoundaryDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const StGraphBoundaryDebug* internal_default_instance() {
    return reinterpret_cast<const StGraphBoundaryDebug*>(
        &_StGraphBoundaryDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(StGraphBoundaryDebug& a, StGraphBoundaryDebug& b) { a.Swap(&b); }
  inline void Swap(StGraphBoundaryDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StGraphBoundaryDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StGraphBoundaryDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StGraphBoundaryDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StGraphBoundaryDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StGraphBoundaryDebug& from) { StGraphBoundaryDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StGraphBoundaryDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.StGraphBoundaryDebug"; }

 protected:
  explicit StGraphBoundaryDebug(::google::protobuf::Arena* arena);
  StGraphBoundaryDebug(::google::protobuf::Arena* arena, const StGraphBoundaryDebug& from);
  StGraphBoundaryDebug(::google::protobuf::Arena* arena, StGraphBoundaryDebug&& from) noexcept
      : StGraphBoundaryDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StBoundaryType = StGraphBoundaryDebug_StBoundaryType;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_UNKNOWN = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_UNKNOWN;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_STOP = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_STOP;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_FOLLOW = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_FOLLOW;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_YIELD = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_YIELD;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_OVERTAKE = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_OVERTAKE;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_KEEP_CLEAR = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_KEEP_CLEAR;
  static constexpr StBoundaryType ST_BOUNDARY_TYPE_DRIVABLE_REGION = StGraphBoundaryDebug_StBoundaryType_ST_BOUNDARY_TYPE_DRIVABLE_REGION;
  static inline bool StBoundaryType_IsValid(int value) {
    return StGraphBoundaryDebug_StBoundaryType_IsValid(value);
  }
  static constexpr StBoundaryType StBoundaryType_MIN = StGraphBoundaryDebug_StBoundaryType_StBoundaryType_MIN;
  static constexpr StBoundaryType StBoundaryType_MAX = StGraphBoundaryDebug_StBoundaryType_StBoundaryType_MAX;
  static constexpr int StBoundaryType_ARRAYSIZE = StGraphBoundaryDebug_StBoundaryType_StBoundaryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StBoundaryType_descriptor() {
    return StGraphBoundaryDebug_StBoundaryType_descriptor();
  }
  template <typename T>
  static inline const std::string& StBoundaryType_Name(T value) {
    return StGraphBoundaryDebug_StBoundaryType_Name(value);
  }
  static inline bool StBoundaryType_Parse(absl::string_view name, StBoundaryType* value) {
    return StGraphBoundaryDebug_StBoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPointFieldNumber = 2,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // repeated .control.common.SpeedPoint point = 2;
  int point_size() const;
  private:
  int _internal_point_size() const;

  public:
  void clear_point() ;
  ::control::common::SpeedPoint* mutable_point(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* mutable_point();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& _internal_point() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* _internal_mutable_point();
  public:
  const ::control::common::SpeedPoint& point(int index) const;
  ::control::common::SpeedPoint* add_point();
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& point() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .control.planning_internal.StGraphBoundaryDebug.StBoundaryType type = 3;
  bool has_type() const;
  void clear_type() ;
  ::control::planning_internal::StGraphBoundaryDebug_StBoundaryType type() const;
  void set_type(::control::planning_internal::StGraphBoundaryDebug_StBoundaryType value);

  private:
  ::control::planning_internal::StGraphBoundaryDebug_StBoundaryType _internal_type() const;
  void _internal_set_type(::control::planning_internal::StGraphBoundaryDebug_StBoundaryType value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.StGraphBoundaryDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StGraphBoundaryDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StGraphBoundaryDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::common::SpeedPoint > point_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class SpeedPlan final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.SpeedPlan) */ {
 public:
  inline SpeedPlan() : SpeedPlan(nullptr) {}
  ~SpeedPlan() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpeedPlan(
      ::google::protobuf::internal::ConstantInitialized);

  inline SpeedPlan(const SpeedPlan& from) : SpeedPlan(nullptr, from) {}
  inline SpeedPlan(SpeedPlan&& from) noexcept
      : SpeedPlan(nullptr, std::move(from)) {}
  inline SpeedPlan& operator=(const SpeedPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedPlan& operator=(SpeedPlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeedPlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeedPlan* internal_default_instance() {
    return reinterpret_cast<const SpeedPlan*>(
        &_SpeedPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SpeedPlan& a, SpeedPlan& b) { a.Swap(&b); }
  inline void Swap(SpeedPlan* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedPlan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeedPlan* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SpeedPlan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpeedPlan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpeedPlan& from) { SpeedPlan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpeedPlan* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.SpeedPlan"; }

 protected:
  explicit SpeedPlan(::google::protobuf::Arena* arena);
  SpeedPlan(::google::protobuf::Arena* arena, const SpeedPlan& from);
  SpeedPlan(::google::protobuf::Arena* arena, SpeedPlan&& from) noexcept
      : SpeedPlan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpeedPointFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .control.common.SpeedPoint speed_point = 2;
  int speed_point_size() const;
  private:
  int _internal_speed_point_size() const;

  public:
  void clear_speed_point() ;
  ::control::common::SpeedPoint* mutable_speed_point(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* mutable_speed_point();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& _internal_speed_point() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* _internal_mutable_speed_point();
  public:
  const ::control::common::SpeedPoint& speed_point(int index) const;
  ::control::common::SpeedPoint* add_speed_point();
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& speed_point() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.SpeedPlan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      48, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SpeedPlan_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SpeedPlan& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::common::SpeedPoint > speed_point_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class SampleLayerDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.SampleLayerDebug) */ {
 public:
  inline SampleLayerDebug() : SampleLayerDebug(nullptr) {}
  ~SampleLayerDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SampleLayerDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline SampleLayerDebug(const SampleLayerDebug& from) : SampleLayerDebug(nullptr, from) {}
  inline SampleLayerDebug(SampleLayerDebug&& from) noexcept
      : SampleLayerDebug(nullptr, std::move(from)) {}
  inline SampleLayerDebug& operator=(const SampleLayerDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline SampleLayerDebug& operator=(SampleLayerDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SampleLayerDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const SampleLayerDebug* internal_default_instance() {
    return reinterpret_cast<const SampleLayerDebug*>(
        &_SampleLayerDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SampleLayerDebug& a, SampleLayerDebug& b) { a.Swap(&b); }
  inline void Swap(SampleLayerDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SampleLayerDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SampleLayerDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SampleLayerDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SampleLayerDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SampleLayerDebug& from) { SampleLayerDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SampleLayerDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.SampleLayerDebug"; }

 protected:
  explicit SampleLayerDebug(::google::protobuf::Arena* arena);
  SampleLayerDebug(::google::protobuf::Arena* arena, const SampleLayerDebug& from);
  SampleLayerDebug(::google::protobuf::Arena* arena, SampleLayerDebug&& from) noexcept
      : SampleLayerDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSlPointFieldNumber = 1,
  };
  // repeated .control.common.SLPoint sl_point = 1;
  int sl_point_size() const;
  private:
  int _internal_sl_point_size() const;

  public:
  void clear_sl_point() ;
  ::control::common::SLPoint* mutable_sl_point(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* mutable_sl_point();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& _internal_sl_point() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* _internal_mutable_sl_point();
  public:
  const ::control::common::SLPoint& sl_point(int index) const;
  ::control::common::SLPoint* add_sl_point();
  const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& sl_point() const;
  // @@protoc_insertion_point(class_scope:control.planning_internal.SampleLayerDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SampleLayerDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SampleLayerDebug& from_msg);
    ::google::protobuf::RepeatedPtrField< ::control::common::SLPoint > sl_point_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class SLFrameDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.SLFrameDebug) */ {
 public:
  inline SLFrameDebug() : SLFrameDebug(nullptr) {}
  ~SLFrameDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SLFrameDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline SLFrameDebug(const SLFrameDebug& from) : SLFrameDebug(nullptr, from) {}
  inline SLFrameDebug(SLFrameDebug&& from) noexcept
      : SLFrameDebug(nullptr, std::move(from)) {}
  inline SLFrameDebug& operator=(const SLFrameDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLFrameDebug& operator=(SLFrameDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLFrameDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLFrameDebug* internal_default_instance() {
    return reinterpret_cast<const SLFrameDebug*>(
        &_SLFrameDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SLFrameDebug& a, SLFrameDebug& b) { a.Swap(&b); }
  inline void Swap(SLFrameDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLFrameDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SLFrameDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SLFrameDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SLFrameDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SLFrameDebug& from) { SLFrameDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SLFrameDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.SLFrameDebug"; }

 protected:
  explicit SLFrameDebug(::google::protobuf::Arena* arena);
  SLFrameDebug(::google::protobuf::Arena* arena, const SLFrameDebug& from);
  SLFrameDebug(::google::protobuf::Arena* arena, SLFrameDebug&& from) noexcept
      : SLFrameDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSampledSFieldNumber = 2,
    kStaticObstacleLowerBoundFieldNumber = 3,
    kDynamicObstacleLowerBoundFieldNumber = 4,
    kStaticObstacleUpperBoundFieldNumber = 5,
    kDynamicObstacleUpperBoundFieldNumber = 6,
    kMapLowerBoundFieldNumber = 7,
    kMapUpperBoundFieldNumber = 8,
    kSlPathFieldNumber = 9,
    kAggregatedBoundarySFieldNumber = 10,
    kAggregatedBoundaryLowFieldNumber = 11,
    kAggregatedBoundaryHighFieldNumber = 12,
    kNameFieldNumber = 1,
  };
  // repeated double sampled_s = 2;
  int sampled_s_size() const;
  private:
  int _internal_sampled_s_size() const;

  public:
  void clear_sampled_s() ;
  double sampled_s(int index) const;
  void set_sampled_s(int index, double value);
  void add_sampled_s(double value);
  const ::google::protobuf::RepeatedField<double>& sampled_s() const;
  ::google::protobuf::RepeatedField<double>* mutable_sampled_s();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sampled_s() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_sampled_s();

  public:
  // repeated double static_obstacle_lower_bound = 3;
  int static_obstacle_lower_bound_size() const;
  private:
  int _internal_static_obstacle_lower_bound_size() const;

  public:
  void clear_static_obstacle_lower_bound() ;
  double static_obstacle_lower_bound(int index) const;
  void set_static_obstacle_lower_bound(int index, double value);
  void add_static_obstacle_lower_bound(double value);
  const ::google::protobuf::RepeatedField<double>& static_obstacle_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_static_obstacle_lower_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_static_obstacle_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_static_obstacle_lower_bound();

  public:
  // repeated double dynamic_obstacle_lower_bound = 4;
  int dynamic_obstacle_lower_bound_size() const;
  private:
  int _internal_dynamic_obstacle_lower_bound_size() const;

  public:
  void clear_dynamic_obstacle_lower_bound() ;
  double dynamic_obstacle_lower_bound(int index) const;
  void set_dynamic_obstacle_lower_bound(int index, double value);
  void add_dynamic_obstacle_lower_bound(double value);
  const ::google::protobuf::RepeatedField<double>& dynamic_obstacle_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_dynamic_obstacle_lower_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_dynamic_obstacle_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_dynamic_obstacle_lower_bound();

  public:
  // repeated double static_obstacle_upper_bound = 5;
  int static_obstacle_upper_bound_size() const;
  private:
  int _internal_static_obstacle_upper_bound_size() const;

  public:
  void clear_static_obstacle_upper_bound() ;
  double static_obstacle_upper_bound(int index) const;
  void set_static_obstacle_upper_bound(int index, double value);
  void add_static_obstacle_upper_bound(double value);
  const ::google::protobuf::RepeatedField<double>& static_obstacle_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_static_obstacle_upper_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_static_obstacle_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_static_obstacle_upper_bound();

  public:
  // repeated double dynamic_obstacle_upper_bound = 6;
  int dynamic_obstacle_upper_bound_size() const;
  private:
  int _internal_dynamic_obstacle_upper_bound_size() const;

  public:
  void clear_dynamic_obstacle_upper_bound() ;
  double dynamic_obstacle_upper_bound(int index) const;
  void set_dynamic_obstacle_upper_bound(int index, double value);
  void add_dynamic_obstacle_upper_bound(double value);
  const ::google::protobuf::RepeatedField<double>& dynamic_obstacle_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_dynamic_obstacle_upper_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_dynamic_obstacle_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_dynamic_obstacle_upper_bound();

  public:
  // repeated double map_lower_bound = 7;
  int map_lower_bound_size() const;
  private:
  int _internal_map_lower_bound_size() const;

  public:
  void clear_map_lower_bound() ;
  double map_lower_bound(int index) const;
  void set_map_lower_bound(int index, double value);
  void add_map_lower_bound(double value);
  const ::google::protobuf::RepeatedField<double>& map_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_map_lower_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_map_lower_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_map_lower_bound();

  public:
  // repeated double map_upper_bound = 8;
  int map_upper_bound_size() const;
  private:
  int _internal_map_upper_bound_size() const;

  public:
  void clear_map_upper_bound() ;
  double map_upper_bound(int index) const;
  void set_map_upper_bound(int index, double value);
  void add_map_upper_bound(double value);
  const ::google::protobuf::RepeatedField<double>& map_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* mutable_map_upper_bound();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_map_upper_bound() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_map_upper_bound();

  public:
  // repeated .control.common.SLPoint sl_path = 9;
  int sl_path_size() const;
  private:
  int _internal_sl_path_size() const;

  public:
  void clear_sl_path() ;
  ::control::common::SLPoint* mutable_sl_path(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* mutable_sl_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& _internal_sl_path() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* _internal_mutable_sl_path();
  public:
  const ::control::common::SLPoint& sl_path(int index) const;
  ::control::common::SLPoint* add_sl_path();
  const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& sl_path() const;
  // repeated double aggregated_boundary_s = 10;
  int aggregated_boundary_s_size() const;
  private:
  int _internal_aggregated_boundary_s_size() const;

  public:
  void clear_aggregated_boundary_s() ;
  double aggregated_boundary_s(int index) const;
  void set_aggregated_boundary_s(int index, double value);
  void add_aggregated_boundary_s(double value);
  const ::google::protobuf::RepeatedField<double>& aggregated_boundary_s() const;
  ::google::protobuf::RepeatedField<double>* mutable_aggregated_boundary_s();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_aggregated_boundary_s() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_aggregated_boundary_s();

  public:
  // repeated double aggregated_boundary_low = 11;
  int aggregated_boundary_low_size() const;
  private:
  int _internal_aggregated_boundary_low_size() const;

  public:
  void clear_aggregated_boundary_low() ;
  double aggregated_boundary_low(int index) const;
  void set_aggregated_boundary_low(int index, double value);
  void add_aggregated_boundary_low(double value);
  const ::google::protobuf::RepeatedField<double>& aggregated_boundary_low() const;
  ::google::protobuf::RepeatedField<double>* mutable_aggregated_boundary_low();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_aggregated_boundary_low() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_aggregated_boundary_low();

  public:
  // repeated double aggregated_boundary_high = 12;
  int aggregated_boundary_high_size() const;
  private:
  int _internal_aggregated_boundary_high_size() const;

  public:
  void clear_aggregated_boundary_high() ;
  double aggregated_boundary_high(int index) const;
  void set_aggregated_boundary_high(int index, double value);
  void add_aggregated_boundary_high(double value);
  const ::google::protobuf::RepeatedField<double>& aggregated_boundary_high() const;
  ::google::protobuf::RepeatedField<double>* mutable_aggregated_boundary_high();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_aggregated_boundary_high() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_aggregated_boundary_high();

  public:
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.SLFrameDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SLFrameDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SLFrameDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> sampled_s_;
    ::google::protobuf::RepeatedField<double> static_obstacle_lower_bound_;
    ::google::protobuf::RepeatedField<double> dynamic_obstacle_lower_bound_;
    ::google::protobuf::RepeatedField<double> static_obstacle_upper_bound_;
    ::google::protobuf::RepeatedField<double> dynamic_obstacle_upper_bound_;
    ::google::protobuf::RepeatedField<double> map_lower_bound_;
    ::google::protobuf::RepeatedField<double> map_upper_bound_;
    ::google::protobuf::RepeatedPtrField< ::control::common::SLPoint > sl_path_;
    ::google::protobuf::RepeatedField<double> aggregated_boundary_s_;
    ::google::protobuf::RepeatedField<double> aggregated_boundary_low_;
    ::google::protobuf::RepeatedField<double> aggregated_boundary_high_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class PullOverDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.PullOverDebug) */ {
 public:
  inline PullOverDebug() : PullOverDebug(nullptr) {}
  ~PullOverDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PullOverDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline PullOverDebug(const PullOverDebug& from) : PullOverDebug(nullptr, from) {}
  inline PullOverDebug(PullOverDebug&& from) noexcept
      : PullOverDebug(nullptr, std::move(from)) {}
  inline PullOverDebug& operator=(const PullOverDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullOverDebug& operator=(PullOverDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullOverDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullOverDebug* internal_default_instance() {
    return reinterpret_cast<const PullOverDebug*>(
        &_PullOverDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(PullOverDebug& a, PullOverDebug& b) { a.Swap(&b); }
  inline void Swap(PullOverDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullOverDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullOverDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PullOverDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PullOverDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PullOverDebug& from) { PullOverDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PullOverDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.PullOverDebug"; }

 protected:
  explicit PullOverDebug(::google::protobuf::Arena* arena);
  PullOverDebug(::google::protobuf::Arena* arena, const PullOverDebug& from);
  PullOverDebug(::google::protobuf::Arena* arena, PullOverDebug&& from) noexcept
      : PullOverDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kThetaFieldNumber = 2,
    kLengthFrontFieldNumber = 3,
    kLengthBackFieldNumber = 4,
    kWidthLeftFieldNumber = 5,
    kWidthRightFieldNumber = 6,
  };
  // optional .control.common.PointENU position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::control::common::PointENU& position() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_position();
  ::control::common::PointENU* mutable_position();
  void set_allocated_position(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_position(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_position();

  private:
  const ::control::common::PointENU& _internal_position() const;
  ::control::common::PointENU* _internal_mutable_position();

  public:
  // optional double theta = 2;
  bool has_theta() const;
  void clear_theta() ;
  double theta() const;
  void set_theta(double value);

  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);

  public:
  // optional double length_front = 3;
  bool has_length_front() const;
  void clear_length_front() ;
  double length_front() const;
  void set_length_front(double value);

  private:
  double _internal_length_front() const;
  void _internal_set_length_front(double value);

  public:
  // optional double length_back = 4;
  bool has_length_back() const;
  void clear_length_back() ;
  double length_back() const;
  void set_length_back(double value);

  private:
  double _internal_length_back() const;
  void _internal_set_length_back(double value);

  public:
  // optional double width_left = 5;
  bool has_width_left() const;
  void clear_width_left() ;
  double width_left() const;
  void set_width_left(double value);

  private:
  double _internal_width_left() const;
  void _internal_set_width_left(double value);

  public:
  // optional double width_right = 6;
  bool has_width_right() const;
  void clear_width_right() ;
  double width_right() const;
  void set_width_right(double value);

  private:
  double _internal_width_right() const;
  void _internal_set_width_right(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.PullOverDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PullOverDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PullOverDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::common::PointENU* position_;
    double theta_;
    double length_front_;
    double length_back_;
    double width_left_;
    double width_right_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class LatticeStTraining final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.LatticeStTraining) */ {
 public:
  inline LatticeStTraining() : LatticeStTraining(nullptr) {}
  ~LatticeStTraining() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LatticeStTraining(
      ::google::protobuf::internal::ConstantInitialized);

  inline LatticeStTraining(const LatticeStTraining& from) : LatticeStTraining(nullptr, from) {}
  inline LatticeStTraining(LatticeStTraining&& from) noexcept
      : LatticeStTraining(nullptr, std::move(from)) {}
  inline LatticeStTraining& operator=(const LatticeStTraining& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatticeStTraining& operator=(LatticeStTraining&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LatticeStTraining& default_instance() {
    return *internal_default_instance();
  }
  static inline const LatticeStTraining* internal_default_instance() {
    return reinterpret_cast<const LatticeStTraining*>(
        &_LatticeStTraining_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(LatticeStTraining& a, LatticeStTraining& b) { a.Swap(&b); }
  inline void Swap(LatticeStTraining* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatticeStTraining* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LatticeStTraining* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<LatticeStTraining>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LatticeStTraining& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LatticeStTraining& from) { LatticeStTraining::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LatticeStTraining* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.LatticeStTraining"; }

 protected:
  explicit LatticeStTraining(::google::protobuf::Arena* arena);
  LatticeStTraining(::google::protobuf::Arena* arena, const LatticeStTraining& from);
  LatticeStTraining(::google::protobuf::Arena* arena, LatticeStTraining&& from) noexcept
      : LatticeStTraining(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPixelFieldNumber = 1,
    kAnnotationFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kNumSGridsFieldNumber = 4,
    kNumTGridsFieldNumber = 5,
    kSResolutionFieldNumber = 6,
    kTResolutionFieldNumber = 7,
  };
  // repeated .control.planning_internal.LatticeStPixel pixel = 1;
  int pixel_size() const;
  private:
  int _internal_pixel_size() const;

  public:
  void clear_pixel() ;
  ::control::planning_internal::LatticeStPixel* mutable_pixel(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>* mutable_pixel();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>& _internal_pixel() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>* _internal_mutable_pixel();
  public:
  const ::control::planning_internal::LatticeStPixel& pixel(int index) const;
  ::control::planning_internal::LatticeStPixel* add_pixel();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>& pixel() const;
  // optional string annotation = 3;
  bool has_annotation() const;
  void clear_annotation() ;
  const std::string& annotation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_annotation(Arg_&& arg, Args_... args);
  std::string* mutable_annotation();
  PROTOBUF_NODISCARD std::string* release_annotation();
  void set_allocated_annotation(std::string* value);

  private:
  const std::string& _internal_annotation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_annotation(
      const std::string& value);
  std::string* _internal_mutable_annotation();

  public:
  // optional double timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp() ;
  double timestamp() const;
  void set_timestamp(double value);

  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);

  public:
  // optional uint32 num_s_grids = 4;
  bool has_num_s_grids() const;
  void clear_num_s_grids() ;
  ::uint32_t num_s_grids() const;
  void set_num_s_grids(::uint32_t value);

  private:
  ::uint32_t _internal_num_s_grids() const;
  void _internal_set_num_s_grids(::uint32_t value);

  public:
  // optional uint32 num_t_grids = 5;
  bool has_num_t_grids() const;
  void clear_num_t_grids() ;
  ::uint32_t num_t_grids() const;
  void set_num_t_grids(::uint32_t value);

  private:
  ::uint32_t _internal_num_t_grids() const;
  void _internal_set_num_t_grids(::uint32_t value);

  public:
  // optional double s_resolution = 6;
  bool has_s_resolution() const;
  void clear_s_resolution() ;
  double s_resolution() const;
  void set_s_resolution(double value);

  private:
  double _internal_s_resolution() const;
  void _internal_set_s_resolution(double value);

  public:
  // optional double t_resolution = 7;
  bool has_t_resolution() const;
  void clear_t_resolution() ;
  double t_resolution() const;
  void set_t_resolution(double value);

  private:
  double _internal_t_resolution() const;
  void _internal_set_t_resolution(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.LatticeStTraining)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      62, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LatticeStTraining_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LatticeStTraining& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::LatticeStPixel > pixel_;
    ::google::protobuf::internal::ArenaStringPtr annotation_;
    double timestamp_;
    ::uint32_t num_s_grids_;
    ::uint32_t num_t_grids_;
    double s_resolution_;
    double t_resolution_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class AutoTuningTrainingData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.AutoTuningTrainingData) */ {
 public:
  inline AutoTuningTrainingData() : AutoTuningTrainingData(nullptr) {}
  ~AutoTuningTrainingData() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AutoTuningTrainingData(
      ::google::protobuf::internal::ConstantInitialized);

  inline AutoTuningTrainingData(const AutoTuningTrainingData& from) : AutoTuningTrainingData(nullptr, from) {}
  inline AutoTuningTrainingData(AutoTuningTrainingData&& from) noexcept
      : AutoTuningTrainingData(nullptr, std::move(from)) {}
  inline AutoTuningTrainingData& operator=(const AutoTuningTrainingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoTuningTrainingData& operator=(AutoTuningTrainingData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoTuningTrainingData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoTuningTrainingData* internal_default_instance() {
    return reinterpret_cast<const AutoTuningTrainingData*>(
        &_AutoTuningTrainingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(AutoTuningTrainingData& a, AutoTuningTrainingData& b) { a.Swap(&b); }
  inline void Swap(AutoTuningTrainingData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoTuningTrainingData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoTuningTrainingData* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AutoTuningTrainingData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoTuningTrainingData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AutoTuningTrainingData& from) { AutoTuningTrainingData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoTuningTrainingData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.AutoTuningTrainingData"; }

 protected:
  explicit AutoTuningTrainingData(::google::protobuf::Arena* arena);
  AutoTuningTrainingData(::google::protobuf::Arena* arena, const AutoTuningTrainingData& from);
  AutoTuningTrainingData(::google::protobuf::Arena* arena, AutoTuningTrainingData&& from) noexcept
      : AutoTuningTrainingData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTeacherComponentFieldNumber = 1,
    kStudentComponentFieldNumber = 2,
  };
  // optional .control.planning_internal.CostComponents teacher_component = 1;
  bool has_teacher_component() const;
  void clear_teacher_component() ;
  const ::control::planning_internal::CostComponents& teacher_component() const;
  PROTOBUF_NODISCARD ::control::planning_internal::CostComponents* release_teacher_component();
  ::control::planning_internal::CostComponents* mutable_teacher_component();
  void set_allocated_teacher_component(::control::planning_internal::CostComponents* value);
  void unsafe_arena_set_allocated_teacher_component(::control::planning_internal::CostComponents* value);
  ::control::planning_internal::CostComponents* unsafe_arena_release_teacher_component();

  private:
  const ::control::planning_internal::CostComponents& _internal_teacher_component() const;
  ::control::planning_internal::CostComponents* _internal_mutable_teacher_component();

  public:
  // optional .control.planning_internal.CostComponents student_component = 2;
  bool has_student_component() const;
  void clear_student_component() ;
  const ::control::planning_internal::CostComponents& student_component() const;
  PROTOBUF_NODISCARD ::control::planning_internal::CostComponents* release_student_component();
  ::control::planning_internal::CostComponents* mutable_student_component();
  void set_allocated_student_component(::control::planning_internal::CostComponents* value);
  void unsafe_arena_set_allocated_student_component(::control::planning_internal::CostComponents* value);
  ::control::planning_internal::CostComponents* unsafe_arena_release_student_component();

  private:
  const ::control::planning_internal::CostComponents& _internal_student_component() const;
  ::control::planning_internal::CostComponents* _internal_mutable_student_component();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.AutoTuningTrainingData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AutoTuningTrainingData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AutoTuningTrainingData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::planning_internal::CostComponents* teacher_component_;
    ::control::planning_internal::CostComponents* student_component_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class STGraphDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.STGraphDebug) */ {
 public:
  inline STGraphDebug() : STGraphDebug(nullptr) {}
  ~STGraphDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR STGraphDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline STGraphDebug(const STGraphDebug& from) : STGraphDebug(nullptr, from) {}
  inline STGraphDebug(STGraphDebug&& from) noexcept
      : STGraphDebug(nullptr, std::move(from)) {}
  inline STGraphDebug& operator=(const STGraphDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline STGraphDebug& operator=(STGraphDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STGraphDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const STGraphDebug* internal_default_instance() {
    return reinterpret_cast<const STGraphDebug*>(
        &_STGraphDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(STGraphDebug& a, STGraphDebug& b) { a.Swap(&b); }
  inline void Swap(STGraphDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STGraphDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STGraphDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<STGraphDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const STGraphDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const STGraphDebug& from) { STGraphDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(STGraphDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.STGraphDebug"; }

 protected:
  explicit STGraphDebug(::google::protobuf::Arena* arena);
  STGraphDebug(::google::protobuf::Arena* arena, const STGraphDebug& from);
  STGraphDebug(::google::protobuf::Arena* arena, STGraphDebug&& from) noexcept
      : STGraphDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using STGraphSpeedConstraint = STGraphDebug_STGraphSpeedConstraint;
  using STGraphKernelCuiseRef = STGraphDebug_STGraphKernelCuiseRef;
  using STGraphKernelFollowRef = STGraphDebug_STGraphKernelFollowRef;

  // accessors -------------------------------------------------------
  enum : int {
    kBoundaryFieldNumber = 2,
    kSpeedLimitFieldNumber = 3,
    kSpeedProfileFieldNumber = 4,
    kNameFieldNumber = 1,
    kSpeedConstraintFieldNumber = 5,
    kKernelCruiseRefFieldNumber = 6,
    kKernelFollowRefFieldNumber = 7,
  };
  // repeated .control.planning_internal.StGraphBoundaryDebug boundary = 2;
  int boundary_size() const;
  private:
  int _internal_boundary_size() const;

  public:
  void clear_boundary() ;
  ::control::planning_internal::StGraphBoundaryDebug* mutable_boundary(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>* mutable_boundary();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>& _internal_boundary() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>* _internal_mutable_boundary();
  public:
  const ::control::planning_internal::StGraphBoundaryDebug& boundary(int index) const;
  ::control::planning_internal::StGraphBoundaryDebug* add_boundary();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>& boundary() const;
  // repeated .control.common.SpeedPoint speed_limit = 3;
  int speed_limit_size() const;
  private:
  int _internal_speed_limit_size() const;

  public:
  void clear_speed_limit() ;
  ::control::common::SpeedPoint* mutable_speed_limit(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* mutable_speed_limit();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& _internal_speed_limit() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* _internal_mutable_speed_limit();
  public:
  const ::control::common::SpeedPoint& speed_limit(int index) const;
  ::control::common::SpeedPoint* add_speed_limit();
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& speed_limit() const;
  // repeated .control.common.SpeedPoint speed_profile = 4;
  int speed_profile_size() const;
  private:
  int _internal_speed_profile_size() const;

  public:
  void clear_speed_profile() ;
  ::control::common::SpeedPoint* mutable_speed_profile(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* mutable_speed_profile();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& _internal_speed_profile() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* _internal_mutable_speed_profile();
  public:
  const ::control::common::SpeedPoint& speed_profile(int index) const;
  ::control::common::SpeedPoint* add_speed_profile();
  const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& speed_profile() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .control.planning_internal.STGraphDebug.STGraphSpeedConstraint speed_constraint = 5;
  bool has_speed_constraint() const;
  void clear_speed_constraint() ;
  const ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint& speed_constraint() const;
  PROTOBUF_NODISCARD ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* release_speed_constraint();
  ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* mutable_speed_constraint();
  void set_allocated_speed_constraint(::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* value);
  void unsafe_arena_set_allocated_speed_constraint(::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* value);
  ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* unsafe_arena_release_speed_constraint();

  private:
  const ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint& _internal_speed_constraint() const;
  ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* _internal_mutable_speed_constraint();

  public:
  // optional .control.planning_internal.STGraphDebug.STGraphKernelCuiseRef kernel_cruise_ref = 6;
  bool has_kernel_cruise_ref() const;
  void clear_kernel_cruise_ref() ;
  const ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef& kernel_cruise_ref() const;
  PROTOBUF_NODISCARD ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* release_kernel_cruise_ref();
  ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* mutable_kernel_cruise_ref();
  void set_allocated_kernel_cruise_ref(::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* value);
  void unsafe_arena_set_allocated_kernel_cruise_ref(::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* value);
  ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* unsafe_arena_release_kernel_cruise_ref();

  private:
  const ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef& _internal_kernel_cruise_ref() const;
  ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* _internal_mutable_kernel_cruise_ref();

  public:
  // optional .control.planning_internal.STGraphDebug.STGraphKernelFollowRef kernel_follow_ref = 7;
  bool has_kernel_follow_ref() const;
  void clear_kernel_follow_ref() ;
  const ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef& kernel_follow_ref() const;
  PROTOBUF_NODISCARD ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* release_kernel_follow_ref();
  ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* mutable_kernel_follow_ref();
  void set_allocated_kernel_follow_ref(::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* value);
  void unsafe_arena_set_allocated_kernel_follow_ref(::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* value);
  ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* unsafe_arena_release_kernel_follow_ref();

  private:
  const ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef& _internal_kernel_follow_ref() const;
  ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* _internal_mutable_kernel_follow_ref();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.STGraphDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_STGraphDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const STGraphDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::StGraphBoundaryDebug > boundary_;
    ::google::protobuf::RepeatedPtrField< ::control::common::SpeedPoint > speed_limit_;
    ::google::protobuf::RepeatedPtrField< ::control::common::SpeedPoint > speed_profile_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* speed_constraint_;
    ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* kernel_cruise_ref_;
    ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* kernel_follow_ref_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class HybridModelDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.HybridModelDebug) */ {
 public:
  inline HybridModelDebug() : HybridModelDebug(nullptr) {}
  ~HybridModelDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HybridModelDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline HybridModelDebug(const HybridModelDebug& from) : HybridModelDebug(nullptr, from) {}
  inline HybridModelDebug(HybridModelDebug&& from) noexcept
      : HybridModelDebug(nullptr, std::move(from)) {}
  inline HybridModelDebug& operator=(const HybridModelDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline HybridModelDebug& operator=(HybridModelDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HybridModelDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const HybridModelDebug* internal_default_instance() {
    return reinterpret_cast<const HybridModelDebug*>(
        &_HybridModelDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(HybridModelDebug& a, HybridModelDebug& b) { a.Swap(&b); }
  inline void Swap(HybridModelDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HybridModelDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HybridModelDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<HybridModelDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HybridModelDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HybridModelDebug& from) { HybridModelDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HybridModelDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.HybridModelDebug"; }

 protected:
  explicit HybridModelDebug(::google::protobuf::Arena* arena);
  HybridModelDebug(::google::protobuf::Arena* arena, const HybridModelDebug& from);
  HybridModelDebug(::google::protobuf::Arena* arena, HybridModelDebug&& from) noexcept
      : HybridModelDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLearningModelOutputFailReasonFieldNumber = 3,
    kEvaluatedPathReferenceFieldNumber = 4,
    kLearningModelOutputUsageRatioFieldNumber = 2,
    kUsingLearningModelOutputFieldNumber = 1,
  };
  // optional string learning_model_output_fail_reason = 3;
  bool has_learning_model_output_fail_reason() const;
  void clear_learning_model_output_fail_reason() ;
  const std::string& learning_model_output_fail_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_learning_model_output_fail_reason(Arg_&& arg, Args_... args);
  std::string* mutable_learning_model_output_fail_reason();
  PROTOBUF_NODISCARD std::string* release_learning_model_output_fail_reason();
  void set_allocated_learning_model_output_fail_reason(std::string* value);

  private:
  const std::string& _internal_learning_model_output_fail_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_learning_model_output_fail_reason(
      const std::string& value);
  std::string* _internal_mutable_learning_model_output_fail_reason();

  public:
  // optional .control.common.Path evaluated_path_reference = 4;
  bool has_evaluated_path_reference() const;
  void clear_evaluated_path_reference() ;
  const ::control::common::Path& evaluated_path_reference() const;
  PROTOBUF_NODISCARD ::control::common::Path* release_evaluated_path_reference();
  ::control::common::Path* mutable_evaluated_path_reference();
  void set_allocated_evaluated_path_reference(::control::common::Path* value);
  void unsafe_arena_set_allocated_evaluated_path_reference(::control::common::Path* value);
  ::control::common::Path* unsafe_arena_release_evaluated_path_reference();

  private:
  const ::control::common::Path& _internal_evaluated_path_reference() const;
  ::control::common::Path* _internal_mutable_evaluated_path_reference();

  public:
  // optional double learning_model_output_usage_ratio = 2;
  bool has_learning_model_output_usage_ratio() const;
  void clear_learning_model_output_usage_ratio() ;
  double learning_model_output_usage_ratio() const;
  void set_learning_model_output_usage_ratio(double value);

  private:
  double _internal_learning_model_output_usage_ratio() const;
  void _internal_set_learning_model_output_usage_ratio(double value);

  public:
  // optional bool using_learning_model_output = 1 [default = false];
  bool has_using_learning_model_output() const;
  void clear_using_learning_model_output() ;
  bool using_learning_model_output() const;
  void set_using_learning_model_output(bool value);

  private:
  bool _internal_using_learning_model_output() const;
  void _internal_set_using_learning_model_output(bool value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.HybridModelDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      84, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HybridModelDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HybridModelDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr learning_model_output_fail_reason_;
    ::control::common::Path* evaluated_path_reference_;
    double learning_model_output_usage_ratio_;
    bool using_learning_model_output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class DpPolyGraphDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.DpPolyGraphDebug) */ {
 public:
  inline DpPolyGraphDebug() : DpPolyGraphDebug(nullptr) {}
  ~DpPolyGraphDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DpPolyGraphDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline DpPolyGraphDebug(const DpPolyGraphDebug& from) : DpPolyGraphDebug(nullptr, from) {}
  inline DpPolyGraphDebug(DpPolyGraphDebug&& from) noexcept
      : DpPolyGraphDebug(nullptr, std::move(from)) {}
  inline DpPolyGraphDebug& operator=(const DpPolyGraphDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline DpPolyGraphDebug& operator=(DpPolyGraphDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DpPolyGraphDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const DpPolyGraphDebug* internal_default_instance() {
    return reinterpret_cast<const DpPolyGraphDebug*>(
        &_DpPolyGraphDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DpPolyGraphDebug& a, DpPolyGraphDebug& b) { a.Swap(&b); }
  inline void Swap(DpPolyGraphDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DpPolyGraphDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DpPolyGraphDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DpPolyGraphDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DpPolyGraphDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DpPolyGraphDebug& from) { DpPolyGraphDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DpPolyGraphDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.DpPolyGraphDebug"; }

 protected:
  explicit DpPolyGraphDebug(::google::protobuf::Arena* arena);
  DpPolyGraphDebug(::google::protobuf::Arena* arena, const DpPolyGraphDebug& from);
  DpPolyGraphDebug(::google::protobuf::Arena* arena, DpPolyGraphDebug&& from) noexcept
      : DpPolyGraphDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSampleLayerFieldNumber = 1,
    kMinCostPointFieldNumber = 2,
  };
  // repeated .control.planning_internal.SampleLayerDebug sample_layer = 1;
  int sample_layer_size() const;
  private:
  int _internal_sample_layer_size() const;

  public:
  void clear_sample_layer() ;
  ::control::planning_internal::SampleLayerDebug* mutable_sample_layer(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>* mutable_sample_layer();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>& _internal_sample_layer() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>* _internal_mutable_sample_layer();
  public:
  const ::control::planning_internal::SampleLayerDebug& sample_layer(int index) const;
  ::control::planning_internal::SampleLayerDebug* add_sample_layer();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>& sample_layer() const;
  // repeated .control.common.SLPoint min_cost_point = 2;
  int min_cost_point_size() const;
  private:
  int _internal_min_cost_point_size() const;

  public:
  void clear_min_cost_point() ;
  ::control::common::SLPoint* mutable_min_cost_point(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* mutable_min_cost_point();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& _internal_min_cost_point() const;
  ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* _internal_mutable_min_cost_point();
  public:
  const ::control::common::SLPoint& min_cost_point(int index) const;
  ::control::common::SLPoint* add_min_cost_point();
  const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& min_cost_point() const;
  // @@protoc_insertion_point(class_scope:control.planning_internal.DpPolyGraphDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DpPolyGraphDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DpPolyGraphDebug& from_msg);
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::SampleLayerDebug > sample_layer_;
    ::google::protobuf::RepeatedPtrField< ::control::common::SLPoint > min_cost_point_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class CloudReferenceLineResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.CloudReferenceLineResponse) */ {
 public:
  inline CloudReferenceLineResponse() : CloudReferenceLineResponse(nullptr) {}
  ~CloudReferenceLineResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloudReferenceLineResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloudReferenceLineResponse(const CloudReferenceLineResponse& from) : CloudReferenceLineResponse(nullptr, from) {}
  inline CloudReferenceLineResponse(CloudReferenceLineResponse&& from) noexcept
      : CloudReferenceLineResponse(nullptr, std::move(from)) {}
  inline CloudReferenceLineResponse& operator=(const CloudReferenceLineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudReferenceLineResponse& operator=(CloudReferenceLineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloudReferenceLineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloudReferenceLineResponse* internal_default_instance() {
    return reinterpret_cast<const CloudReferenceLineResponse*>(
        &_CloudReferenceLineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(CloudReferenceLineResponse& a, CloudReferenceLineResponse& b) { a.Swap(&b); }
  inline void Swap(CloudReferenceLineResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudReferenceLineResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloudReferenceLineResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CloudReferenceLineResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CloudReferenceLineResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CloudReferenceLineResponse& from) { CloudReferenceLineResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CloudReferenceLineResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.CloudReferenceLineResponse"; }

 protected:
  explicit CloudReferenceLineResponse(::google::protobuf::Arena* arena);
  CloudReferenceLineResponse(::google::protobuf::Arena* arena, const CloudReferenceLineResponse& from);
  CloudReferenceLineResponse(::google::protobuf::Arena* arena, CloudReferenceLineResponse&& from) noexcept
      : CloudReferenceLineResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSegmentFieldNumber = 1,
  };
  // repeated .control.common.Path segment = 1;
  int segment_size() const;
  private:
  int _internal_segment_size() const;

  public:
  void clear_segment() ;
  ::control::common::Path* mutable_segment(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::Path>* mutable_segment();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::Path>& _internal_segment() const;
  ::google::protobuf::RepeatedPtrField<::control::common::Path>* _internal_mutable_segment();
  public:
  const ::control::common::Path& segment(int index) const;
  ::control::common::Path* add_segment();
  const ::google::protobuf::RepeatedPtrField<::control::common::Path>& segment() const;
  // @@protoc_insertion_point(class_scope:control.planning_internal.CloudReferenceLineResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CloudReferenceLineResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CloudReferenceLineResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::control::common::Path > segment_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Trajectories final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.Trajectories) */ {
 public:
  inline Trajectories() : Trajectories(nullptr) {}
  ~Trajectories() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Trajectories(
      ::google::protobuf::internal::ConstantInitialized);

  inline Trajectories(const Trajectories& from) : Trajectories(nullptr, from) {}
  inline Trajectories(Trajectories&& from) noexcept
      : Trajectories(nullptr, std::move(from)) {}
  inline Trajectories& operator=(const Trajectories& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectories& operator=(Trajectories&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trajectories& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trajectories* internal_default_instance() {
    return reinterpret_cast<const Trajectories*>(
        &_Trajectories_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Trajectories& a, Trajectories& b) { a.Swap(&b); }
  inline void Swap(Trajectories* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectories* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trajectories* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Trajectories>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Trajectories& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Trajectories& from) { Trajectories::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Trajectories* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.Trajectories"; }

 protected:
  explicit Trajectories(::google::protobuf::Arena* arena);
  Trajectories(::google::protobuf::Arena* arena, const Trajectories& from);
  Trajectories(::google::protobuf::Arena* arena, Trajectories&& from) noexcept
      : Trajectories(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrajectoryFieldNumber = 1,
  };
  // repeated .control.common.Trajectory trajectory = 1;
  int trajectory_size() const;
  private:
  int _internal_trajectory_size() const;

  public:
  void clear_trajectory() ;
  ::control::common::Trajectory* mutable_trajectory(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>* mutable_trajectory();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>& _internal_trajectory() const;
  ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>* _internal_mutable_trajectory();
  public:
  const ::control::common::Trajectory& trajectory(int index) const;
  ::control::common::Trajectory* add_trajectory();
  const ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>& trajectory() const;
  // @@protoc_insertion_point(class_scope:control.planning_internal.Trajectories)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Trajectories_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Trajectories& from_msg);
    ::google::protobuf::RepeatedPtrField< ::control::common::Trajectory > trajectory_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class DecisionTag final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.DecisionTag) */ {
 public:
  inline DecisionTag() : DecisionTag(nullptr) {}
  ~DecisionTag() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DecisionTag(
      ::google::protobuf::internal::ConstantInitialized);

  inline DecisionTag(const DecisionTag& from) : DecisionTag(nullptr, from) {}
  inline DecisionTag(DecisionTag&& from) noexcept
      : DecisionTag(nullptr, std::move(from)) {}
  inline DecisionTag& operator=(const DecisionTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionTag& operator=(DecisionTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecisionTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecisionTag* internal_default_instance() {
    return reinterpret_cast<const DecisionTag*>(
        &_DecisionTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(DecisionTag& a, DecisionTag& b) { a.Swap(&b); }
  inline void Swap(DecisionTag* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecisionTag* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecisionTag* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DecisionTag>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DecisionTag& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DecisionTag& from) { DecisionTag::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DecisionTag* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.DecisionTag"; }

 protected:
  explicit DecisionTag(::google::protobuf::Arena* arena);
  DecisionTag(::google::protobuf::Arena* arena, const DecisionTag& from);
  DecisionTag(::google::protobuf::Arena* arena, DecisionTag&& from) noexcept
      : DecisionTag(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeciderTagFieldNumber = 1,
    kDecisionFieldNumber = 2,
  };
  // optional string decider_tag = 1;
  bool has_decider_tag() const;
  void clear_decider_tag() ;
  const std::string& decider_tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_decider_tag(Arg_&& arg, Args_... args);
  std::string* mutable_decider_tag();
  PROTOBUF_NODISCARD std::string* release_decider_tag();
  void set_allocated_decider_tag(std::string* value);

  private:
  const std::string& _internal_decider_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decider_tag(
      const std::string& value);
  std::string* _internal_mutable_decider_tag();

  public:
  // optional .control.planning.ObjectDecisionType decision = 2;
  bool has_decision() const;
  void clear_decision() ;
  const ::control::planning::ObjectDecisionType& decision() const;
  PROTOBUF_NODISCARD ::control::planning::ObjectDecisionType* release_decision();
  ::control::planning::ObjectDecisionType* mutable_decision();
  void set_allocated_decision(::control::planning::ObjectDecisionType* value);
  void unsafe_arena_set_allocated_decision(::control::planning::ObjectDecisionType* value);
  ::control::planning::ObjectDecisionType* unsafe_arena_release_decision();

  private:
  const ::control::planning::ObjectDecisionType& _internal_decision() const;
  ::control::planning::ObjectDecisionType* _internal_mutable_decision();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.DecisionTag)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      57, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DecisionTag_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DecisionTag& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr decider_tag_;
    ::control::planning::ObjectDecisionType* decision_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class ObstacleDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.ObstacleDebug) */ {
 public:
  inline ObstacleDebug() : ObstacleDebug(nullptr) {}
  ~ObstacleDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObstacleDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObstacleDebug(const ObstacleDebug& from) : ObstacleDebug(nullptr, from) {}
  inline ObstacleDebug(ObstacleDebug&& from) noexcept
      : ObstacleDebug(nullptr, std::move(from)) {}
  inline ObstacleDebug& operator=(const ObstacleDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleDebug& operator=(ObstacleDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleDebug* internal_default_instance() {
    return reinterpret_cast<const ObstacleDebug*>(
        &_ObstacleDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ObstacleDebug& a, ObstacleDebug& b) { a.Swap(&b); }
  inline void Swap(ObstacleDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ObstacleDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObstacleDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObstacleDebug& from) { ObstacleDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObstacleDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.ObstacleDebug"; }

 protected:
  explicit ObstacleDebug(::google::protobuf::Arena* arena);
  ObstacleDebug(::google::protobuf::Arena* arena, const ObstacleDebug& from);
  ObstacleDebug(::google::protobuf::Arena* arena, ObstacleDebug&& from) noexcept
      : ObstacleDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDecisionTagFieldNumber = 3,
    kVerticesXCoordsFieldNumber = 4,
    kVerticesYCoordsFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // repeated .control.planning_internal.DecisionTag decision_tag = 3;
  int decision_tag_size() const;
  private:
  int _internal_decision_tag_size() const;

  public:
  void clear_decision_tag() ;
  ::control::planning_internal::DecisionTag* mutable_decision_tag(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>* mutable_decision_tag();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>& _internal_decision_tag() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>* _internal_mutable_decision_tag();
  public:
  const ::control::planning_internal::DecisionTag& decision_tag(int index) const;
  ::control::planning_internal::DecisionTag* add_decision_tag();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>& decision_tag() const;
  // repeated double vertices_x_coords = 4;
  int vertices_x_coords_size() const;
  private:
  int _internal_vertices_x_coords_size() const;

  public:
  void clear_vertices_x_coords() ;
  double vertices_x_coords(int index) const;
  void set_vertices_x_coords(int index, double value);
  void add_vertices_x_coords(double value);
  const ::google::protobuf::RepeatedField<double>& vertices_x_coords() const;
  ::google::protobuf::RepeatedField<double>* mutable_vertices_x_coords();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_vertices_x_coords() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_vertices_x_coords();

  public:
  // repeated double vertices_y_coords = 5;
  int vertices_y_coords_size() const;
  private:
  int _internal_vertices_y_coords_size() const;

  public:
  void clear_vertices_y_coords() ;
  double vertices_y_coords(int index) const;
  void set_vertices_y_coords(int index, double value);
  void add_vertices_y_coords(double value);
  const ::google::protobuf::RepeatedField<double>& vertices_y_coords() const;
  ::google::protobuf::RepeatedField<double>* mutable_vertices_y_coords();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_vertices_y_coords() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_vertices_y_coords();

  public:
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.ObstacleDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 1,
      50, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObstacleDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObstacleDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::DecisionTag > decision_tag_;
    ::google::protobuf::RepeatedField<double> vertices_x_coords_;
    ::google::protobuf::RepeatedField<double> vertices_y_coords_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class OpenSpaceDebug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.OpenSpaceDebug) */ {
 public:
  inline OpenSpaceDebug() : OpenSpaceDebug(nullptr) {}
  ~OpenSpaceDebug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpenSpaceDebug(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpenSpaceDebug(const OpenSpaceDebug& from) : OpenSpaceDebug(nullptr, from) {}
  inline OpenSpaceDebug(OpenSpaceDebug&& from) noexcept
      : OpenSpaceDebug(nullptr, std::move(from)) {}
  inline OpenSpaceDebug& operator=(const OpenSpaceDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenSpaceDebug& operator=(OpenSpaceDebug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenSpaceDebug& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenSpaceDebug* internal_default_instance() {
    return reinterpret_cast<const OpenSpaceDebug*>(
        &_OpenSpaceDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(OpenSpaceDebug& a, OpenSpaceDebug& b) { a.Swap(&b); }
  inline void Swap(OpenSpaceDebug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenSpaceDebug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenSpaceDebug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OpenSpaceDebug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpenSpaceDebug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpenSpaceDebug& from) { OpenSpaceDebug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpenSpaceDebug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.OpenSpaceDebug"; }

 protected:
  explicit OpenSpaceDebug(::google::protobuf::Arena* arena);
  OpenSpaceDebug(::google::protobuf::Arena* arena, const OpenSpaceDebug& from);
  OpenSpaceDebug(::google::protobuf::Arena* arena, OpenSpaceDebug&& from) noexcept
      : OpenSpaceDebug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarmStartDualLambdaFieldNumber = 4,
    kWarmStartDualMiuFieldNumber = 5,
    kOptimizedDualLambdaFieldNumber = 6,
    kOptimizedDualMiuFieldNumber = 7,
    kXyBoundaryFieldNumber = 8,
    kObstaclesFieldNumber = 9,
    kTrajectoriesFieldNumber = 1,
    kWarmStartTrajectoryFieldNumber = 2,
    kSmoothedTrajectoryFieldNumber = 3,
    kRoiShiftPointFieldNumber = 10,
    kEndPointFieldNumber = 11,
    kPartitionedTrajectoriesFieldNumber = 12,
    kChosenTrajectoryFieldNumber = 13,
    kFallbackTrajectoryFieldNumber = 15,
    kTrajectoryStitchingPointFieldNumber = 16,
    kFutureCollisionPointFieldNumber = 17,
    kOriginPointFieldNumber = 19,
    kTimeLatencyFieldNumber = 18,
    kOriginHeadingRadFieldNumber = 20,
    kIsFallbackTrajectoryFieldNumber = 14,
  };
  // repeated double warm_start_dual_lambda = 4;
  int warm_start_dual_lambda_size() const;
  private:
  int _internal_warm_start_dual_lambda_size() const;

  public:
  void clear_warm_start_dual_lambda() ;
  double warm_start_dual_lambda(int index) const;
  void set_warm_start_dual_lambda(int index, double value);
  void add_warm_start_dual_lambda(double value);
  const ::google::protobuf::RepeatedField<double>& warm_start_dual_lambda() const;
  ::google::protobuf::RepeatedField<double>* mutable_warm_start_dual_lambda();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_warm_start_dual_lambda() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_warm_start_dual_lambda();

  public:
  // repeated double warm_start_dual_miu = 5;
  int warm_start_dual_miu_size() const;
  private:
  int _internal_warm_start_dual_miu_size() const;

  public:
  void clear_warm_start_dual_miu() ;
  double warm_start_dual_miu(int index) const;
  void set_warm_start_dual_miu(int index, double value);
  void add_warm_start_dual_miu(double value);
  const ::google::protobuf::RepeatedField<double>& warm_start_dual_miu() const;
  ::google::protobuf::RepeatedField<double>* mutable_warm_start_dual_miu();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_warm_start_dual_miu() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_warm_start_dual_miu();

  public:
  // repeated double optimized_dual_lambda = 6;
  int optimized_dual_lambda_size() const;
  private:
  int _internal_optimized_dual_lambda_size() const;

  public:
  void clear_optimized_dual_lambda() ;
  double optimized_dual_lambda(int index) const;
  void set_optimized_dual_lambda(int index, double value);
  void add_optimized_dual_lambda(double value);
  const ::google::protobuf::RepeatedField<double>& optimized_dual_lambda() const;
  ::google::protobuf::RepeatedField<double>* mutable_optimized_dual_lambda();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_optimized_dual_lambda() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_optimized_dual_lambda();

  public:
  // repeated double optimized_dual_miu = 7;
  int optimized_dual_miu_size() const;
  private:
  int _internal_optimized_dual_miu_size() const;

  public:
  void clear_optimized_dual_miu() ;
  double optimized_dual_miu(int index) const;
  void set_optimized_dual_miu(int index, double value);
  void add_optimized_dual_miu(double value);
  const ::google::protobuf::RepeatedField<double>& optimized_dual_miu() const;
  ::google::protobuf::RepeatedField<double>* mutable_optimized_dual_miu();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_optimized_dual_miu() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_optimized_dual_miu();

  public:
  // repeated double xy_boundary = 8;
  int xy_boundary_size() const;
  private:
  int _internal_xy_boundary_size() const;

  public:
  void clear_xy_boundary() ;
  double xy_boundary(int index) const;
  void set_xy_boundary(int index, double value);
  void add_xy_boundary(double value);
  const ::google::protobuf::RepeatedField<double>& xy_boundary() const;
  ::google::protobuf::RepeatedField<double>* mutable_xy_boundary();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_xy_boundary() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_xy_boundary();

  public:
  // repeated .control.planning_internal.ObstacleDebug obstacles = 9;
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;

  public:
  void clear_obstacles() ;
  ::control::planning_internal::ObstacleDebug* mutable_obstacles(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>* mutable_obstacles();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>& _internal_obstacles() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>* _internal_mutable_obstacles();
  public:
  const ::control::planning_internal::ObstacleDebug& obstacles(int index) const;
  ::control::planning_internal::ObstacleDebug* add_obstacles();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>& obstacles() const;
  // optional .control.planning_internal.Trajectories trajectories = 1;
  bool has_trajectories() const;
  void clear_trajectories() ;
  const ::control::planning_internal::Trajectories& trajectories() const;
  PROTOBUF_NODISCARD ::control::planning_internal::Trajectories* release_trajectories();
  ::control::planning_internal::Trajectories* mutable_trajectories();
  void set_allocated_trajectories(::control::planning_internal::Trajectories* value);
  void unsafe_arena_set_allocated_trajectories(::control::planning_internal::Trajectories* value);
  ::control::planning_internal::Trajectories* unsafe_arena_release_trajectories();

  private:
  const ::control::planning_internal::Trajectories& _internal_trajectories() const;
  ::control::planning_internal::Trajectories* _internal_mutable_trajectories();

  public:
  // optional .control.common.VehicleMotion warm_start_trajectory = 2;
  bool has_warm_start_trajectory() const;
  void clear_warm_start_trajectory() ;
  const ::control::common::VehicleMotion& warm_start_trajectory() const;
  PROTOBUF_NODISCARD ::control::common::VehicleMotion* release_warm_start_trajectory();
  ::control::common::VehicleMotion* mutable_warm_start_trajectory();
  void set_allocated_warm_start_trajectory(::control::common::VehicleMotion* value);
  void unsafe_arena_set_allocated_warm_start_trajectory(::control::common::VehicleMotion* value);
  ::control::common::VehicleMotion* unsafe_arena_release_warm_start_trajectory();

  private:
  const ::control::common::VehicleMotion& _internal_warm_start_trajectory() const;
  ::control::common::VehicleMotion* _internal_mutable_warm_start_trajectory();

  public:
  // optional .control.common.VehicleMotion smoothed_trajectory = 3;
  bool has_smoothed_trajectory() const;
  void clear_smoothed_trajectory() ;
  const ::control::common::VehicleMotion& smoothed_trajectory() const;
  PROTOBUF_NODISCARD ::control::common::VehicleMotion* release_smoothed_trajectory();
  ::control::common::VehicleMotion* mutable_smoothed_trajectory();
  void set_allocated_smoothed_trajectory(::control::common::VehicleMotion* value);
  void unsafe_arena_set_allocated_smoothed_trajectory(::control::common::VehicleMotion* value);
  ::control::common::VehicleMotion* unsafe_arena_release_smoothed_trajectory();

  private:
  const ::control::common::VehicleMotion& _internal_smoothed_trajectory() const;
  ::control::common::VehicleMotion* _internal_mutable_smoothed_trajectory();

  public:
  // optional .control.common.TrajectoryPoint roi_shift_point = 10;
  bool has_roi_shift_point() const;
  void clear_roi_shift_point() ;
  const ::control::common::TrajectoryPoint& roi_shift_point() const;
  PROTOBUF_NODISCARD ::control::common::TrajectoryPoint* release_roi_shift_point();
  ::control::common::TrajectoryPoint* mutable_roi_shift_point();
  void set_allocated_roi_shift_point(::control::common::TrajectoryPoint* value);
  void unsafe_arena_set_allocated_roi_shift_point(::control::common::TrajectoryPoint* value);
  ::control::common::TrajectoryPoint* unsafe_arena_release_roi_shift_point();

  private:
  const ::control::common::TrajectoryPoint& _internal_roi_shift_point() const;
  ::control::common::TrajectoryPoint* _internal_mutable_roi_shift_point();

  public:
  // optional .control.common.TrajectoryPoint end_point = 11;
  bool has_end_point() const;
  void clear_end_point() ;
  const ::control::common::TrajectoryPoint& end_point() const;
  PROTOBUF_NODISCARD ::control::common::TrajectoryPoint* release_end_point();
  ::control::common::TrajectoryPoint* mutable_end_point();
  void set_allocated_end_point(::control::common::TrajectoryPoint* value);
  void unsafe_arena_set_allocated_end_point(::control::common::TrajectoryPoint* value);
  ::control::common::TrajectoryPoint* unsafe_arena_release_end_point();

  private:
  const ::control::common::TrajectoryPoint& _internal_end_point() const;
  ::control::common::TrajectoryPoint* _internal_mutable_end_point();

  public:
  // optional .control.planning_internal.Trajectories partitioned_trajectories = 12;
  bool has_partitioned_trajectories() const;
  void clear_partitioned_trajectories() ;
  const ::control::planning_internal::Trajectories& partitioned_trajectories() const;
  PROTOBUF_NODISCARD ::control::planning_internal::Trajectories* release_partitioned_trajectories();
  ::control::planning_internal::Trajectories* mutable_partitioned_trajectories();
  void set_allocated_partitioned_trajectories(::control::planning_internal::Trajectories* value);
  void unsafe_arena_set_allocated_partitioned_trajectories(::control::planning_internal::Trajectories* value);
  ::control::planning_internal::Trajectories* unsafe_arena_release_partitioned_trajectories();

  private:
  const ::control::planning_internal::Trajectories& _internal_partitioned_trajectories() const;
  ::control::planning_internal::Trajectories* _internal_mutable_partitioned_trajectories();

  public:
  // optional .control.planning_internal.Trajectories chosen_trajectory = 13;
  bool has_chosen_trajectory() const;
  void clear_chosen_trajectory() ;
  const ::control::planning_internal::Trajectories& chosen_trajectory() const;
  PROTOBUF_NODISCARD ::control::planning_internal::Trajectories* release_chosen_trajectory();
  ::control::planning_internal::Trajectories* mutable_chosen_trajectory();
  void set_allocated_chosen_trajectory(::control::planning_internal::Trajectories* value);
  void unsafe_arena_set_allocated_chosen_trajectory(::control::planning_internal::Trajectories* value);
  ::control::planning_internal::Trajectories* unsafe_arena_release_chosen_trajectory();

  private:
  const ::control::planning_internal::Trajectories& _internal_chosen_trajectory() const;
  ::control::planning_internal::Trajectories* _internal_mutable_chosen_trajectory();

  public:
  // optional .control.planning_internal.Trajectories fallback_trajectory = 15;
  bool has_fallback_trajectory() const;
  void clear_fallback_trajectory() ;
  const ::control::planning_internal::Trajectories& fallback_trajectory() const;
  PROTOBUF_NODISCARD ::control::planning_internal::Trajectories* release_fallback_trajectory();
  ::control::planning_internal::Trajectories* mutable_fallback_trajectory();
  void set_allocated_fallback_trajectory(::control::planning_internal::Trajectories* value);
  void unsafe_arena_set_allocated_fallback_trajectory(::control::planning_internal::Trajectories* value);
  ::control::planning_internal::Trajectories* unsafe_arena_release_fallback_trajectory();

  private:
  const ::control::planning_internal::Trajectories& _internal_fallback_trajectory() const;
  ::control::planning_internal::Trajectories* _internal_mutable_fallback_trajectory();

  public:
  // optional .control.common.TrajectoryPoint trajectory_stitching_point = 16;
  bool has_trajectory_stitching_point() const;
  void clear_trajectory_stitching_point() ;
  const ::control::common::TrajectoryPoint& trajectory_stitching_point() const;
  PROTOBUF_NODISCARD ::control::common::TrajectoryPoint* release_trajectory_stitching_point();
  ::control::common::TrajectoryPoint* mutable_trajectory_stitching_point();
  void set_allocated_trajectory_stitching_point(::control::common::TrajectoryPoint* value);
  void unsafe_arena_set_allocated_trajectory_stitching_point(::control::common::TrajectoryPoint* value);
  ::control::common::TrajectoryPoint* unsafe_arena_release_trajectory_stitching_point();

  private:
  const ::control::common::TrajectoryPoint& _internal_trajectory_stitching_point() const;
  ::control::common::TrajectoryPoint* _internal_mutable_trajectory_stitching_point();

  public:
  // optional .control.common.TrajectoryPoint future_collision_point = 17;
  bool has_future_collision_point() const;
  void clear_future_collision_point() ;
  const ::control::common::TrajectoryPoint& future_collision_point() const;
  PROTOBUF_NODISCARD ::control::common::TrajectoryPoint* release_future_collision_point();
  ::control::common::TrajectoryPoint* mutable_future_collision_point();
  void set_allocated_future_collision_point(::control::common::TrajectoryPoint* value);
  void unsafe_arena_set_allocated_future_collision_point(::control::common::TrajectoryPoint* value);
  ::control::common::TrajectoryPoint* unsafe_arena_release_future_collision_point();

  private:
  const ::control::common::TrajectoryPoint& _internal_future_collision_point() const;
  ::control::common::TrajectoryPoint* _internal_mutable_future_collision_point();

  public:
  // optional .control.common.PointENU origin_point = 19;
  bool has_origin_point() const;
  void clear_origin_point() ;
  const ::control::common::PointENU& origin_point() const;
  PROTOBUF_NODISCARD ::control::common::PointENU* release_origin_point();
  ::control::common::PointENU* mutable_origin_point();
  void set_allocated_origin_point(::control::common::PointENU* value);
  void unsafe_arena_set_allocated_origin_point(::control::common::PointENU* value);
  ::control::common::PointENU* unsafe_arena_release_origin_point();

  private:
  const ::control::common::PointENU& _internal_origin_point() const;
  ::control::common::PointENU* _internal_mutable_origin_point();

  public:
  // optional double time_latency = 18 [default = 0];
  bool has_time_latency() const;
  void clear_time_latency() ;
  double time_latency() const;
  void set_time_latency(double value);

  private:
  double _internal_time_latency() const;
  void _internal_set_time_latency(double value);

  public:
  // optional double origin_heading_rad = 20;
  bool has_origin_heading_rad() const;
  void clear_origin_heading_rad() ;
  double origin_heading_rad() const;
  void set_origin_heading_rad(double value);

  private:
  double _internal_origin_heading_rad() const;
  void _internal_set_origin_heading_rad(double value);

  public:
  // optional bool is_fallback_trajectory = 14;
  bool has_is_fallback_trajectory() const;
  void clear_is_fallback_trajectory() ;
  bool is_fallback_trajectory() const;
  void set_is_fallback_trajectory(bool value);

  private:
  bool _internal_is_fallback_trajectory() const;
  void _internal_set_is_fallback_trajectory(bool value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.OpenSpaceDebug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 20, 12,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_OpenSpaceDebug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OpenSpaceDebug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> warm_start_dual_lambda_;
    ::google::protobuf::RepeatedField<double> warm_start_dual_miu_;
    ::google::protobuf::RepeatedField<double> optimized_dual_lambda_;
    ::google::protobuf::RepeatedField<double> optimized_dual_miu_;
    ::google::protobuf::RepeatedField<double> xy_boundary_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::ObstacleDebug > obstacles_;
    ::control::planning_internal::Trajectories* trajectories_;
    ::control::common::VehicleMotion* warm_start_trajectory_;
    ::control::common::VehicleMotion* smoothed_trajectory_;
    ::control::common::TrajectoryPoint* roi_shift_point_;
    ::control::common::TrajectoryPoint* end_point_;
    ::control::planning_internal::Trajectories* partitioned_trajectories_;
    ::control::planning_internal::Trajectories* chosen_trajectory_;
    ::control::planning_internal::Trajectories* fallback_trajectory_;
    ::control::common::TrajectoryPoint* trajectory_stitching_point_;
    ::control::common::TrajectoryPoint* future_collision_point_;
    ::control::common::PointENU* origin_point_;
    double time_latency_;
    double origin_heading_rad_;
    bool is_fallback_trajectory_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class PlanningData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.PlanningData) */ {
 public:
  inline PlanningData() : PlanningData(nullptr) {}
  ~PlanningData() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlanningData(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlanningData(const PlanningData& from) : PlanningData(nullptr, from) {}
  inline PlanningData(PlanningData&& from) noexcept
      : PlanningData(nullptr, std::move(from)) {}
  inline PlanningData& operator=(const PlanningData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningData& operator=(PlanningData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanningData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanningData* internal_default_instance() {
    return reinterpret_cast<const PlanningData*>(
        &_PlanningData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(PlanningData& a, PlanningData& b) { a.Swap(&b); }
  inline void Swap(PlanningData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanningData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanningData* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PlanningData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanningData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlanningData& from) { PlanningData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanningData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.PlanningData"; }

 protected:
  explicit PlanningData(::google::protobuf::Arena* arena);
  PlanningData(::google::protobuf::Arena* arena, const PlanningData& from);
  PlanningData(::google::protobuf::Arena* arena, PlanningData&& from) noexcept
      : PlanningData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 6,
    kSpeedPlanFieldNumber = 13,
    kStGraphFieldNumber = 14,
    kSlFrameFieldNumber = 15,
    kObstacleFieldNumber = 18,
    kReferenceLineFieldNumber = 19,
    kAdcPositionFieldNumber = 7,
    kChassisFieldNumber = 8,
    kInitPointFieldNumber = 10,
    kPredictionHeaderFieldNumber = 16,
    kDpPolyGraphFieldNumber = 20,
    kLatticeStImageFieldNumber = 21,
    kAutoTuningTrainingDataFieldNumber = 23,
    kScenarioFieldNumber = 26,
    kOpenSpaceFieldNumber = 27,
    kSmootherFieldNumber = 28,
    kPullOverFieldNumber = 29,
    kHybridModelFieldNumber = 30,
    kFrontClearDistanceFieldNumber = 24,
  };
  // repeated .control.common.Path path = 6;
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::control::common::Path* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField<::control::common::Path>* mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::common::Path>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::control::common::Path>* _internal_mutable_path();
  public:
  const ::control::common::Path& path(int index) const;
  ::control::common::Path* add_path();
  const ::google::protobuf::RepeatedPtrField<::control::common::Path>& path() const;
  // repeated .control.planning_internal.SpeedPlan speed_plan = 13;
  int speed_plan_size() const;
  private:
  int _internal_speed_plan_size() const;

  public:
  void clear_speed_plan() ;
  ::control::planning_internal::SpeedPlan* mutable_speed_plan(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>* mutable_speed_plan();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>& _internal_speed_plan() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>* _internal_mutable_speed_plan();
  public:
  const ::control::planning_internal::SpeedPlan& speed_plan(int index) const;
  ::control::planning_internal::SpeedPlan* add_speed_plan();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>& speed_plan() const;
  // repeated .control.planning_internal.STGraphDebug st_graph = 14;
  int st_graph_size() const;
  private:
  int _internal_st_graph_size() const;

  public:
  void clear_st_graph() ;
  ::control::planning_internal::STGraphDebug* mutable_st_graph(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>* mutable_st_graph();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>& _internal_st_graph() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>* _internal_mutable_st_graph();
  public:
  const ::control::planning_internal::STGraphDebug& st_graph(int index) const;
  ::control::planning_internal::STGraphDebug* add_st_graph();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>& st_graph() const;
  // repeated .control.planning_internal.SLFrameDebug sl_frame = 15;
  int sl_frame_size() const;
  private:
  int _internal_sl_frame_size() const;

  public:
  void clear_sl_frame() ;
  ::control::planning_internal::SLFrameDebug* mutable_sl_frame(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>* mutable_sl_frame();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>& _internal_sl_frame() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>* _internal_mutable_sl_frame();
  public:
  const ::control::planning_internal::SLFrameDebug& sl_frame(int index) const;
  ::control::planning_internal::SLFrameDebug* add_sl_frame();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>& sl_frame() const;
  // repeated .control.planning_internal.ObstacleDebug obstacle = 18;
  int obstacle_size() const;
  private:
  int _internal_obstacle_size() const;

  public:
  void clear_obstacle() ;
  ::control::planning_internal::ObstacleDebug* mutable_obstacle(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>* mutable_obstacle();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>& _internal_obstacle() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>* _internal_mutable_obstacle();
  public:
  const ::control::planning_internal::ObstacleDebug& obstacle(int index) const;
  ::control::planning_internal::ObstacleDebug* add_obstacle();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>& obstacle() const;
  // repeated .control.planning_internal.ReferenceLineDebug reference_line = 19;
  int reference_line_size() const;
  private:
  int _internal_reference_line_size() const;

  public:
  void clear_reference_line() ;
  ::control::planning_internal::ReferenceLineDebug* mutable_reference_line(int index);
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>* mutable_reference_line();

  private:
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>& _internal_reference_line() const;
  ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>* _internal_mutable_reference_line();
  public:
  const ::control::planning_internal::ReferenceLineDebug& reference_line(int index) const;
  ::control::planning_internal::ReferenceLineDebug* add_reference_line();
  const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>& reference_line() const;
  // optional .control.localization.LocalizationEstimate adc_position = 7;
  bool has_adc_position() const;
  void clear_adc_position() ;
  const ::control::localization::LocalizationEstimate& adc_position() const;
  PROTOBUF_NODISCARD ::control::localization::LocalizationEstimate* release_adc_position();
  ::control::localization::LocalizationEstimate* mutable_adc_position();
  void set_allocated_adc_position(::control::localization::LocalizationEstimate* value);
  void unsafe_arena_set_allocated_adc_position(::control::localization::LocalizationEstimate* value);
  ::control::localization::LocalizationEstimate* unsafe_arena_release_adc_position();

  private:
  const ::control::localization::LocalizationEstimate& _internal_adc_position() const;
  ::control::localization::LocalizationEstimate* _internal_mutable_adc_position();

  public:
  // optional .control.canbus.Chassis chassis = 8;
  bool has_chassis() const;
  void clear_chassis() ;
  const ::control::canbus::Chassis& chassis() const;
  PROTOBUF_NODISCARD ::control::canbus::Chassis* release_chassis();
  ::control::canbus::Chassis* mutable_chassis();
  void set_allocated_chassis(::control::canbus::Chassis* value);
  void unsafe_arena_set_allocated_chassis(::control::canbus::Chassis* value);
  ::control::canbus::Chassis* unsafe_arena_release_chassis();

  private:
  const ::control::canbus::Chassis& _internal_chassis() const;
  ::control::canbus::Chassis* _internal_mutable_chassis();

  public:
  // optional .control.common.TrajectoryPoint init_point = 10;
  bool has_init_point() const;
  void clear_init_point() ;
  const ::control::common::TrajectoryPoint& init_point() const;
  PROTOBUF_NODISCARD ::control::common::TrajectoryPoint* release_init_point();
  ::control::common::TrajectoryPoint* mutable_init_point();
  void set_allocated_init_point(::control::common::TrajectoryPoint* value);
  void unsafe_arena_set_allocated_init_point(::control::common::TrajectoryPoint* value);
  ::control::common::TrajectoryPoint* unsafe_arena_release_init_point();

  private:
  const ::control::common::TrajectoryPoint& _internal_init_point() const;
  ::control::common::TrajectoryPoint* _internal_mutable_init_point();

  public:
  // optional .control.common.Header prediction_header = 16;
  bool has_prediction_header() const;
  void clear_prediction_header() ;
  const ::control::common::Header& prediction_header() const;
  PROTOBUF_NODISCARD ::control::common::Header* release_prediction_header();
  ::control::common::Header* mutable_prediction_header();
  void set_allocated_prediction_header(::control::common::Header* value);
  void unsafe_arena_set_allocated_prediction_header(::control::common::Header* value);
  ::control::common::Header* unsafe_arena_release_prediction_header();

  private:
  const ::control::common::Header& _internal_prediction_header() const;
  ::control::common::Header* _internal_mutable_prediction_header();

  public:
  // optional .control.planning_internal.DpPolyGraphDebug dp_poly_graph = 20;
  bool has_dp_poly_graph() const;
  void clear_dp_poly_graph() ;
  const ::control::planning_internal::DpPolyGraphDebug& dp_poly_graph() const;
  PROTOBUF_NODISCARD ::control::planning_internal::DpPolyGraphDebug* release_dp_poly_graph();
  ::control::planning_internal::DpPolyGraphDebug* mutable_dp_poly_graph();
  void set_allocated_dp_poly_graph(::control::planning_internal::DpPolyGraphDebug* value);
  void unsafe_arena_set_allocated_dp_poly_graph(::control::planning_internal::DpPolyGraphDebug* value);
  ::control::planning_internal::DpPolyGraphDebug* unsafe_arena_release_dp_poly_graph();

  private:
  const ::control::planning_internal::DpPolyGraphDebug& _internal_dp_poly_graph() const;
  ::control::planning_internal::DpPolyGraphDebug* _internal_mutable_dp_poly_graph();

  public:
  // optional .control.planning_internal.LatticeStTraining lattice_st_image = 21;
  bool has_lattice_st_image() const;
  void clear_lattice_st_image() ;
  const ::control::planning_internal::LatticeStTraining& lattice_st_image() const;
  PROTOBUF_NODISCARD ::control::planning_internal::LatticeStTraining* release_lattice_st_image();
  ::control::planning_internal::LatticeStTraining* mutable_lattice_st_image();
  void set_allocated_lattice_st_image(::control::planning_internal::LatticeStTraining* value);
  void unsafe_arena_set_allocated_lattice_st_image(::control::planning_internal::LatticeStTraining* value);
  ::control::planning_internal::LatticeStTraining* unsafe_arena_release_lattice_st_image();

  private:
  const ::control::planning_internal::LatticeStTraining& _internal_lattice_st_image() const;
  ::control::planning_internal::LatticeStTraining* _internal_mutable_lattice_st_image();

  public:
  // optional .control.planning_internal.AutoTuningTrainingData auto_tuning_training_data = 23;
  bool has_auto_tuning_training_data() const;
  void clear_auto_tuning_training_data() ;
  const ::control::planning_internal::AutoTuningTrainingData& auto_tuning_training_data() const;
  PROTOBUF_NODISCARD ::control::planning_internal::AutoTuningTrainingData* release_auto_tuning_training_data();
  ::control::planning_internal::AutoTuningTrainingData* mutable_auto_tuning_training_data();
  void set_allocated_auto_tuning_training_data(::control::planning_internal::AutoTuningTrainingData* value);
  void unsafe_arena_set_allocated_auto_tuning_training_data(::control::planning_internal::AutoTuningTrainingData* value);
  ::control::planning_internal::AutoTuningTrainingData* unsafe_arena_release_auto_tuning_training_data();

  private:
  const ::control::planning_internal::AutoTuningTrainingData& _internal_auto_tuning_training_data() const;
  ::control::planning_internal::AutoTuningTrainingData* _internal_mutable_auto_tuning_training_data();

  public:
  // optional .control.planning_internal.ScenarioDebug scenario = 26;
  bool has_scenario() const;
  void clear_scenario() ;
  const ::control::planning_internal::ScenarioDebug& scenario() const;
  PROTOBUF_NODISCARD ::control::planning_internal::ScenarioDebug* release_scenario();
  ::control::planning_internal::ScenarioDebug* mutable_scenario();
  void set_allocated_scenario(::control::planning_internal::ScenarioDebug* value);
  void unsafe_arena_set_allocated_scenario(::control::planning_internal::ScenarioDebug* value);
  ::control::planning_internal::ScenarioDebug* unsafe_arena_release_scenario();

  private:
  const ::control::planning_internal::ScenarioDebug& _internal_scenario() const;
  ::control::planning_internal::ScenarioDebug* _internal_mutable_scenario();

  public:
  // optional .control.planning_internal.OpenSpaceDebug open_space = 27;
  bool has_open_space() const;
  void clear_open_space() ;
  const ::control::planning_internal::OpenSpaceDebug& open_space() const;
  PROTOBUF_NODISCARD ::control::planning_internal::OpenSpaceDebug* release_open_space();
  ::control::planning_internal::OpenSpaceDebug* mutable_open_space();
  void set_allocated_open_space(::control::planning_internal::OpenSpaceDebug* value);
  void unsafe_arena_set_allocated_open_space(::control::planning_internal::OpenSpaceDebug* value);
  ::control::planning_internal::OpenSpaceDebug* unsafe_arena_release_open_space();

  private:
  const ::control::planning_internal::OpenSpaceDebug& _internal_open_space() const;
  ::control::planning_internal::OpenSpaceDebug* _internal_mutable_open_space();

  public:
  // optional .control.planning_internal.SmootherDebug smoother = 28;
  bool has_smoother() const;
  void clear_smoother() ;
  const ::control::planning_internal::SmootherDebug& smoother() const;
  PROTOBUF_NODISCARD ::control::planning_internal::SmootherDebug* release_smoother();
  ::control::planning_internal::SmootherDebug* mutable_smoother();
  void set_allocated_smoother(::control::planning_internal::SmootherDebug* value);
  void unsafe_arena_set_allocated_smoother(::control::planning_internal::SmootherDebug* value);
  ::control::planning_internal::SmootherDebug* unsafe_arena_release_smoother();

  private:
  const ::control::planning_internal::SmootherDebug& _internal_smoother() const;
  ::control::planning_internal::SmootherDebug* _internal_mutable_smoother();

  public:
  // optional .control.planning_internal.PullOverDebug pull_over = 29;
  bool has_pull_over() const;
  void clear_pull_over() ;
  const ::control::planning_internal::PullOverDebug& pull_over() const;
  PROTOBUF_NODISCARD ::control::planning_internal::PullOverDebug* release_pull_over();
  ::control::planning_internal::PullOverDebug* mutable_pull_over();
  void set_allocated_pull_over(::control::planning_internal::PullOverDebug* value);
  void unsafe_arena_set_allocated_pull_over(::control::planning_internal::PullOverDebug* value);
  ::control::planning_internal::PullOverDebug* unsafe_arena_release_pull_over();

  private:
  const ::control::planning_internal::PullOverDebug& _internal_pull_over() const;
  ::control::planning_internal::PullOverDebug* _internal_mutable_pull_over();

  public:
  // optional .control.planning_internal.HybridModelDebug hybrid_model = 30;
  bool has_hybrid_model() const;
  void clear_hybrid_model() ;
  const ::control::planning_internal::HybridModelDebug& hybrid_model() const;
  PROTOBUF_NODISCARD ::control::planning_internal::HybridModelDebug* release_hybrid_model();
  ::control::planning_internal::HybridModelDebug* mutable_hybrid_model();
  void set_allocated_hybrid_model(::control::planning_internal::HybridModelDebug* value);
  void unsafe_arena_set_allocated_hybrid_model(::control::planning_internal::HybridModelDebug* value);
  ::control::planning_internal::HybridModelDebug* unsafe_arena_release_hybrid_model();

  private:
  const ::control::planning_internal::HybridModelDebug& _internal_hybrid_model() const;
  ::control::planning_internal::HybridModelDebug* _internal_mutable_hybrid_model();

  public:
  // optional double front_clear_distance = 24;
  bool has_front_clear_distance() const;
  void clear_front_clear_distance() ;
  double front_clear_distance() const;
  void set_front_clear_distance(double value);

  private:
  double _internal_front_clear_distance() const;
  void _internal_set_front_clear_distance(double value);

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.PlanningData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 18,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlanningData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlanningData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::control::common::Path > path_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::SpeedPlan > speed_plan_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::STGraphDebug > st_graph_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::SLFrameDebug > sl_frame_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::ObstacleDebug > obstacle_;
    ::google::protobuf::RepeatedPtrField< ::control::planning_internal::ReferenceLineDebug > reference_line_;
    ::control::localization::LocalizationEstimate* adc_position_;
    ::control::canbus::Chassis* chassis_;
    ::control::common::TrajectoryPoint* init_point_;
    ::control::common::Header* prediction_header_;
    ::control::planning_internal::DpPolyGraphDebug* dp_poly_graph_;
    ::control::planning_internal::LatticeStTraining* lattice_st_image_;
    ::control::planning_internal::AutoTuningTrainingData* auto_tuning_training_data_;
    ::control::planning_internal::ScenarioDebug* scenario_;
    ::control::planning_internal::OpenSpaceDebug* open_space_;
    ::control::planning_internal::SmootherDebug* smoother_;
    ::control::planning_internal::PullOverDebug* pull_over_;
    ::control::planning_internal::HybridModelDebug* hybrid_model_;
    double front_clear_distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Debug final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control.planning_internal.Debug) */ {
 public:
  inline Debug() : Debug(nullptr) {}
  ~Debug() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Debug(
      ::google::protobuf::internal::ConstantInitialized);

  inline Debug(const Debug& from) : Debug(nullptr, from) {}
  inline Debug(Debug&& from) noexcept
      : Debug(nullptr, std::move(from)) {}
  inline Debug& operator=(const Debug& from) {
    CopyFrom(from);
    return *this;
  }
  inline Debug& operator=(Debug&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Debug& default_instance() {
    return *internal_default_instance();
  }
  static inline const Debug* internal_default_instance() {
    return reinterpret_cast<const Debug*>(
        &_Debug_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Debug& a, Debug& b) { a.Swap(&b); }
  inline void Swap(Debug* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Debug* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Debug* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Debug>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Debug& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Debug& from) { Debug::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  ::size_t ByteSizeLong() const PROTOBUF_FINAL;
  ::uint8_t* _InternalSerialize(::uint8_t* target,
                              ::google::protobuf::io::EpsCopyOutputStream*
                                  stream) const PROTOBUF_FINAL;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Debug* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control.planning_internal.Debug"; }

 protected:
  explicit Debug(::google::protobuf::Arena* arena);
  Debug(::google::protobuf::Arena* arena, const Debug& from);
  Debug(::google::protobuf::Arena* arena, Debug&& from) noexcept
      : Debug(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlanningDataFieldNumber = 2,
  };
  // optional .control.planning_internal.PlanningData planning_data = 2;
  bool has_planning_data() const;
  void clear_planning_data() ;
  const ::control::planning_internal::PlanningData& planning_data() const;
  PROTOBUF_NODISCARD ::control::planning_internal::PlanningData* release_planning_data();
  ::control::planning_internal::PlanningData* mutable_planning_data();
  void set_allocated_planning_data(::control::planning_internal::PlanningData* value);
  void unsafe_arena_set_allocated_planning_data(::control::planning_internal::PlanningData* value);
  ::control::planning_internal::PlanningData* unsafe_arena_release_planning_data();

  private:
  const ::control::planning_internal::PlanningData& _internal_planning_data() const;
  ::control::planning_internal::PlanningData* _internal_mutable_planning_data();

  public:
  // @@protoc_insertion_point(class_scope:control.planning_internal.Debug)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Debug_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Debug& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::control::planning_internal::PlanningData* planning_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_planning_5fmsgs_2fplanning_5finternal_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Debug

// optional .control.planning_internal.PlanningData planning_data = 2;
inline bool Debug::has_planning_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planning_data_ != nullptr);
  return value;
}
inline void Debug::clear_planning_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.planning_data_ != nullptr) _impl_.planning_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning_internal::PlanningData& Debug::_internal_planning_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::PlanningData* p = _impl_.planning_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::PlanningData&>(::control::planning_internal::_PlanningData_default_instance_);
}
inline const ::control::planning_internal::PlanningData& Debug::planning_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.Debug.planning_data)
  return _internal_planning_data();
}
inline void Debug::unsafe_arena_set_allocated_planning_data(::control::planning_internal::PlanningData* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.planning_data_);
  }
  _impl_.planning_data_ = reinterpret_cast<::control::planning_internal::PlanningData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.Debug.planning_data)
}
inline ::control::planning_internal::PlanningData* Debug::release_planning_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning_internal::PlanningData* released = _impl_.planning_data_;
  _impl_.planning_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::PlanningData* Debug::unsafe_arena_release_planning_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.Debug.planning_data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning_internal::PlanningData* temp = _impl_.planning_data_;
  _impl_.planning_data_ = nullptr;
  return temp;
}
inline ::control::planning_internal::PlanningData* Debug::_internal_mutable_planning_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.planning_data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::PlanningData>(GetArena());
    _impl_.planning_data_ = reinterpret_cast<::control::planning_internal::PlanningData*>(p);
  }
  return _impl_.planning_data_;
}
inline ::control::planning_internal::PlanningData* Debug::mutable_planning_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::planning_internal::PlanningData* _msg = _internal_mutable_planning_data();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.Debug.planning_data)
  return _msg;
}
inline void Debug::set_allocated_planning_data(::control::planning_internal::PlanningData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.planning_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.planning_data_ = reinterpret_cast<::control::planning_internal::PlanningData*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.Debug.planning_data)
}

// -------------------------------------------------------------------

// SpeedPlan

// optional string name = 1;
inline bool SpeedPlan::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SpeedPlan::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SpeedPlan::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.SpeedPlan.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpeedPlan::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.SpeedPlan.name)
}
inline std::string* SpeedPlan::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.SpeedPlan.name)
  return _s;
}
inline const std::string& SpeedPlan::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void SpeedPlan::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SpeedPlan::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SpeedPlan::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.SpeedPlan.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SpeedPlan::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.SpeedPlan.name)
}

// repeated .control.common.SpeedPoint speed_point = 2;
inline int SpeedPlan::_internal_speed_point_size() const {
  return _internal_speed_point().size();
}
inline int SpeedPlan::speed_point_size() const {
  return _internal_speed_point_size();
}
inline ::control::common::SpeedPoint* SpeedPlan::mutable_speed_point(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.SpeedPlan.speed_point)
  return _internal_mutable_speed_point()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* SpeedPlan::mutable_speed_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SpeedPlan.speed_point)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_speed_point();
}
inline const ::control::common::SpeedPoint& SpeedPlan::speed_point(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.SpeedPlan.speed_point)
  return _internal_speed_point().Get(index);
}
inline ::control::common::SpeedPoint* SpeedPlan::add_speed_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SpeedPoint* _add = _internal_mutable_speed_point()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.SpeedPlan.speed_point)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& SpeedPlan::speed_point() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SpeedPlan.speed_point)
  return _internal_speed_point();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>&
SpeedPlan::_internal_speed_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_point_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>*
SpeedPlan::_internal_mutable_speed_point() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.speed_point_;
}

// -------------------------------------------------------------------

// StGraphBoundaryDebug

// optional string name = 1;
inline bool StGraphBoundaryDebug::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StGraphBoundaryDebug::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StGraphBoundaryDebug::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.StGraphBoundaryDebug.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StGraphBoundaryDebug::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.StGraphBoundaryDebug.name)
}
inline std::string* StGraphBoundaryDebug::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.StGraphBoundaryDebug.name)
  return _s;
}
inline const std::string& StGraphBoundaryDebug::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void StGraphBoundaryDebug::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* StGraphBoundaryDebug::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* StGraphBoundaryDebug::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.StGraphBoundaryDebug.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StGraphBoundaryDebug::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.StGraphBoundaryDebug.name)
}

// repeated .control.common.SpeedPoint point = 2;
inline int StGraphBoundaryDebug::_internal_point_size() const {
  return _internal_point().size();
}
inline int StGraphBoundaryDebug::point_size() const {
  return _internal_point_size();
}
inline ::control::common::SpeedPoint* StGraphBoundaryDebug::mutable_point(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.StGraphBoundaryDebug.point)
  return _internal_mutable_point()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* StGraphBoundaryDebug::mutable_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.StGraphBoundaryDebug.point)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_point();
}
inline const ::control::common::SpeedPoint& StGraphBoundaryDebug::point(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.StGraphBoundaryDebug.point)
  return _internal_point().Get(index);
}
inline ::control::common::SpeedPoint* StGraphBoundaryDebug::add_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SpeedPoint* _add = _internal_mutable_point()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.StGraphBoundaryDebug.point)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& StGraphBoundaryDebug::point() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.StGraphBoundaryDebug.point)
  return _internal_point();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>&
StGraphBoundaryDebug::_internal_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.point_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>*
StGraphBoundaryDebug::_internal_mutable_point() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.point_;
}

// optional .control.planning_internal.StGraphBoundaryDebug.StBoundaryType type = 3;
inline bool StGraphBoundaryDebug::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StGraphBoundaryDebug::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::control::planning_internal::StGraphBoundaryDebug_StBoundaryType StGraphBoundaryDebug::type() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.StGraphBoundaryDebug.type)
  return _internal_type();
}
inline void StGraphBoundaryDebug::set_type(::control::planning_internal::StGraphBoundaryDebug_StBoundaryType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning_internal.StGraphBoundaryDebug.type)
}
inline ::control::planning_internal::StGraphBoundaryDebug_StBoundaryType StGraphBoundaryDebug::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning_internal::StGraphBoundaryDebug_StBoundaryType>(_impl_.type_);
}
inline void StGraphBoundaryDebug::_internal_set_type(::control::planning_internal::StGraphBoundaryDebug_StBoundaryType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning_internal::StGraphBoundaryDebug_StBoundaryType_IsValid(value));
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// SLFrameDebug

// optional string name = 1;
inline bool SLFrameDebug::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SLFrameDebug::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SLFrameDebug::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SLFrameDebug::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.name)
}
inline std::string* SLFrameDebug::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.SLFrameDebug.name)
  return _s;
}
inline const std::string& SLFrameDebug::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void SLFrameDebug::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SLFrameDebug::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SLFrameDebug::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.SLFrameDebug.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SLFrameDebug::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.SLFrameDebug.name)
}

// repeated double sampled_s = 2;
inline int SLFrameDebug::_internal_sampled_s_size() const {
  return _internal_sampled_s().size();
}
inline int SLFrameDebug::sampled_s_size() const {
  return _internal_sampled_s_size();
}
inline void SLFrameDebug::clear_sampled_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampled_s_.Clear();
}
inline double SLFrameDebug::sampled_s(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.sampled_s)
  return _internal_sampled_s().Get(index);
}
inline void SLFrameDebug::set_sampled_s(int index, double value) {
  _internal_mutable_sampled_s()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.sampled_s)
}
inline void SLFrameDebug::add_sampled_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_sampled_s()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.sampled_s)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::sampled_s() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.sampled_s)
  return _internal_sampled_s();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_sampled_s()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.sampled_s)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sampled_s();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_sampled_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sampled_s_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_sampled_s() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sampled_s_;
}

// repeated double static_obstacle_lower_bound = 3;
inline int SLFrameDebug::_internal_static_obstacle_lower_bound_size() const {
  return _internal_static_obstacle_lower_bound().size();
}
inline int SLFrameDebug::static_obstacle_lower_bound_size() const {
  return _internal_static_obstacle_lower_bound_size();
}
inline void SLFrameDebug::clear_static_obstacle_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.static_obstacle_lower_bound_.Clear();
}
inline double SLFrameDebug::static_obstacle_lower_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.static_obstacle_lower_bound)
  return _internal_static_obstacle_lower_bound().Get(index);
}
inline void SLFrameDebug::set_static_obstacle_lower_bound(int index, double value) {
  _internal_mutable_static_obstacle_lower_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.static_obstacle_lower_bound)
}
inline void SLFrameDebug::add_static_obstacle_lower_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_static_obstacle_lower_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.static_obstacle_lower_bound)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::static_obstacle_lower_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.static_obstacle_lower_bound)
  return _internal_static_obstacle_lower_bound();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_static_obstacle_lower_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.static_obstacle_lower_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_static_obstacle_lower_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_static_obstacle_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.static_obstacle_lower_bound_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_static_obstacle_lower_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.static_obstacle_lower_bound_;
}

// repeated double dynamic_obstacle_lower_bound = 4;
inline int SLFrameDebug::_internal_dynamic_obstacle_lower_bound_size() const {
  return _internal_dynamic_obstacle_lower_bound().size();
}
inline int SLFrameDebug::dynamic_obstacle_lower_bound_size() const {
  return _internal_dynamic_obstacle_lower_bound_size();
}
inline void SLFrameDebug::clear_dynamic_obstacle_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_obstacle_lower_bound_.Clear();
}
inline double SLFrameDebug::dynamic_obstacle_lower_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.dynamic_obstacle_lower_bound)
  return _internal_dynamic_obstacle_lower_bound().Get(index);
}
inline void SLFrameDebug::set_dynamic_obstacle_lower_bound(int index, double value) {
  _internal_mutable_dynamic_obstacle_lower_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.dynamic_obstacle_lower_bound)
}
inline void SLFrameDebug::add_dynamic_obstacle_lower_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_dynamic_obstacle_lower_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.dynamic_obstacle_lower_bound)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::dynamic_obstacle_lower_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.dynamic_obstacle_lower_bound)
  return _internal_dynamic_obstacle_lower_bound();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_dynamic_obstacle_lower_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.dynamic_obstacle_lower_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dynamic_obstacle_lower_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_dynamic_obstacle_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dynamic_obstacle_lower_bound_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_dynamic_obstacle_lower_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dynamic_obstacle_lower_bound_;
}

// repeated double static_obstacle_upper_bound = 5;
inline int SLFrameDebug::_internal_static_obstacle_upper_bound_size() const {
  return _internal_static_obstacle_upper_bound().size();
}
inline int SLFrameDebug::static_obstacle_upper_bound_size() const {
  return _internal_static_obstacle_upper_bound_size();
}
inline void SLFrameDebug::clear_static_obstacle_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.static_obstacle_upper_bound_.Clear();
}
inline double SLFrameDebug::static_obstacle_upper_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.static_obstacle_upper_bound)
  return _internal_static_obstacle_upper_bound().Get(index);
}
inline void SLFrameDebug::set_static_obstacle_upper_bound(int index, double value) {
  _internal_mutable_static_obstacle_upper_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.static_obstacle_upper_bound)
}
inline void SLFrameDebug::add_static_obstacle_upper_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_static_obstacle_upper_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.static_obstacle_upper_bound)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::static_obstacle_upper_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.static_obstacle_upper_bound)
  return _internal_static_obstacle_upper_bound();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_static_obstacle_upper_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.static_obstacle_upper_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_static_obstacle_upper_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_static_obstacle_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.static_obstacle_upper_bound_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_static_obstacle_upper_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.static_obstacle_upper_bound_;
}

// repeated double dynamic_obstacle_upper_bound = 6;
inline int SLFrameDebug::_internal_dynamic_obstacle_upper_bound_size() const {
  return _internal_dynamic_obstacle_upper_bound().size();
}
inline int SLFrameDebug::dynamic_obstacle_upper_bound_size() const {
  return _internal_dynamic_obstacle_upper_bound_size();
}
inline void SLFrameDebug::clear_dynamic_obstacle_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_obstacle_upper_bound_.Clear();
}
inline double SLFrameDebug::dynamic_obstacle_upper_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.dynamic_obstacle_upper_bound)
  return _internal_dynamic_obstacle_upper_bound().Get(index);
}
inline void SLFrameDebug::set_dynamic_obstacle_upper_bound(int index, double value) {
  _internal_mutable_dynamic_obstacle_upper_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.dynamic_obstacle_upper_bound)
}
inline void SLFrameDebug::add_dynamic_obstacle_upper_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_dynamic_obstacle_upper_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.dynamic_obstacle_upper_bound)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::dynamic_obstacle_upper_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.dynamic_obstacle_upper_bound)
  return _internal_dynamic_obstacle_upper_bound();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_dynamic_obstacle_upper_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.dynamic_obstacle_upper_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dynamic_obstacle_upper_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_dynamic_obstacle_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dynamic_obstacle_upper_bound_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_dynamic_obstacle_upper_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dynamic_obstacle_upper_bound_;
}

// repeated double map_lower_bound = 7;
inline int SLFrameDebug::_internal_map_lower_bound_size() const {
  return _internal_map_lower_bound().size();
}
inline int SLFrameDebug::map_lower_bound_size() const {
  return _internal_map_lower_bound_size();
}
inline void SLFrameDebug::clear_map_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_lower_bound_.Clear();
}
inline double SLFrameDebug::map_lower_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.map_lower_bound)
  return _internal_map_lower_bound().Get(index);
}
inline void SLFrameDebug::set_map_lower_bound(int index, double value) {
  _internal_mutable_map_lower_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.map_lower_bound)
}
inline void SLFrameDebug::add_map_lower_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_map_lower_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.map_lower_bound)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::map_lower_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.map_lower_bound)
  return _internal_map_lower_bound();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_map_lower_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.map_lower_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_map_lower_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_map_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_lower_bound_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_map_lower_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.map_lower_bound_;
}

// repeated double map_upper_bound = 8;
inline int SLFrameDebug::_internal_map_upper_bound_size() const {
  return _internal_map_upper_bound().size();
}
inline int SLFrameDebug::map_upper_bound_size() const {
  return _internal_map_upper_bound_size();
}
inline void SLFrameDebug::clear_map_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_upper_bound_.Clear();
}
inline double SLFrameDebug::map_upper_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.map_upper_bound)
  return _internal_map_upper_bound().Get(index);
}
inline void SLFrameDebug::set_map_upper_bound(int index, double value) {
  _internal_mutable_map_upper_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.map_upper_bound)
}
inline void SLFrameDebug::add_map_upper_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_map_upper_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.map_upper_bound)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::map_upper_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.map_upper_bound)
  return _internal_map_upper_bound();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_map_upper_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.map_upper_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_map_upper_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_map_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_upper_bound_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_map_upper_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.map_upper_bound_;
}

// repeated .control.common.SLPoint sl_path = 9;
inline int SLFrameDebug::_internal_sl_path_size() const {
  return _internal_sl_path().size();
}
inline int SLFrameDebug::sl_path_size() const {
  return _internal_sl_path_size();
}
inline ::control::common::SLPoint* SLFrameDebug::mutable_sl_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.SLFrameDebug.sl_path)
  return _internal_mutable_sl_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* SLFrameDebug::mutable_sl_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.sl_path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sl_path();
}
inline const ::control::common::SLPoint& SLFrameDebug::sl_path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.sl_path)
  return _internal_sl_path().Get(index);
}
inline ::control::common::SLPoint* SLFrameDebug::add_sl_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SLPoint* _add = _internal_mutable_sl_path()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.sl_path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& SLFrameDebug::sl_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.sl_path)
  return _internal_sl_path();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>&
SLFrameDebug::_internal_sl_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sl_path_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>*
SLFrameDebug::_internal_mutable_sl_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sl_path_;
}

// repeated double aggregated_boundary_s = 10;
inline int SLFrameDebug::_internal_aggregated_boundary_s_size() const {
  return _internal_aggregated_boundary_s().size();
}
inline int SLFrameDebug::aggregated_boundary_s_size() const {
  return _internal_aggregated_boundary_s_size();
}
inline void SLFrameDebug::clear_aggregated_boundary_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregated_boundary_s_.Clear();
}
inline double SLFrameDebug::aggregated_boundary_s(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.aggregated_boundary_s)
  return _internal_aggregated_boundary_s().Get(index);
}
inline void SLFrameDebug::set_aggregated_boundary_s(int index, double value) {
  _internal_mutable_aggregated_boundary_s()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.aggregated_boundary_s)
}
inline void SLFrameDebug::add_aggregated_boundary_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggregated_boundary_s()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.aggregated_boundary_s)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::aggregated_boundary_s() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.aggregated_boundary_s)
  return _internal_aggregated_boundary_s();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_aggregated_boundary_s()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.aggregated_boundary_s)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_aggregated_boundary_s();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_aggregated_boundary_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregated_boundary_s_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_aggregated_boundary_s() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.aggregated_boundary_s_;
}

// repeated double aggregated_boundary_low = 11;
inline int SLFrameDebug::_internal_aggregated_boundary_low_size() const {
  return _internal_aggregated_boundary_low().size();
}
inline int SLFrameDebug::aggregated_boundary_low_size() const {
  return _internal_aggregated_boundary_low_size();
}
inline void SLFrameDebug::clear_aggregated_boundary_low() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregated_boundary_low_.Clear();
}
inline double SLFrameDebug::aggregated_boundary_low(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.aggregated_boundary_low)
  return _internal_aggregated_boundary_low().Get(index);
}
inline void SLFrameDebug::set_aggregated_boundary_low(int index, double value) {
  _internal_mutable_aggregated_boundary_low()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.aggregated_boundary_low)
}
inline void SLFrameDebug::add_aggregated_boundary_low(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggregated_boundary_low()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.aggregated_boundary_low)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::aggregated_boundary_low() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.aggregated_boundary_low)
  return _internal_aggregated_boundary_low();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_aggregated_boundary_low()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.aggregated_boundary_low)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_aggregated_boundary_low();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_aggregated_boundary_low() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregated_boundary_low_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_aggregated_boundary_low() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.aggregated_boundary_low_;
}

// repeated double aggregated_boundary_high = 12;
inline int SLFrameDebug::_internal_aggregated_boundary_high_size() const {
  return _internal_aggregated_boundary_high().size();
}
inline int SLFrameDebug::aggregated_boundary_high_size() const {
  return _internal_aggregated_boundary_high_size();
}
inline void SLFrameDebug::clear_aggregated_boundary_high() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregated_boundary_high_.Clear();
}
inline double SLFrameDebug::aggregated_boundary_high(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SLFrameDebug.aggregated_boundary_high)
  return _internal_aggregated_boundary_high().Get(index);
}
inline void SLFrameDebug::set_aggregated_boundary_high(int index, double value) {
  _internal_mutable_aggregated_boundary_high()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.SLFrameDebug.aggregated_boundary_high)
}
inline void SLFrameDebug::add_aggregated_boundary_high(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggregated_boundary_high()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.SLFrameDebug.aggregated_boundary_high)
}
inline const ::google::protobuf::RepeatedField<double>& SLFrameDebug::aggregated_boundary_high() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SLFrameDebug.aggregated_boundary_high)
  return _internal_aggregated_boundary_high();
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::mutable_aggregated_boundary_high()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SLFrameDebug.aggregated_boundary_high)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_aggregated_boundary_high();
}
inline const ::google::protobuf::RepeatedField<double>&
SLFrameDebug::_internal_aggregated_boundary_high() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregated_boundary_high_;
}
inline ::google::protobuf::RepeatedField<double>* SLFrameDebug::_internal_mutable_aggregated_boundary_high() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.aggregated_boundary_high_;
}

// -------------------------------------------------------------------

// STGraphDebug_STGraphSpeedConstraint

// repeated double t = 1;
inline int STGraphDebug_STGraphSpeedConstraint::_internal_t_size() const {
  return _internal_t().size();
}
inline int STGraphDebug_STGraphSpeedConstraint::t_size() const {
  return _internal_t_size();
}
inline void STGraphDebug_STGraphSpeedConstraint::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_.Clear();
}
inline double STGraphDebug_STGraphSpeedConstraint::t(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.t)
  return _internal_t().Get(index);
}
inline void STGraphDebug_STGraphSpeedConstraint::set_t(int index, double value) {
  _internal_mutable_t()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.t)
}
inline void STGraphDebug_STGraphSpeedConstraint::add_t(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_t()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.t)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphSpeedConstraint::t() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.t)
  return _internal_t();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphSpeedConstraint::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.t)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_t();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphSpeedConstraint::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphSpeedConstraint::_internal_mutable_t() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.t_;
}

// repeated double lower_bound = 2;
inline int STGraphDebug_STGraphSpeedConstraint::_internal_lower_bound_size() const {
  return _internal_lower_bound().size();
}
inline int STGraphDebug_STGraphSpeedConstraint::lower_bound_size() const {
  return _internal_lower_bound_size();
}
inline void STGraphDebug_STGraphSpeedConstraint::clear_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lower_bound_.Clear();
}
inline double STGraphDebug_STGraphSpeedConstraint::lower_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.lower_bound)
  return _internal_lower_bound().Get(index);
}
inline void STGraphDebug_STGraphSpeedConstraint::set_lower_bound(int index, double value) {
  _internal_mutable_lower_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.lower_bound)
}
inline void STGraphDebug_STGraphSpeedConstraint::add_lower_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_lower_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.lower_bound)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphSpeedConstraint::lower_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.lower_bound)
  return _internal_lower_bound();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphSpeedConstraint::mutable_lower_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.lower_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lower_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphSpeedConstraint::_internal_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lower_bound_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphSpeedConstraint::_internal_mutable_lower_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lower_bound_;
}

// repeated double upper_bound = 3;
inline int STGraphDebug_STGraphSpeedConstraint::_internal_upper_bound_size() const {
  return _internal_upper_bound().size();
}
inline int STGraphDebug_STGraphSpeedConstraint::upper_bound_size() const {
  return _internal_upper_bound_size();
}
inline void STGraphDebug_STGraphSpeedConstraint::clear_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.upper_bound_.Clear();
}
inline double STGraphDebug_STGraphSpeedConstraint::upper_bound(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.upper_bound)
  return _internal_upper_bound().Get(index);
}
inline void STGraphDebug_STGraphSpeedConstraint::set_upper_bound(int index, double value) {
  _internal_mutable_upper_bound()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.upper_bound)
}
inline void STGraphDebug_STGraphSpeedConstraint::add_upper_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_upper_bound()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.upper_bound)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphSpeedConstraint::upper_bound() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.upper_bound)
  return _internal_upper_bound();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphSpeedConstraint::mutable_upper_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphSpeedConstraint.upper_bound)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_upper_bound();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphSpeedConstraint::_internal_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.upper_bound_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphSpeedConstraint::_internal_mutable_upper_bound() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.upper_bound_;
}

// -------------------------------------------------------------------

// STGraphDebug_STGraphKernelCuiseRef

// repeated double t = 1;
inline int STGraphDebug_STGraphKernelCuiseRef::_internal_t_size() const {
  return _internal_t().size();
}
inline int STGraphDebug_STGraphKernelCuiseRef::t_size() const {
  return _internal_t_size();
}
inline void STGraphDebug_STGraphKernelCuiseRef::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_.Clear();
}
inline double STGraphDebug_STGraphKernelCuiseRef::t(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.t)
  return _internal_t().Get(index);
}
inline void STGraphDebug_STGraphKernelCuiseRef::set_t(int index, double value) {
  _internal_mutable_t()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.t)
}
inline void STGraphDebug_STGraphKernelCuiseRef::add_t(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_t()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.t)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphKernelCuiseRef::t() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.t)
  return _internal_t();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelCuiseRef::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.t)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_t();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphKernelCuiseRef::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelCuiseRef::_internal_mutable_t() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.t_;
}

// repeated double cruise_line_s = 2;
inline int STGraphDebug_STGraphKernelCuiseRef::_internal_cruise_line_s_size() const {
  return _internal_cruise_line_s().size();
}
inline int STGraphDebug_STGraphKernelCuiseRef::cruise_line_s_size() const {
  return _internal_cruise_line_s_size();
}
inline void STGraphDebug_STGraphKernelCuiseRef::clear_cruise_line_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cruise_line_s_.Clear();
}
inline double STGraphDebug_STGraphKernelCuiseRef::cruise_line_s(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.cruise_line_s)
  return _internal_cruise_line_s().Get(index);
}
inline void STGraphDebug_STGraphKernelCuiseRef::set_cruise_line_s(int index, double value) {
  _internal_mutable_cruise_line_s()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.cruise_line_s)
}
inline void STGraphDebug_STGraphKernelCuiseRef::add_cruise_line_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_cruise_line_s()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.cruise_line_s)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphKernelCuiseRef::cruise_line_s() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.cruise_line_s)
  return _internal_cruise_line_s();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelCuiseRef::mutable_cruise_line_s()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphKernelCuiseRef.cruise_line_s)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cruise_line_s();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphKernelCuiseRef::_internal_cruise_line_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cruise_line_s_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelCuiseRef::_internal_mutable_cruise_line_s() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cruise_line_s_;
}

// -------------------------------------------------------------------

// STGraphDebug_STGraphKernelFollowRef

// repeated double t = 1;
inline int STGraphDebug_STGraphKernelFollowRef::_internal_t_size() const {
  return _internal_t().size();
}
inline int STGraphDebug_STGraphKernelFollowRef::t_size() const {
  return _internal_t_size();
}
inline void STGraphDebug_STGraphKernelFollowRef::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_.Clear();
}
inline double STGraphDebug_STGraphKernelFollowRef::t(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.t)
  return _internal_t().Get(index);
}
inline void STGraphDebug_STGraphKernelFollowRef::set_t(int index, double value) {
  _internal_mutable_t()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.t)
}
inline void STGraphDebug_STGraphKernelFollowRef::add_t(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_t()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.t)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphKernelFollowRef::t() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.t)
  return _internal_t();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelFollowRef::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.t)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_t();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphKernelFollowRef::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelFollowRef::_internal_mutable_t() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.t_;
}

// repeated double follow_line_s = 2;
inline int STGraphDebug_STGraphKernelFollowRef::_internal_follow_line_s_size() const {
  return _internal_follow_line_s().size();
}
inline int STGraphDebug_STGraphKernelFollowRef::follow_line_s_size() const {
  return _internal_follow_line_s_size();
}
inline void STGraphDebug_STGraphKernelFollowRef::clear_follow_line_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.follow_line_s_.Clear();
}
inline double STGraphDebug_STGraphKernelFollowRef::follow_line_s(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.follow_line_s)
  return _internal_follow_line_s().Get(index);
}
inline void STGraphDebug_STGraphKernelFollowRef::set_follow_line_s(int index, double value) {
  _internal_mutable_follow_line_s()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.follow_line_s)
}
inline void STGraphDebug_STGraphKernelFollowRef::add_follow_line_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_follow_line_s()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.follow_line_s)
}
inline const ::google::protobuf::RepeatedField<double>& STGraphDebug_STGraphKernelFollowRef::follow_line_s() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.follow_line_s)
  return _internal_follow_line_s();
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelFollowRef::mutable_follow_line_s()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.STGraphKernelFollowRef.follow_line_s)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_follow_line_s();
}
inline const ::google::protobuf::RepeatedField<double>&
STGraphDebug_STGraphKernelFollowRef::_internal_follow_line_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.follow_line_s_;
}
inline ::google::protobuf::RepeatedField<double>* STGraphDebug_STGraphKernelFollowRef::_internal_mutable_follow_line_s() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.follow_line_s_;
}

// -------------------------------------------------------------------

// STGraphDebug

// optional string name = 1;
inline bool STGraphDebug::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void STGraphDebug::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& STGraphDebug::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void STGraphDebug::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.STGraphDebug.name)
}
inline std::string* STGraphDebug::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.name)
  return _s;
}
inline const std::string& STGraphDebug::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void STGraphDebug::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* STGraphDebug::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* STGraphDebug::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.STGraphDebug.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void STGraphDebug::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.STGraphDebug.name)
}

// repeated .control.planning_internal.StGraphBoundaryDebug boundary = 2;
inline int STGraphDebug::_internal_boundary_size() const {
  return _internal_boundary().size();
}
inline int STGraphDebug::boundary_size() const {
  return _internal_boundary_size();
}
inline void STGraphDebug::clear_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.boundary_.Clear();
}
inline ::control::planning_internal::StGraphBoundaryDebug* STGraphDebug::mutable_boundary(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.boundary)
  return _internal_mutable_boundary()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>* STGraphDebug::mutable_boundary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.boundary)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_boundary();
}
inline const ::control::planning_internal::StGraphBoundaryDebug& STGraphDebug::boundary(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.boundary)
  return _internal_boundary().Get(index);
}
inline ::control::planning_internal::StGraphBoundaryDebug* STGraphDebug::add_boundary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::StGraphBoundaryDebug* _add = _internal_mutable_boundary()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.boundary)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>& STGraphDebug::boundary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.boundary)
  return _internal_boundary();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>&
STGraphDebug::_internal_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.boundary_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::StGraphBoundaryDebug>*
STGraphDebug::_internal_mutable_boundary() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.boundary_;
}

// repeated .control.common.SpeedPoint speed_limit = 3;
inline int STGraphDebug::_internal_speed_limit_size() const {
  return _internal_speed_limit().size();
}
inline int STGraphDebug::speed_limit_size() const {
  return _internal_speed_limit_size();
}
inline ::control::common::SpeedPoint* STGraphDebug::mutable_speed_limit(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.speed_limit)
  return _internal_mutable_speed_limit()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* STGraphDebug::mutable_speed_limit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.speed_limit)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_speed_limit();
}
inline const ::control::common::SpeedPoint& STGraphDebug::speed_limit(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.speed_limit)
  return _internal_speed_limit().Get(index);
}
inline ::control::common::SpeedPoint* STGraphDebug::add_speed_limit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SpeedPoint* _add = _internal_mutable_speed_limit()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.speed_limit)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& STGraphDebug::speed_limit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.speed_limit)
  return _internal_speed_limit();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>&
STGraphDebug::_internal_speed_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_limit_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>*
STGraphDebug::_internal_mutable_speed_limit() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.speed_limit_;
}

// repeated .control.common.SpeedPoint speed_profile = 4;
inline int STGraphDebug::_internal_speed_profile_size() const {
  return _internal_speed_profile().size();
}
inline int STGraphDebug::speed_profile_size() const {
  return _internal_speed_profile_size();
}
inline ::control::common::SpeedPoint* STGraphDebug::mutable_speed_profile(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.speed_profile)
  return _internal_mutable_speed_profile()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>* STGraphDebug::mutable_speed_profile()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.STGraphDebug.speed_profile)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_speed_profile();
}
inline const ::control::common::SpeedPoint& STGraphDebug::speed_profile(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.speed_profile)
  return _internal_speed_profile().Get(index);
}
inline ::control::common::SpeedPoint* STGraphDebug::add_speed_profile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SpeedPoint* _add = _internal_mutable_speed_profile()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.STGraphDebug.speed_profile)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>& STGraphDebug::speed_profile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.STGraphDebug.speed_profile)
  return _internal_speed_profile();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>&
STGraphDebug::_internal_speed_profile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_profile_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SpeedPoint>*
STGraphDebug::_internal_mutable_speed_profile() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.speed_profile_;
}

// optional .control.planning_internal.STGraphDebug.STGraphSpeedConstraint speed_constraint = 5;
inline bool STGraphDebug::has_speed_constraint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_constraint_ != nullptr);
  return value;
}
inline void STGraphDebug::clear_speed_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_constraint_ != nullptr) _impl_.speed_constraint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint& STGraphDebug::_internal_speed_constraint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* p = _impl_.speed_constraint_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint&>(::control::planning_internal::_STGraphDebug_STGraphSpeedConstraint_default_instance_);
}
inline const ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint& STGraphDebug::speed_constraint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.speed_constraint)
  return _internal_speed_constraint();
}
inline void STGraphDebug::unsafe_arena_set_allocated_speed_constraint(::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_constraint_);
  }
  _impl_.speed_constraint_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphSpeedConstraint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.STGraphDebug.speed_constraint)
}
inline ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* STGraphDebug::release_speed_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* released = _impl_.speed_constraint_;
  _impl_.speed_constraint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* STGraphDebug::unsafe_arena_release_speed_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.STGraphDebug.speed_constraint)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* temp = _impl_.speed_constraint_;
  _impl_.speed_constraint_ = nullptr;
  return temp;
}
inline ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* STGraphDebug::_internal_mutable_speed_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_constraint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::STGraphDebug_STGraphSpeedConstraint>(GetArena());
    _impl_.speed_constraint_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphSpeedConstraint*>(p);
  }
  return _impl_.speed_constraint_;
}
inline ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* STGraphDebug::mutable_speed_constraint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* _msg = _internal_mutable_speed_constraint();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.speed_constraint)
  return _msg;
}
inline void STGraphDebug::set_allocated_speed_constraint(::control::planning_internal::STGraphDebug_STGraphSpeedConstraint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.speed_constraint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_constraint_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphSpeedConstraint*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.STGraphDebug.speed_constraint)
}

// optional .control.planning_internal.STGraphDebug.STGraphKernelCuiseRef kernel_cruise_ref = 6;
inline bool STGraphDebug::has_kernel_cruise_ref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kernel_cruise_ref_ != nullptr);
  return value;
}
inline void STGraphDebug::clear_kernel_cruise_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_cruise_ref_ != nullptr) _impl_.kernel_cruise_ref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef& STGraphDebug::_internal_kernel_cruise_ref() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* p = _impl_.kernel_cruise_ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef&>(::control::planning_internal::_STGraphDebug_STGraphKernelCuiseRef_default_instance_);
}
inline const ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef& STGraphDebug::kernel_cruise_ref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.kernel_cruise_ref)
  return _internal_kernel_cruise_ref();
}
inline void STGraphDebug::unsafe_arena_set_allocated_kernel_cruise_ref(::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kernel_cruise_ref_);
  }
  _impl_.kernel_cruise_ref_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.STGraphDebug.kernel_cruise_ref)
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* STGraphDebug::release_kernel_cruise_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* released = _impl_.kernel_cruise_ref_;
  _impl_.kernel_cruise_ref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* STGraphDebug::unsafe_arena_release_kernel_cruise_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.STGraphDebug.kernel_cruise_ref)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* temp = _impl_.kernel_cruise_ref_;
  _impl_.kernel_cruise_ref_ = nullptr;
  return temp;
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* STGraphDebug::_internal_mutable_kernel_cruise_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_cruise_ref_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef>(GetArena());
    _impl_.kernel_cruise_ref_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef*>(p);
  }
  return _impl_.kernel_cruise_ref_;
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* STGraphDebug::mutable_kernel_cruise_ref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* _msg = _internal_mutable_kernel_cruise_ref();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.kernel_cruise_ref)
  return _msg;
}
inline void STGraphDebug::set_allocated_kernel_cruise_ref(::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kernel_cruise_ref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.kernel_cruise_ref_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphKernelCuiseRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.STGraphDebug.kernel_cruise_ref)
}

// optional .control.planning_internal.STGraphDebug.STGraphKernelFollowRef kernel_follow_ref = 7;
inline bool STGraphDebug::has_kernel_follow_ref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kernel_follow_ref_ != nullptr);
  return value;
}
inline void STGraphDebug::clear_kernel_follow_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_follow_ref_ != nullptr) _impl_.kernel_follow_ref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef& STGraphDebug::_internal_kernel_follow_ref() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* p = _impl_.kernel_follow_ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef&>(::control::planning_internal::_STGraphDebug_STGraphKernelFollowRef_default_instance_);
}
inline const ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef& STGraphDebug::kernel_follow_ref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.STGraphDebug.kernel_follow_ref)
  return _internal_kernel_follow_ref();
}
inline void STGraphDebug::unsafe_arena_set_allocated_kernel_follow_ref(::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kernel_follow_ref_);
  }
  _impl_.kernel_follow_ref_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphKernelFollowRef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.STGraphDebug.kernel_follow_ref)
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* STGraphDebug::release_kernel_follow_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* released = _impl_.kernel_follow_ref_;
  _impl_.kernel_follow_ref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* STGraphDebug::unsafe_arena_release_kernel_follow_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.STGraphDebug.kernel_follow_ref)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* temp = _impl_.kernel_follow_ref_;
  _impl_.kernel_follow_ref_ = nullptr;
  return temp;
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* STGraphDebug::_internal_mutable_kernel_follow_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_follow_ref_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::STGraphDebug_STGraphKernelFollowRef>(GetArena());
    _impl_.kernel_follow_ref_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphKernelFollowRef*>(p);
  }
  return _impl_.kernel_follow_ref_;
}
inline ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* STGraphDebug::mutable_kernel_follow_ref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* _msg = _internal_mutable_kernel_follow_ref();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.STGraphDebug.kernel_follow_ref)
  return _msg;
}
inline void STGraphDebug::set_allocated_kernel_follow_ref(::control::planning_internal::STGraphDebug_STGraphKernelFollowRef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kernel_follow_ref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.kernel_follow_ref_ = reinterpret_cast<::control::planning_internal::STGraphDebug_STGraphKernelFollowRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.STGraphDebug.kernel_follow_ref)
}

// -------------------------------------------------------------------

// DecisionTag

// optional string decider_tag = 1;
inline bool DecisionTag::has_decider_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DecisionTag::clear_decider_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.decider_tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DecisionTag::decider_tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.DecisionTag.decider_tag)
  return _internal_decider_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DecisionTag::set_decider_tag(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.decider_tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.DecisionTag.decider_tag)
}
inline std::string* DecisionTag::mutable_decider_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_decider_tag();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.DecisionTag.decider_tag)
  return _s;
}
inline const std::string& DecisionTag::_internal_decider_tag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.decider_tag_.Get();
}
inline void DecisionTag::_internal_set_decider_tag(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.decider_tag_.Set(value, GetArena());
}
inline std::string* DecisionTag::_internal_mutable_decider_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.decider_tag_.Mutable( GetArena());
}
inline std::string* DecisionTag::release_decider_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.DecisionTag.decider_tag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.decider_tag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.decider_tag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DecisionTag::set_allocated_decider_tag(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.decider_tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.decider_tag_.IsDefault()) {
          _impl_.decider_tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.DecisionTag.decider_tag)
}

// optional .control.planning.ObjectDecisionType decision = 2;
inline bool DecisionTag::has_decision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.decision_ != nullptr);
  return value;
}
inline const ::control::planning::ObjectDecisionType& DecisionTag::_internal_decision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning::ObjectDecisionType* p = _impl_.decision_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning::ObjectDecisionType&>(::control::planning::_ObjectDecisionType_default_instance_);
}
inline const ::control::planning::ObjectDecisionType& DecisionTag::decision() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.DecisionTag.decision)
  return _internal_decision();
}
inline void DecisionTag::unsafe_arena_set_allocated_decision(::control::planning::ObjectDecisionType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.decision_);
  }
  _impl_.decision_ = reinterpret_cast<::control::planning::ObjectDecisionType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.DecisionTag.decision)
}
inline ::control::planning::ObjectDecisionType* DecisionTag::release_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisionType* released = _impl_.decision_;
  _impl_.decision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning::ObjectDecisionType* DecisionTag::unsafe_arena_release_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.DecisionTag.decision)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning::ObjectDecisionType* temp = _impl_.decision_;
  _impl_.decision_ = nullptr;
  return temp;
}
inline ::control::planning::ObjectDecisionType* DecisionTag::_internal_mutable_decision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.decision_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning::ObjectDecisionType>(GetArena());
    _impl_.decision_ = reinterpret_cast<::control::planning::ObjectDecisionType*>(p);
  }
  return _impl_.decision_;
}
inline ::control::planning::ObjectDecisionType* DecisionTag::mutable_decision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::planning::ObjectDecisionType* _msg = _internal_mutable_decision();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.DecisionTag.decision)
  return _msg;
}
inline void DecisionTag::set_allocated_decision(::control::planning::ObjectDecisionType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.decision_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.decision_ = reinterpret_cast<::control::planning::ObjectDecisionType*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.DecisionTag.decision)
}

// -------------------------------------------------------------------

// ObstacleDebug

// optional string id = 1;
inline bool ObstacleDebug::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ObstacleDebug::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObstacleDebug::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.ObstacleDebug.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ObstacleDebug::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.ObstacleDebug.id)
}
inline std::string* ObstacleDebug::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.ObstacleDebug.id)
  return _s;
}
inline const std::string& ObstacleDebug::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ObstacleDebug::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ObstacleDebug::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ObstacleDebug::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.ObstacleDebug.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ObstacleDebug::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.ObstacleDebug.id)
}

// repeated .control.planning_internal.DecisionTag decision_tag = 3;
inline int ObstacleDebug::_internal_decision_tag_size() const {
  return _internal_decision_tag().size();
}
inline int ObstacleDebug::decision_tag_size() const {
  return _internal_decision_tag_size();
}
inline void ObstacleDebug::clear_decision_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.decision_tag_.Clear();
}
inline ::control::planning_internal::DecisionTag* ObstacleDebug::mutable_decision_tag(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.ObstacleDebug.decision_tag)
  return _internal_mutable_decision_tag()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>* ObstacleDebug::mutable_decision_tag()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.ObstacleDebug.decision_tag)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_decision_tag();
}
inline const ::control::planning_internal::DecisionTag& ObstacleDebug::decision_tag(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.ObstacleDebug.decision_tag)
  return _internal_decision_tag().Get(index);
}
inline ::control::planning_internal::DecisionTag* ObstacleDebug::add_decision_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::DecisionTag* _add = _internal_mutable_decision_tag()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.ObstacleDebug.decision_tag)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>& ObstacleDebug::decision_tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.ObstacleDebug.decision_tag)
  return _internal_decision_tag();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>&
ObstacleDebug::_internal_decision_tag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.decision_tag_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::DecisionTag>*
ObstacleDebug::_internal_mutable_decision_tag() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.decision_tag_;
}

// repeated double vertices_x_coords = 4;
inline int ObstacleDebug::_internal_vertices_x_coords_size() const {
  return _internal_vertices_x_coords().size();
}
inline int ObstacleDebug::vertices_x_coords_size() const {
  return _internal_vertices_x_coords_size();
}
inline void ObstacleDebug::clear_vertices_x_coords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertices_x_coords_.Clear();
}
inline double ObstacleDebug::vertices_x_coords(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ObstacleDebug.vertices_x_coords)
  return _internal_vertices_x_coords().Get(index);
}
inline void ObstacleDebug::set_vertices_x_coords(int index, double value) {
  _internal_mutable_vertices_x_coords()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.ObstacleDebug.vertices_x_coords)
}
inline void ObstacleDebug::add_vertices_x_coords(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vertices_x_coords()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.ObstacleDebug.vertices_x_coords)
}
inline const ::google::protobuf::RepeatedField<double>& ObstacleDebug::vertices_x_coords() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.ObstacleDebug.vertices_x_coords)
  return _internal_vertices_x_coords();
}
inline ::google::protobuf::RepeatedField<double>* ObstacleDebug::mutable_vertices_x_coords()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.ObstacleDebug.vertices_x_coords)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vertices_x_coords();
}
inline const ::google::protobuf::RepeatedField<double>&
ObstacleDebug::_internal_vertices_x_coords() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vertices_x_coords_;
}
inline ::google::protobuf::RepeatedField<double>* ObstacleDebug::_internal_mutable_vertices_x_coords() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vertices_x_coords_;
}

// repeated double vertices_y_coords = 5;
inline int ObstacleDebug::_internal_vertices_y_coords_size() const {
  return _internal_vertices_y_coords().size();
}
inline int ObstacleDebug::vertices_y_coords_size() const {
  return _internal_vertices_y_coords_size();
}
inline void ObstacleDebug::clear_vertices_y_coords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertices_y_coords_.Clear();
}
inline double ObstacleDebug::vertices_y_coords(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ObstacleDebug.vertices_y_coords)
  return _internal_vertices_y_coords().Get(index);
}
inline void ObstacleDebug::set_vertices_y_coords(int index, double value) {
  _internal_mutable_vertices_y_coords()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.ObstacleDebug.vertices_y_coords)
}
inline void ObstacleDebug::add_vertices_y_coords(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vertices_y_coords()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.ObstacleDebug.vertices_y_coords)
}
inline const ::google::protobuf::RepeatedField<double>& ObstacleDebug::vertices_y_coords() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.ObstacleDebug.vertices_y_coords)
  return _internal_vertices_y_coords();
}
inline ::google::protobuf::RepeatedField<double>* ObstacleDebug::mutable_vertices_y_coords()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.ObstacleDebug.vertices_y_coords)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vertices_y_coords();
}
inline const ::google::protobuf::RepeatedField<double>&
ObstacleDebug::_internal_vertices_y_coords() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vertices_y_coords_;
}
inline ::google::protobuf::RepeatedField<double>* ObstacleDebug::_internal_mutable_vertices_y_coords() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vertices_y_coords_;
}

// -------------------------------------------------------------------

// ReferenceLineDebug

// optional string id = 1;
inline bool ReferenceLineDebug::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReferenceLineDebug::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReferenceLineDebug::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.id)
}
inline std::string* ReferenceLineDebug::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.ReferenceLineDebug.id)
  return _s;
}
inline const std::string& ReferenceLineDebug::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ReferenceLineDebug::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ReferenceLineDebug::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ReferenceLineDebug::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.ReferenceLineDebug.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ReferenceLineDebug::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.ReferenceLineDebug.id)
}

// optional double length = 2;
inline bool ReferenceLineDebug::has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ReferenceLineDebug::length() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.length)
  return _internal_length();
}
inline void ReferenceLineDebug::set_length(double value) {
  _internal_set_length(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.length)
}
inline double ReferenceLineDebug::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_;
}
inline void ReferenceLineDebug::_internal_set_length(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// optional double cost = 3;
inline bool ReferenceLineDebug::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ReferenceLineDebug::cost() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.cost)
  return _internal_cost();
}
inline void ReferenceLineDebug::set_cost(double value) {
  _internal_set_cost(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.cost)
}
inline double ReferenceLineDebug::_internal_cost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cost_;
}
inline void ReferenceLineDebug::_internal_set_cost(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cost_ = value;
}

// optional bool is_change_lane_path = 4;
inline bool ReferenceLineDebug::has_is_change_lane_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_is_change_lane_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_change_lane_path_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ReferenceLineDebug::is_change_lane_path() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.is_change_lane_path)
  return _internal_is_change_lane_path();
}
inline void ReferenceLineDebug::set_is_change_lane_path(bool value) {
  _internal_set_is_change_lane_path(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.is_change_lane_path)
}
inline bool ReferenceLineDebug::_internal_is_change_lane_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_change_lane_path_;
}
inline void ReferenceLineDebug::_internal_set_is_change_lane_path(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_change_lane_path_ = value;
}

// optional bool is_drivable = 5;
inline bool ReferenceLineDebug::has_is_drivable() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_is_drivable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_drivable_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool ReferenceLineDebug::is_drivable() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.is_drivable)
  return _internal_is_drivable();
}
inline void ReferenceLineDebug::set_is_drivable(bool value) {
  _internal_set_is_drivable(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.is_drivable)
}
inline bool ReferenceLineDebug::_internal_is_drivable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_drivable_;
}
inline void ReferenceLineDebug::_internal_set_is_drivable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_drivable_ = value;
}

// optional bool is_protected = 6;
inline bool ReferenceLineDebug::has_is_protected() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_is_protected() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_protected_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool ReferenceLineDebug::is_protected() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.is_protected)
  return _internal_is_protected();
}
inline void ReferenceLineDebug::set_is_protected(bool value) {
  _internal_set_is_protected(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.is_protected)
}
inline bool ReferenceLineDebug::_internal_is_protected() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_protected_;
}
inline void ReferenceLineDebug::_internal_set_is_protected(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_protected_ = value;
}

// optional bool is_offroad = 7;
inline bool ReferenceLineDebug::has_is_offroad() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_is_offroad() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_offroad_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool ReferenceLineDebug::is_offroad() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.is_offroad)
  return _internal_is_offroad();
}
inline void ReferenceLineDebug::set_is_offroad(bool value) {
  _internal_set_is_offroad(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.is_offroad)
}
inline bool ReferenceLineDebug::_internal_is_offroad() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_offroad_;
}
inline void ReferenceLineDebug::_internal_set_is_offroad(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_offroad_ = value;
}

// optional double minimum_boundary = 8;
inline bool ReferenceLineDebug::has_minimum_boundary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_minimum_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minimum_boundary_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ReferenceLineDebug::minimum_boundary() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.minimum_boundary)
  return _internal_minimum_boundary();
}
inline void ReferenceLineDebug::set_minimum_boundary(double value) {
  _internal_set_minimum_boundary(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.minimum_boundary)
}
inline double ReferenceLineDebug::_internal_minimum_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.minimum_boundary_;
}
inline void ReferenceLineDebug::_internal_set_minimum_boundary(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minimum_boundary_ = value;
}

// optional double average_kappa = 9 [deprecated = true];
inline bool ReferenceLineDebug::has_average_kappa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_average_kappa() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_kappa_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double ReferenceLineDebug::average_kappa() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.average_kappa)
  return _internal_average_kappa();
}
inline void ReferenceLineDebug::set_average_kappa(double value) {
  _internal_set_average_kappa(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.average_kappa)
}
inline double ReferenceLineDebug::_internal_average_kappa() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_kappa_;
}
inline void ReferenceLineDebug::_internal_set_average_kappa(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_kappa_ = value;
}

// optional double average_dkappa = 10 [deprecated = true];
inline bool ReferenceLineDebug::has_average_dkappa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_average_dkappa() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_dkappa_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double ReferenceLineDebug::average_dkappa() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.average_dkappa)
  return _internal_average_dkappa();
}
inline void ReferenceLineDebug::set_average_dkappa(double value) {
  _internal_set_average_dkappa(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.average_dkappa)
}
inline double ReferenceLineDebug::_internal_average_dkappa() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_dkappa_;
}
inline void ReferenceLineDebug::_internal_set_average_dkappa(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_dkappa_ = value;
}

// optional double kappa_rms = 11;
inline bool ReferenceLineDebug::has_kappa_rms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_kappa_rms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kappa_rms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double ReferenceLineDebug::kappa_rms() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.kappa_rms)
  return _internal_kappa_rms();
}
inline void ReferenceLineDebug::set_kappa_rms(double value) {
  _internal_set_kappa_rms(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.kappa_rms)
}
inline double ReferenceLineDebug::_internal_kappa_rms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kappa_rms_;
}
inline void ReferenceLineDebug::_internal_set_kappa_rms(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kappa_rms_ = value;
}

// optional double dkappa_rms = 12;
inline bool ReferenceLineDebug::has_dkappa_rms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_dkappa_rms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dkappa_rms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double ReferenceLineDebug::dkappa_rms() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.dkappa_rms)
  return _internal_dkappa_rms();
}
inline void ReferenceLineDebug::set_dkappa_rms(double value) {
  _internal_set_dkappa_rms(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.dkappa_rms)
}
inline double ReferenceLineDebug::_internal_dkappa_rms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dkappa_rms_;
}
inline void ReferenceLineDebug::_internal_set_dkappa_rms(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dkappa_rms_ = value;
}

// optional double kappa_max_abs = 13;
inline bool ReferenceLineDebug::has_kappa_max_abs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_kappa_max_abs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kappa_max_abs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double ReferenceLineDebug::kappa_max_abs() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.kappa_max_abs)
  return _internal_kappa_max_abs();
}
inline void ReferenceLineDebug::set_kappa_max_abs(double value) {
  _internal_set_kappa_max_abs(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.kappa_max_abs)
}
inline double ReferenceLineDebug::_internal_kappa_max_abs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kappa_max_abs_;
}
inline void ReferenceLineDebug::_internal_set_kappa_max_abs(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kappa_max_abs_ = value;
}

// optional double dkappa_max_abs = 14;
inline bool ReferenceLineDebug::has_dkappa_max_abs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_dkappa_max_abs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dkappa_max_abs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double ReferenceLineDebug::dkappa_max_abs() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.dkappa_max_abs)
  return _internal_dkappa_max_abs();
}
inline void ReferenceLineDebug::set_dkappa_max_abs(double value) {
  _internal_set_dkappa_max_abs(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.dkappa_max_abs)
}
inline double ReferenceLineDebug::_internal_dkappa_max_abs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dkappa_max_abs_;
}
inline void ReferenceLineDebug::_internal_set_dkappa_max_abs(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dkappa_max_abs_ = value;
}

// optional double average_offset = 15;
inline bool ReferenceLineDebug::has_average_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ReferenceLineDebug::clear_average_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double ReferenceLineDebug::average_offset() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ReferenceLineDebug.average_offset)
  return _internal_average_offset();
}
inline void ReferenceLineDebug::set_average_offset(double value) {
  _internal_set_average_offset(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ReferenceLineDebug.average_offset)
}
inline double ReferenceLineDebug::_internal_average_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_offset_;
}
inline void ReferenceLineDebug::_internal_set_average_offset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_offset_ = value;
}

// -------------------------------------------------------------------

// SampleLayerDebug

// repeated .control.common.SLPoint sl_point = 1;
inline int SampleLayerDebug::_internal_sl_point_size() const {
  return _internal_sl_point().size();
}
inline int SampleLayerDebug::sl_point_size() const {
  return _internal_sl_point_size();
}
inline ::control::common::SLPoint* SampleLayerDebug::mutable_sl_point(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.SampleLayerDebug.sl_point)
  return _internal_mutable_sl_point()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* SampleLayerDebug::mutable_sl_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.SampleLayerDebug.sl_point)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sl_point();
}
inline const ::control::common::SLPoint& SampleLayerDebug::sl_point(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.SampleLayerDebug.sl_point)
  return _internal_sl_point().Get(index);
}
inline ::control::common::SLPoint* SampleLayerDebug::add_sl_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SLPoint* _add = _internal_mutable_sl_point()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.SampleLayerDebug.sl_point)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& SampleLayerDebug::sl_point() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.SampleLayerDebug.sl_point)
  return _internal_sl_point();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>&
SampleLayerDebug::_internal_sl_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sl_point_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>*
SampleLayerDebug::_internal_mutable_sl_point() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sl_point_;
}

// -------------------------------------------------------------------

// DpPolyGraphDebug

// repeated .control.planning_internal.SampleLayerDebug sample_layer = 1;
inline int DpPolyGraphDebug::_internal_sample_layer_size() const {
  return _internal_sample_layer().size();
}
inline int DpPolyGraphDebug::sample_layer_size() const {
  return _internal_sample_layer_size();
}
inline void DpPolyGraphDebug::clear_sample_layer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_layer_.Clear();
}
inline ::control::planning_internal::SampleLayerDebug* DpPolyGraphDebug::mutable_sample_layer(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.DpPolyGraphDebug.sample_layer)
  return _internal_mutable_sample_layer()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>* DpPolyGraphDebug::mutable_sample_layer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.DpPolyGraphDebug.sample_layer)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sample_layer();
}
inline const ::control::planning_internal::SampleLayerDebug& DpPolyGraphDebug::sample_layer(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.DpPolyGraphDebug.sample_layer)
  return _internal_sample_layer().Get(index);
}
inline ::control::planning_internal::SampleLayerDebug* DpPolyGraphDebug::add_sample_layer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::SampleLayerDebug* _add = _internal_mutable_sample_layer()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.DpPolyGraphDebug.sample_layer)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>& DpPolyGraphDebug::sample_layer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.DpPolyGraphDebug.sample_layer)
  return _internal_sample_layer();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>&
DpPolyGraphDebug::_internal_sample_layer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_layer_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::SampleLayerDebug>*
DpPolyGraphDebug::_internal_mutable_sample_layer() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sample_layer_;
}

// repeated .control.common.SLPoint min_cost_point = 2;
inline int DpPolyGraphDebug::_internal_min_cost_point_size() const {
  return _internal_min_cost_point().size();
}
inline int DpPolyGraphDebug::min_cost_point_size() const {
  return _internal_min_cost_point_size();
}
inline ::control::common::SLPoint* DpPolyGraphDebug::mutable_min_cost_point(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.DpPolyGraphDebug.min_cost_point)
  return _internal_mutable_min_cost_point()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>* DpPolyGraphDebug::mutable_min_cost_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.DpPolyGraphDebug.min_cost_point)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_min_cost_point();
}
inline const ::control::common::SLPoint& DpPolyGraphDebug::min_cost_point(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.DpPolyGraphDebug.min_cost_point)
  return _internal_min_cost_point().Get(index);
}
inline ::control::common::SLPoint* DpPolyGraphDebug::add_min_cost_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::SLPoint* _add = _internal_mutable_min_cost_point()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.DpPolyGraphDebug.min_cost_point)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>& DpPolyGraphDebug::min_cost_point() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.DpPolyGraphDebug.min_cost_point)
  return _internal_min_cost_point();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>&
DpPolyGraphDebug::_internal_min_cost_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_cost_point_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::SLPoint>*
DpPolyGraphDebug::_internal_mutable_min_cost_point() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.min_cost_point_;
}

// -------------------------------------------------------------------

// ScenarioDebug

// optional int32 scenario_type = 1 [deprecated = true];
inline bool ScenarioDebug::has_scenario_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ScenarioDebug::clear_scenario_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scenario_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ScenarioDebug::scenario_type() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ScenarioDebug.scenario_type)
  return _internal_scenario_type();
}
inline void ScenarioDebug::set_scenario_type(::int32_t value) {
  _internal_set_scenario_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ScenarioDebug.scenario_type)
}
inline ::int32_t ScenarioDebug::_internal_scenario_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scenario_type_;
}
inline void ScenarioDebug::_internal_set_scenario_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scenario_type_ = value;
}

// optional int32 stage_type = 2 [deprecated = true];
inline bool ScenarioDebug::has_stage_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ScenarioDebug::clear_stage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t ScenarioDebug::stage_type() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.ScenarioDebug.stage_type)
  return _internal_stage_type();
}
inline void ScenarioDebug::set_stage_type(::int32_t value) {
  _internal_set_stage_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:control.planning_internal.ScenarioDebug.stage_type)
}
inline ::int32_t ScenarioDebug::_internal_stage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_type_;
}
inline void ScenarioDebug::_internal_set_stage_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_type_ = value;
}

// optional string msg = 3;
inline bool ScenarioDebug::has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ScenarioDebug::clear_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScenarioDebug::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.ScenarioDebug.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScenarioDebug::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.ScenarioDebug.msg)
}
inline std::string* ScenarioDebug::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.ScenarioDebug.msg)
  return _s;
}
inline const std::string& ScenarioDebug::_internal_msg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.msg_.Get();
}
inline void ScenarioDebug::_internal_set_msg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* ScenarioDebug::_internal_mutable_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* ScenarioDebug::release_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.ScenarioDebug.msg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.msg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScenarioDebug::set_allocated_msg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.ScenarioDebug.msg)
}

// optional string scenario_plugin_type = 4;
inline bool ScenarioDebug::has_scenario_plugin_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ScenarioDebug::clear_scenario_plugin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scenario_plugin_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ScenarioDebug::scenario_plugin_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.ScenarioDebug.scenario_plugin_type)
  return _internal_scenario_plugin_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScenarioDebug::set_scenario_plugin_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.scenario_plugin_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.ScenarioDebug.scenario_plugin_type)
}
inline std::string* ScenarioDebug::mutable_scenario_plugin_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_scenario_plugin_type();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.ScenarioDebug.scenario_plugin_type)
  return _s;
}
inline const std::string& ScenarioDebug::_internal_scenario_plugin_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scenario_plugin_type_.Get();
}
inline void ScenarioDebug::_internal_set_scenario_plugin_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.scenario_plugin_type_.Set(value, GetArena());
}
inline std::string* ScenarioDebug::_internal_mutable_scenario_plugin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.scenario_plugin_type_.Mutable( GetArena());
}
inline std::string* ScenarioDebug::release_scenario_plugin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.ScenarioDebug.scenario_plugin_type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.scenario_plugin_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scenario_plugin_type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScenarioDebug::set_allocated_scenario_plugin_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.scenario_plugin_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.scenario_plugin_type_.IsDefault()) {
          _impl_.scenario_plugin_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.ScenarioDebug.scenario_plugin_type)
}

// optional string stage_plugin_type = 5;
inline bool ScenarioDebug::has_stage_plugin_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ScenarioDebug::clear_stage_plugin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_plugin_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ScenarioDebug::stage_plugin_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.ScenarioDebug.stage_plugin_type)
  return _internal_stage_plugin_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScenarioDebug::set_stage_plugin_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stage_plugin_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.ScenarioDebug.stage_plugin_type)
}
inline std::string* ScenarioDebug::mutable_stage_plugin_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stage_plugin_type();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.ScenarioDebug.stage_plugin_type)
  return _s;
}
inline const std::string& ScenarioDebug::_internal_stage_plugin_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_plugin_type_.Get();
}
inline void ScenarioDebug::_internal_set_stage_plugin_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stage_plugin_type_.Set(value, GetArena());
}
inline std::string* ScenarioDebug::_internal_mutable_stage_plugin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stage_plugin_type_.Mutable( GetArena());
}
inline std::string* ScenarioDebug::release_stage_plugin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.ScenarioDebug.stage_plugin_type)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.stage_plugin_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stage_plugin_type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScenarioDebug::set_allocated_stage_plugin_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stage_plugin_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stage_plugin_type_.IsDefault()) {
          _impl_.stage_plugin_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.ScenarioDebug.stage_plugin_type)
}

// -------------------------------------------------------------------

// Trajectories

// repeated .control.common.Trajectory trajectory = 1;
inline int Trajectories::_internal_trajectory_size() const {
  return _internal_trajectory().size();
}
inline int Trajectories::trajectory_size() const {
  return _internal_trajectory_size();
}
inline ::control::common::Trajectory* Trajectories::mutable_trajectory(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.Trajectories.trajectory)
  return _internal_mutable_trajectory()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>* Trajectories::mutable_trajectory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.Trajectories.trajectory)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_trajectory();
}
inline const ::control::common::Trajectory& Trajectories::trajectory(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.Trajectories.trajectory)
  return _internal_trajectory().Get(index);
}
inline ::control::common::Trajectory* Trajectories::add_trajectory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::Trajectory* _add = _internal_mutable_trajectory()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.Trajectories.trajectory)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>& Trajectories::trajectory() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.Trajectories.trajectory)
  return _internal_trajectory();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>&
Trajectories::_internal_trajectory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trajectory_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::Trajectory>*
Trajectories::_internal_mutable_trajectory() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.trajectory_;
}

// -------------------------------------------------------------------

// OpenSpaceDebug

// optional .control.planning_internal.Trajectories trajectories = 1;
inline bool OpenSpaceDebug::has_trajectories() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trajectories_ != nullptr);
  return value;
}
inline void OpenSpaceDebug::clear_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trajectories_ != nullptr) _impl_.trajectories_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::_internal_trajectories() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::Trajectories* p = _impl_.trajectories_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::Trajectories&>(::control::planning_internal::_Trajectories_default_instance_);
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::trajectories() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.trajectories)
  return _internal_trajectories();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_trajectories(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trajectories_);
  }
  _impl_.trajectories_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.trajectories)
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::release_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning_internal::Trajectories* released = _impl_.trajectories_;
  _impl_.trajectories_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::unsafe_arena_release_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.trajectories)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning_internal::Trajectories* temp = _impl_.trajectories_;
  _impl_.trajectories_ = nullptr;
  return temp;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::_internal_mutable_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trajectories_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::Trajectories>(GetArena());
    _impl_.trajectories_ = reinterpret_cast<::control::planning_internal::Trajectories*>(p);
  }
  return _impl_.trajectories_;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::mutable_trajectories() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::planning_internal::Trajectories* _msg = _internal_mutable_trajectories();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.trajectories)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_trajectories(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trajectories_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.trajectories_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.trajectories)
}

// optional .control.common.VehicleMotion warm_start_trajectory = 2;
inline bool OpenSpaceDebug::has_warm_start_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.warm_start_trajectory_ != nullptr);
  return value;
}
inline const ::control::common::VehicleMotion& OpenSpaceDebug::_internal_warm_start_trajectory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::VehicleMotion* p = _impl_.warm_start_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::VehicleMotion&>(::control::common::_VehicleMotion_default_instance_);
}
inline const ::control::common::VehicleMotion& OpenSpaceDebug::warm_start_trajectory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.warm_start_trajectory)
  return _internal_warm_start_trajectory();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_warm_start_trajectory(::control::common::VehicleMotion* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.warm_start_trajectory_);
  }
  _impl_.warm_start_trajectory_ = reinterpret_cast<::control::common::VehicleMotion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.warm_start_trajectory)
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::release_warm_start_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::common::VehicleMotion* released = _impl_.warm_start_trajectory_;
  _impl_.warm_start_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::unsafe_arena_release_warm_start_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.warm_start_trajectory)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::common::VehicleMotion* temp = _impl_.warm_start_trajectory_;
  _impl_.warm_start_trajectory_ = nullptr;
  return temp;
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::_internal_mutable_warm_start_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.warm_start_trajectory_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::VehicleMotion>(GetArena());
    _impl_.warm_start_trajectory_ = reinterpret_cast<::control::common::VehicleMotion*>(p);
  }
  return _impl_.warm_start_trajectory_;
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::mutable_warm_start_trajectory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::common::VehicleMotion* _msg = _internal_mutable_warm_start_trajectory();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.warm_start_trajectory)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_warm_start_trajectory(::control::common::VehicleMotion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.warm_start_trajectory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.warm_start_trajectory_ = reinterpret_cast<::control::common::VehicleMotion*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.warm_start_trajectory)
}

// optional .control.common.VehicleMotion smoothed_trajectory = 3;
inline bool OpenSpaceDebug::has_smoothed_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.smoothed_trajectory_ != nullptr);
  return value;
}
inline const ::control::common::VehicleMotion& OpenSpaceDebug::_internal_smoothed_trajectory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::VehicleMotion* p = _impl_.smoothed_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::VehicleMotion&>(::control::common::_VehicleMotion_default_instance_);
}
inline const ::control::common::VehicleMotion& OpenSpaceDebug::smoothed_trajectory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.smoothed_trajectory)
  return _internal_smoothed_trajectory();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_smoothed_trajectory(::control::common::VehicleMotion* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.smoothed_trajectory_);
  }
  _impl_.smoothed_trajectory_ = reinterpret_cast<::control::common::VehicleMotion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.smoothed_trajectory)
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::release_smoothed_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::common::VehicleMotion* released = _impl_.smoothed_trajectory_;
  _impl_.smoothed_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::unsafe_arena_release_smoothed_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.smoothed_trajectory)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::common::VehicleMotion* temp = _impl_.smoothed_trajectory_;
  _impl_.smoothed_trajectory_ = nullptr;
  return temp;
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::_internal_mutable_smoothed_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.smoothed_trajectory_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::VehicleMotion>(GetArena());
    _impl_.smoothed_trajectory_ = reinterpret_cast<::control::common::VehicleMotion*>(p);
  }
  return _impl_.smoothed_trajectory_;
}
inline ::control::common::VehicleMotion* OpenSpaceDebug::mutable_smoothed_trajectory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::control::common::VehicleMotion* _msg = _internal_mutable_smoothed_trajectory();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.smoothed_trajectory)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_smoothed_trajectory(::control::common::VehicleMotion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.smoothed_trajectory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.smoothed_trajectory_ = reinterpret_cast<::control::common::VehicleMotion*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.smoothed_trajectory)
}

// repeated double warm_start_dual_lambda = 4;
inline int OpenSpaceDebug::_internal_warm_start_dual_lambda_size() const {
  return _internal_warm_start_dual_lambda().size();
}
inline int OpenSpaceDebug::warm_start_dual_lambda_size() const {
  return _internal_warm_start_dual_lambda_size();
}
inline void OpenSpaceDebug::clear_warm_start_dual_lambda() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.warm_start_dual_lambda_.Clear();
}
inline double OpenSpaceDebug::warm_start_dual_lambda(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.warm_start_dual_lambda)
  return _internal_warm_start_dual_lambda().Get(index);
}
inline void OpenSpaceDebug::set_warm_start_dual_lambda(int index, double value) {
  _internal_mutable_warm_start_dual_lambda()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.warm_start_dual_lambda)
}
inline void OpenSpaceDebug::add_warm_start_dual_lambda(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_warm_start_dual_lambda()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.OpenSpaceDebug.warm_start_dual_lambda)
}
inline const ::google::protobuf::RepeatedField<double>& OpenSpaceDebug::warm_start_dual_lambda() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.OpenSpaceDebug.warm_start_dual_lambda)
  return _internal_warm_start_dual_lambda();
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::mutable_warm_start_dual_lambda()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.OpenSpaceDebug.warm_start_dual_lambda)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warm_start_dual_lambda();
}
inline const ::google::protobuf::RepeatedField<double>&
OpenSpaceDebug::_internal_warm_start_dual_lambda() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warm_start_dual_lambda_;
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::_internal_mutable_warm_start_dual_lambda() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warm_start_dual_lambda_;
}

// repeated double warm_start_dual_miu = 5;
inline int OpenSpaceDebug::_internal_warm_start_dual_miu_size() const {
  return _internal_warm_start_dual_miu().size();
}
inline int OpenSpaceDebug::warm_start_dual_miu_size() const {
  return _internal_warm_start_dual_miu_size();
}
inline void OpenSpaceDebug::clear_warm_start_dual_miu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.warm_start_dual_miu_.Clear();
}
inline double OpenSpaceDebug::warm_start_dual_miu(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.warm_start_dual_miu)
  return _internal_warm_start_dual_miu().Get(index);
}
inline void OpenSpaceDebug::set_warm_start_dual_miu(int index, double value) {
  _internal_mutable_warm_start_dual_miu()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.warm_start_dual_miu)
}
inline void OpenSpaceDebug::add_warm_start_dual_miu(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_warm_start_dual_miu()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.OpenSpaceDebug.warm_start_dual_miu)
}
inline const ::google::protobuf::RepeatedField<double>& OpenSpaceDebug::warm_start_dual_miu() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.OpenSpaceDebug.warm_start_dual_miu)
  return _internal_warm_start_dual_miu();
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::mutable_warm_start_dual_miu()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.OpenSpaceDebug.warm_start_dual_miu)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warm_start_dual_miu();
}
inline const ::google::protobuf::RepeatedField<double>&
OpenSpaceDebug::_internal_warm_start_dual_miu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warm_start_dual_miu_;
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::_internal_mutable_warm_start_dual_miu() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warm_start_dual_miu_;
}

// repeated double optimized_dual_lambda = 6;
inline int OpenSpaceDebug::_internal_optimized_dual_lambda_size() const {
  return _internal_optimized_dual_lambda().size();
}
inline int OpenSpaceDebug::optimized_dual_lambda_size() const {
  return _internal_optimized_dual_lambda_size();
}
inline void OpenSpaceDebug::clear_optimized_dual_lambda() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.optimized_dual_lambda_.Clear();
}
inline double OpenSpaceDebug::optimized_dual_lambda(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.optimized_dual_lambda)
  return _internal_optimized_dual_lambda().Get(index);
}
inline void OpenSpaceDebug::set_optimized_dual_lambda(int index, double value) {
  _internal_mutable_optimized_dual_lambda()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.optimized_dual_lambda)
}
inline void OpenSpaceDebug::add_optimized_dual_lambda(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_optimized_dual_lambda()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.OpenSpaceDebug.optimized_dual_lambda)
}
inline const ::google::protobuf::RepeatedField<double>& OpenSpaceDebug::optimized_dual_lambda() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.OpenSpaceDebug.optimized_dual_lambda)
  return _internal_optimized_dual_lambda();
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::mutable_optimized_dual_lambda()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.OpenSpaceDebug.optimized_dual_lambda)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_optimized_dual_lambda();
}
inline const ::google::protobuf::RepeatedField<double>&
OpenSpaceDebug::_internal_optimized_dual_lambda() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.optimized_dual_lambda_;
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::_internal_mutable_optimized_dual_lambda() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.optimized_dual_lambda_;
}

// repeated double optimized_dual_miu = 7;
inline int OpenSpaceDebug::_internal_optimized_dual_miu_size() const {
  return _internal_optimized_dual_miu().size();
}
inline int OpenSpaceDebug::optimized_dual_miu_size() const {
  return _internal_optimized_dual_miu_size();
}
inline void OpenSpaceDebug::clear_optimized_dual_miu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.optimized_dual_miu_.Clear();
}
inline double OpenSpaceDebug::optimized_dual_miu(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.optimized_dual_miu)
  return _internal_optimized_dual_miu().Get(index);
}
inline void OpenSpaceDebug::set_optimized_dual_miu(int index, double value) {
  _internal_mutable_optimized_dual_miu()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.optimized_dual_miu)
}
inline void OpenSpaceDebug::add_optimized_dual_miu(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_optimized_dual_miu()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.OpenSpaceDebug.optimized_dual_miu)
}
inline const ::google::protobuf::RepeatedField<double>& OpenSpaceDebug::optimized_dual_miu() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.OpenSpaceDebug.optimized_dual_miu)
  return _internal_optimized_dual_miu();
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::mutable_optimized_dual_miu()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.OpenSpaceDebug.optimized_dual_miu)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_optimized_dual_miu();
}
inline const ::google::protobuf::RepeatedField<double>&
OpenSpaceDebug::_internal_optimized_dual_miu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.optimized_dual_miu_;
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::_internal_mutable_optimized_dual_miu() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.optimized_dual_miu_;
}

// repeated double xy_boundary = 8;
inline int OpenSpaceDebug::_internal_xy_boundary_size() const {
  return _internal_xy_boundary().size();
}
inline int OpenSpaceDebug::xy_boundary_size() const {
  return _internal_xy_boundary_size();
}
inline void OpenSpaceDebug::clear_xy_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xy_boundary_.Clear();
}
inline double OpenSpaceDebug::xy_boundary(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.xy_boundary)
  return _internal_xy_boundary().Get(index);
}
inline void OpenSpaceDebug::set_xy_boundary(int index, double value) {
  _internal_mutable_xy_boundary()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.xy_boundary)
}
inline void OpenSpaceDebug::add_xy_boundary(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_xy_boundary()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.OpenSpaceDebug.xy_boundary)
}
inline const ::google::protobuf::RepeatedField<double>& OpenSpaceDebug::xy_boundary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.OpenSpaceDebug.xy_boundary)
  return _internal_xy_boundary();
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::mutable_xy_boundary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.OpenSpaceDebug.xy_boundary)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_xy_boundary();
}
inline const ::google::protobuf::RepeatedField<double>&
OpenSpaceDebug::_internal_xy_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xy_boundary_;
}
inline ::google::protobuf::RepeatedField<double>* OpenSpaceDebug::_internal_mutable_xy_boundary() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.xy_boundary_;
}

// repeated .control.planning_internal.ObstacleDebug obstacles = 9;
inline int OpenSpaceDebug::_internal_obstacles_size() const {
  return _internal_obstacles().size();
}
inline int OpenSpaceDebug::obstacles_size() const {
  return _internal_obstacles_size();
}
inline void OpenSpaceDebug::clear_obstacles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.obstacles_.Clear();
}
inline ::control::planning_internal::ObstacleDebug* OpenSpaceDebug::mutable_obstacles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.obstacles)
  return _internal_mutable_obstacles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>* OpenSpaceDebug::mutable_obstacles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.OpenSpaceDebug.obstacles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_obstacles();
}
inline const ::control::planning_internal::ObstacleDebug& OpenSpaceDebug::obstacles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.obstacles)
  return _internal_obstacles().Get(index);
}
inline ::control::planning_internal::ObstacleDebug* OpenSpaceDebug::add_obstacles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::ObstacleDebug* _add = _internal_mutable_obstacles()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.OpenSpaceDebug.obstacles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>& OpenSpaceDebug::obstacles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.OpenSpaceDebug.obstacles)
  return _internal_obstacles();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>&
OpenSpaceDebug::_internal_obstacles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.obstacles_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>*
OpenSpaceDebug::_internal_mutable_obstacles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.obstacles_;
}

// optional .control.common.TrajectoryPoint roi_shift_point = 10;
inline bool OpenSpaceDebug::has_roi_shift_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roi_shift_point_ != nullptr);
  return value;
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::_internal_roi_shift_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::TrajectoryPoint* p = _impl_.roi_shift_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::TrajectoryPoint&>(::control::common::_TrajectoryPoint_default_instance_);
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::roi_shift_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.roi_shift_point)
  return _internal_roi_shift_point();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_roi_shift_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roi_shift_point_);
  }
  _impl_.roi_shift_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.roi_shift_point)
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::release_roi_shift_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::control::common::TrajectoryPoint* released = _impl_.roi_shift_point_;
  _impl_.roi_shift_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::unsafe_arena_release_roi_shift_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.roi_shift_point)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::control::common::TrajectoryPoint* temp = _impl_.roi_shift_point_;
  _impl_.roi_shift_point_ = nullptr;
  return temp;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::_internal_mutable_roi_shift_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roi_shift_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::TrajectoryPoint>(GetArena());
    _impl_.roi_shift_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(p);
  }
  return _impl_.roi_shift_point_;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::mutable_roi_shift_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::control::common::TrajectoryPoint* _msg = _internal_mutable_roi_shift_point();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.roi_shift_point)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_roi_shift_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roi_shift_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.roi_shift_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.roi_shift_point)
}

// optional .control.common.TrajectoryPoint end_point = 11;
inline bool OpenSpaceDebug::has_end_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_point_ != nullptr);
  return value;
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::_internal_end_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::TrajectoryPoint* p = _impl_.end_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::TrajectoryPoint&>(::control::common::_TrajectoryPoint_default_instance_);
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::end_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.end_point)
  return _internal_end_point();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_end_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_point_);
  }
  _impl_.end_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.end_point)
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::release_end_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::control::common::TrajectoryPoint* released = _impl_.end_point_;
  _impl_.end_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::unsafe_arena_release_end_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.end_point)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::control::common::TrajectoryPoint* temp = _impl_.end_point_;
  _impl_.end_point_ = nullptr;
  return temp;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::_internal_mutable_end_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::TrajectoryPoint>(GetArena());
    _impl_.end_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(p);
  }
  return _impl_.end_point_;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::mutable_end_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::control::common::TrajectoryPoint* _msg = _internal_mutable_end_point();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.end_point)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_end_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.end_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.end_point)
}

// optional .control.planning_internal.Trajectories partitioned_trajectories = 12;
inline bool OpenSpaceDebug::has_partitioned_trajectories() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.partitioned_trajectories_ != nullptr);
  return value;
}
inline void OpenSpaceDebug::clear_partitioned_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.partitioned_trajectories_ != nullptr) _impl_.partitioned_trajectories_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::_internal_partitioned_trajectories() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::Trajectories* p = _impl_.partitioned_trajectories_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::Trajectories&>(::control::planning_internal::_Trajectories_default_instance_);
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::partitioned_trajectories() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.partitioned_trajectories)
  return _internal_partitioned_trajectories();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_partitioned_trajectories(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.partitioned_trajectories_);
  }
  _impl_.partitioned_trajectories_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.partitioned_trajectories)
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::release_partitioned_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::control::planning_internal::Trajectories* released = _impl_.partitioned_trajectories_;
  _impl_.partitioned_trajectories_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::unsafe_arena_release_partitioned_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.partitioned_trajectories)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::control::planning_internal::Trajectories* temp = _impl_.partitioned_trajectories_;
  _impl_.partitioned_trajectories_ = nullptr;
  return temp;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::_internal_mutable_partitioned_trajectories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.partitioned_trajectories_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::Trajectories>(GetArena());
    _impl_.partitioned_trajectories_ = reinterpret_cast<::control::planning_internal::Trajectories*>(p);
  }
  return _impl_.partitioned_trajectories_;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::mutable_partitioned_trajectories() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::control::planning_internal::Trajectories* _msg = _internal_mutable_partitioned_trajectories();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.partitioned_trajectories)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_partitioned_trajectories(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.partitioned_trajectories_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.partitioned_trajectories_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.partitioned_trajectories)
}

// optional .control.planning_internal.Trajectories chosen_trajectory = 13;
inline bool OpenSpaceDebug::has_chosen_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chosen_trajectory_ != nullptr);
  return value;
}
inline void OpenSpaceDebug::clear_chosen_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chosen_trajectory_ != nullptr) _impl_.chosen_trajectory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::_internal_chosen_trajectory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::Trajectories* p = _impl_.chosen_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::Trajectories&>(::control::planning_internal::_Trajectories_default_instance_);
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::chosen_trajectory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.chosen_trajectory)
  return _internal_chosen_trajectory();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_chosen_trajectory(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chosen_trajectory_);
  }
  _impl_.chosen_trajectory_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.chosen_trajectory)
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::release_chosen_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::control::planning_internal::Trajectories* released = _impl_.chosen_trajectory_;
  _impl_.chosen_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::unsafe_arena_release_chosen_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.chosen_trajectory)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::control::planning_internal::Trajectories* temp = _impl_.chosen_trajectory_;
  _impl_.chosen_trajectory_ = nullptr;
  return temp;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::_internal_mutable_chosen_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chosen_trajectory_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::Trajectories>(GetArena());
    _impl_.chosen_trajectory_ = reinterpret_cast<::control::planning_internal::Trajectories*>(p);
  }
  return _impl_.chosen_trajectory_;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::mutable_chosen_trajectory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::control::planning_internal::Trajectories* _msg = _internal_mutable_chosen_trajectory();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.chosen_trajectory)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_chosen_trajectory(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.chosen_trajectory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.chosen_trajectory_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.chosen_trajectory)
}

// optional bool is_fallback_trajectory = 14;
inline bool OpenSpaceDebug::has_is_fallback_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void OpenSpaceDebug::clear_is_fallback_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_fallback_trajectory_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool OpenSpaceDebug::is_fallback_trajectory() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.is_fallback_trajectory)
  return _internal_is_fallback_trajectory();
}
inline void OpenSpaceDebug::set_is_fallback_trajectory(bool value) {
  _internal_set_is_fallback_trajectory(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.is_fallback_trajectory)
}
inline bool OpenSpaceDebug::_internal_is_fallback_trajectory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_fallback_trajectory_;
}
inline void OpenSpaceDebug::_internal_set_is_fallback_trajectory(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_fallback_trajectory_ = value;
}

// optional .control.planning_internal.Trajectories fallback_trajectory = 15;
inline bool OpenSpaceDebug::has_fallback_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fallback_trajectory_ != nullptr);
  return value;
}
inline void OpenSpaceDebug::clear_fallback_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fallback_trajectory_ != nullptr) _impl_.fallback_trajectory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::_internal_fallback_trajectory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::Trajectories* p = _impl_.fallback_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::Trajectories&>(::control::planning_internal::_Trajectories_default_instance_);
}
inline const ::control::planning_internal::Trajectories& OpenSpaceDebug::fallback_trajectory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.fallback_trajectory)
  return _internal_fallback_trajectory();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_fallback_trajectory(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fallback_trajectory_);
  }
  _impl_.fallback_trajectory_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.fallback_trajectory)
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::release_fallback_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::control::planning_internal::Trajectories* released = _impl_.fallback_trajectory_;
  _impl_.fallback_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::unsafe_arena_release_fallback_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.fallback_trajectory)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::control::planning_internal::Trajectories* temp = _impl_.fallback_trajectory_;
  _impl_.fallback_trajectory_ = nullptr;
  return temp;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::_internal_mutable_fallback_trajectory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fallback_trajectory_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::Trajectories>(GetArena());
    _impl_.fallback_trajectory_ = reinterpret_cast<::control::planning_internal::Trajectories*>(p);
  }
  return _impl_.fallback_trajectory_;
}
inline ::control::planning_internal::Trajectories* OpenSpaceDebug::mutable_fallback_trajectory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::control::planning_internal::Trajectories* _msg = _internal_mutable_fallback_trajectory();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.fallback_trajectory)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_fallback_trajectory(::control::planning_internal::Trajectories* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.fallback_trajectory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.fallback_trajectory_ = reinterpret_cast<::control::planning_internal::Trajectories*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.fallback_trajectory)
}

// optional .control.common.TrajectoryPoint trajectory_stitching_point = 16;
inline bool OpenSpaceDebug::has_trajectory_stitching_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trajectory_stitching_point_ != nullptr);
  return value;
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::_internal_trajectory_stitching_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::TrajectoryPoint* p = _impl_.trajectory_stitching_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::TrajectoryPoint&>(::control::common::_TrajectoryPoint_default_instance_);
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::trajectory_stitching_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.trajectory_stitching_point)
  return _internal_trajectory_stitching_point();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_trajectory_stitching_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trajectory_stitching_point_);
  }
  _impl_.trajectory_stitching_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.trajectory_stitching_point)
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::release_trajectory_stitching_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::control::common::TrajectoryPoint* released = _impl_.trajectory_stitching_point_;
  _impl_.trajectory_stitching_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::unsafe_arena_release_trajectory_stitching_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.trajectory_stitching_point)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::control::common::TrajectoryPoint* temp = _impl_.trajectory_stitching_point_;
  _impl_.trajectory_stitching_point_ = nullptr;
  return temp;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::_internal_mutable_trajectory_stitching_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trajectory_stitching_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::TrajectoryPoint>(GetArena());
    _impl_.trajectory_stitching_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(p);
  }
  return _impl_.trajectory_stitching_point_;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::mutable_trajectory_stitching_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::control::common::TrajectoryPoint* _msg = _internal_mutable_trajectory_stitching_point();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.trajectory_stitching_point)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_trajectory_stitching_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trajectory_stitching_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.trajectory_stitching_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.trajectory_stitching_point)
}

// optional .control.common.TrajectoryPoint future_collision_point = 17;
inline bool OpenSpaceDebug::has_future_collision_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.future_collision_point_ != nullptr);
  return value;
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::_internal_future_collision_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::TrajectoryPoint* p = _impl_.future_collision_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::TrajectoryPoint&>(::control::common::_TrajectoryPoint_default_instance_);
}
inline const ::control::common::TrajectoryPoint& OpenSpaceDebug::future_collision_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.future_collision_point)
  return _internal_future_collision_point();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_future_collision_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.future_collision_point_);
  }
  _impl_.future_collision_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.future_collision_point)
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::release_future_collision_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::control::common::TrajectoryPoint* released = _impl_.future_collision_point_;
  _impl_.future_collision_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::unsafe_arena_release_future_collision_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.future_collision_point)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::control::common::TrajectoryPoint* temp = _impl_.future_collision_point_;
  _impl_.future_collision_point_ = nullptr;
  return temp;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::_internal_mutable_future_collision_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.future_collision_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::TrajectoryPoint>(GetArena());
    _impl_.future_collision_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(p);
  }
  return _impl_.future_collision_point_;
}
inline ::control::common::TrajectoryPoint* OpenSpaceDebug::mutable_future_collision_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::control::common::TrajectoryPoint* _msg = _internal_mutable_future_collision_point();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.future_collision_point)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_future_collision_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.future_collision_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.future_collision_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.future_collision_point)
}

// optional double time_latency = 18 [default = 0];
inline bool OpenSpaceDebug::has_time_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void OpenSpaceDebug::clear_time_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_latency_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double OpenSpaceDebug::time_latency() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.time_latency)
  return _internal_time_latency();
}
inline void OpenSpaceDebug::set_time_latency(double value) {
  _internal_set_time_latency(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.time_latency)
}
inline double OpenSpaceDebug::_internal_time_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_latency_;
}
inline void OpenSpaceDebug::_internal_set_time_latency(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_latency_ = value;
}

// optional .control.common.PointENU origin_point = 19;
inline bool OpenSpaceDebug::has_origin_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_point_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& OpenSpaceDebug::_internal_origin_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.origin_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& OpenSpaceDebug::origin_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.origin_point)
  return _internal_origin_point();
}
inline void OpenSpaceDebug::unsafe_arena_set_allocated_origin_point(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_point_);
  }
  _impl_.origin_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.OpenSpaceDebug.origin_point)
}
inline ::control::common::PointENU* OpenSpaceDebug::release_origin_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::control::common::PointENU* released = _impl_.origin_point_;
  _impl_.origin_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* OpenSpaceDebug::unsafe_arena_release_origin_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.OpenSpaceDebug.origin_point)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::control::common::PointENU* temp = _impl_.origin_point_;
  _impl_.origin_point_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* OpenSpaceDebug::_internal_mutable_origin_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.origin_point_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.origin_point_;
}
inline ::control::common::PointENU* OpenSpaceDebug::mutable_origin_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::control::common::PointENU* _msg = _internal_mutable_origin_point();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.OpenSpaceDebug.origin_point)
  return _msg;
}
inline void OpenSpaceDebug::set_allocated_origin_point(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.origin_point_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.OpenSpaceDebug.origin_point)
}

// optional double origin_heading_rad = 20;
inline bool OpenSpaceDebug::has_origin_heading_rad() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void OpenSpaceDebug::clear_origin_heading_rad() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_heading_rad_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline double OpenSpaceDebug::origin_heading_rad() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.OpenSpaceDebug.origin_heading_rad)
  return _internal_origin_heading_rad();
}
inline void OpenSpaceDebug::set_origin_heading_rad(double value) {
  _internal_set_origin_heading_rad(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:control.planning_internal.OpenSpaceDebug.origin_heading_rad)
}
inline double OpenSpaceDebug::_internal_origin_heading_rad() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.origin_heading_rad_;
}
inline void OpenSpaceDebug::_internal_set_origin_heading_rad(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_heading_rad_ = value;
}

// -------------------------------------------------------------------

// SmootherDebug

// optional bool is_smoothed = 1;
inline bool SmootherDebug::has_is_smoothed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SmootherDebug::clear_is_smoothed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_smoothed_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SmootherDebug::is_smoothed() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SmootherDebug.is_smoothed)
  return _internal_is_smoothed();
}
inline void SmootherDebug::set_is_smoothed(bool value) {
  _internal_set_is_smoothed(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning_internal.SmootherDebug.is_smoothed)
}
inline bool SmootherDebug::_internal_is_smoothed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_smoothed_;
}
inline void SmootherDebug::_internal_set_is_smoothed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_smoothed_ = value;
}

// optional .control.planning_internal.SmootherDebug.SmootherType type = 2 [default = SMOOTHER_NONE];
inline bool SmootherDebug::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SmootherDebug::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::control::planning_internal::SmootherDebug_SmootherType SmootherDebug::type() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.SmootherDebug.type)
  return _internal_type();
}
inline void SmootherDebug::set_type(::control::planning_internal::SmootherDebug_SmootherType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning_internal.SmootherDebug.type)
}
inline ::control::planning_internal::SmootherDebug_SmootherType SmootherDebug::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control::planning_internal::SmootherDebug_SmootherType>(_impl_.type_);
}
inline void SmootherDebug::_internal_set_type(::control::planning_internal::SmootherDebug_SmootherType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::control::planning_internal::SmootherDebug_SmootherType_IsValid(value));
  _impl_.type_ = value;
}

// optional string reason = 3;
inline bool SmootherDebug::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SmootherDebug::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SmootherDebug::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.SmootherDebug.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SmootherDebug::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.SmootherDebug.reason)
}
inline std::string* SmootherDebug::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.SmootherDebug.reason)
  return _s;
}
inline const std::string& SmootherDebug::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void SmootherDebug::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* SmootherDebug::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* SmootherDebug::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.SmootherDebug.reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SmootherDebug::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.SmootherDebug.reason)
}

// -------------------------------------------------------------------

// PullOverDebug

// optional .control.common.PointENU position = 1;
inline bool PullOverDebug::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::control::common::PointENU& PullOverDebug::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::PointENU* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::PointENU&>(::control::common::_PointENU_default_instance_);
}
inline const ::control::common::PointENU& PullOverDebug::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PullOverDebug.position)
  return _internal_position();
}
inline void PullOverDebug::unsafe_arena_set_allocated_position(::control::common::PointENU* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::control::common::PointENU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PullOverDebug.position)
}
inline ::control::common::PointENU* PullOverDebug::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::PointENU* PullOverDebug::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PullOverDebug.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::common::PointENU* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::control::common::PointENU* PullOverDebug::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::PointENU>(GetArena());
    _impl_.position_ = reinterpret_cast<::control::common::PointENU*>(p);
  }
  return _impl_.position_;
}
inline ::control::common::PointENU* PullOverDebug::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::common::PointENU* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PullOverDebug.position)
  return _msg;
}
inline void PullOverDebug::set_allocated_position(::control::common::PointENU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::control::common::PointENU*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PullOverDebug.position)
}

// optional double theta = 2;
inline bool PullOverDebug::has_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PullOverDebug::clear_theta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PullOverDebug::theta() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.PullOverDebug.theta)
  return _internal_theta();
}
inline void PullOverDebug::set_theta(double value) {
  _internal_set_theta(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning_internal.PullOverDebug.theta)
}
inline double PullOverDebug::_internal_theta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.theta_;
}
inline void PullOverDebug::_internal_set_theta(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.theta_ = value;
}

// optional double length_front = 3;
inline bool PullOverDebug::has_length_front() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PullOverDebug::clear_length_front() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_front_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PullOverDebug::length_front() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.PullOverDebug.length_front)
  return _internal_length_front();
}
inline void PullOverDebug::set_length_front(double value) {
  _internal_set_length_front(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning_internal.PullOverDebug.length_front)
}
inline double PullOverDebug::_internal_length_front() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_front_;
}
inline void PullOverDebug::_internal_set_length_front(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_front_ = value;
}

// optional double length_back = 4;
inline bool PullOverDebug::has_length_back() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PullOverDebug::clear_length_back() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_back_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PullOverDebug::length_back() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.PullOverDebug.length_back)
  return _internal_length_back();
}
inline void PullOverDebug::set_length_back(double value) {
  _internal_set_length_back(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning_internal.PullOverDebug.length_back)
}
inline double PullOverDebug::_internal_length_back() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_back_;
}
inline void PullOverDebug::_internal_set_length_back(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_back_ = value;
}

// optional double width_left = 5;
inline bool PullOverDebug::has_width_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PullOverDebug::clear_width_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_left_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PullOverDebug::width_left() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.PullOverDebug.width_left)
  return _internal_width_left();
}
inline void PullOverDebug::set_width_left(double value) {
  _internal_set_width_left(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:control.planning_internal.PullOverDebug.width_left)
}
inline double PullOverDebug::_internal_width_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_left_;
}
inline void PullOverDebug::_internal_set_width_left(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_left_ = value;
}

// optional double width_right = 6;
inline bool PullOverDebug::has_width_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PullOverDebug::clear_width_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_right_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double PullOverDebug::width_right() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.PullOverDebug.width_right)
  return _internal_width_right();
}
inline void PullOverDebug::set_width_right(double value) {
  _internal_set_width_right(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:control.planning_internal.PullOverDebug.width_right)
}
inline double PullOverDebug::_internal_width_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_right_;
}
inline void PullOverDebug::_internal_set_width_right(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_right_ = value;
}

// -------------------------------------------------------------------

// PlanningData

// optional .control.localization.LocalizationEstimate adc_position = 7;
inline bool PlanningData::has_adc_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adc_position_ != nullptr);
  return value;
}
inline const ::control::localization::LocalizationEstimate& PlanningData::_internal_adc_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::localization::LocalizationEstimate* p = _impl_.adc_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::localization::LocalizationEstimate&>(::control::localization::_LocalizationEstimate_default_instance_);
}
inline const ::control::localization::LocalizationEstimate& PlanningData::adc_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.adc_position)
  return _internal_adc_position();
}
inline void PlanningData::unsafe_arena_set_allocated_adc_position(::control::localization::LocalizationEstimate* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.adc_position_);
  }
  _impl_.adc_position_ = reinterpret_cast<::control::localization::LocalizationEstimate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.adc_position)
}
inline ::control::localization::LocalizationEstimate* PlanningData::release_adc_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::localization::LocalizationEstimate* released = _impl_.adc_position_;
  _impl_.adc_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::localization::LocalizationEstimate* PlanningData::unsafe_arena_release_adc_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.adc_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::localization::LocalizationEstimate* temp = _impl_.adc_position_;
  _impl_.adc_position_ = nullptr;
  return temp;
}
inline ::control::localization::LocalizationEstimate* PlanningData::_internal_mutable_adc_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.adc_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::localization::LocalizationEstimate>(GetArena());
    _impl_.adc_position_ = reinterpret_cast<::control::localization::LocalizationEstimate*>(p);
  }
  return _impl_.adc_position_;
}
inline ::control::localization::LocalizationEstimate* PlanningData::mutable_adc_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::localization::LocalizationEstimate* _msg = _internal_mutable_adc_position();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.adc_position)
  return _msg;
}
inline void PlanningData::set_allocated_adc_position(::control::localization::LocalizationEstimate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.adc_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.adc_position_ = reinterpret_cast<::control::localization::LocalizationEstimate*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.adc_position)
}

// optional .control.canbus.Chassis chassis = 8;
inline bool PlanningData::has_chassis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chassis_ != nullptr);
  return value;
}
inline const ::control::canbus::Chassis& PlanningData::_internal_chassis() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::canbus::Chassis* p = _impl_.chassis_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::canbus::Chassis&>(::control::canbus::_Chassis_default_instance_);
}
inline const ::control::canbus::Chassis& PlanningData::chassis() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.chassis)
  return _internal_chassis();
}
inline void PlanningData::unsafe_arena_set_allocated_chassis(::control::canbus::Chassis* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chassis_);
  }
  _impl_.chassis_ = reinterpret_cast<::control::canbus::Chassis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.chassis)
}
inline ::control::canbus::Chassis* PlanningData::release_chassis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::canbus::Chassis* released = _impl_.chassis_;
  _impl_.chassis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::canbus::Chassis* PlanningData::unsafe_arena_release_chassis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.chassis)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::canbus::Chassis* temp = _impl_.chassis_;
  _impl_.chassis_ = nullptr;
  return temp;
}
inline ::control::canbus::Chassis* PlanningData::_internal_mutable_chassis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chassis_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::canbus::Chassis>(GetArena());
    _impl_.chassis_ = reinterpret_cast<::control::canbus::Chassis*>(p);
  }
  return _impl_.chassis_;
}
inline ::control::canbus::Chassis* PlanningData::mutable_chassis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::canbus::Chassis* _msg = _internal_mutable_chassis();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.chassis)
  return _msg;
}
inline void PlanningData::set_allocated_chassis(::control::canbus::Chassis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chassis_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.chassis_ = reinterpret_cast<::control::canbus::Chassis*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.chassis)
}

// optional .control.common.TrajectoryPoint init_point = 10;
inline bool PlanningData::has_init_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.init_point_ != nullptr);
  return value;
}
inline const ::control::common::TrajectoryPoint& PlanningData::_internal_init_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::TrajectoryPoint* p = _impl_.init_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::TrajectoryPoint&>(::control::common::_TrajectoryPoint_default_instance_);
}
inline const ::control::common::TrajectoryPoint& PlanningData::init_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.init_point)
  return _internal_init_point();
}
inline void PlanningData::unsafe_arena_set_allocated_init_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.init_point_);
  }
  _impl_.init_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.init_point)
}
inline ::control::common::TrajectoryPoint* PlanningData::release_init_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::common::TrajectoryPoint* released = _impl_.init_point_;
  _impl_.init_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::TrajectoryPoint* PlanningData::unsafe_arena_release_init_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.init_point)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::control::common::TrajectoryPoint* temp = _impl_.init_point_;
  _impl_.init_point_ = nullptr;
  return temp;
}
inline ::control::common::TrajectoryPoint* PlanningData::_internal_mutable_init_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.init_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::TrajectoryPoint>(GetArena());
    _impl_.init_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(p);
  }
  return _impl_.init_point_;
}
inline ::control::common::TrajectoryPoint* PlanningData::mutable_init_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::control::common::TrajectoryPoint* _msg = _internal_mutable_init_point();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.init_point)
  return _msg;
}
inline void PlanningData::set_allocated_init_point(::control::common::TrajectoryPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.init_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.init_point_ = reinterpret_cast<::control::common::TrajectoryPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.init_point)
}

// repeated .control.common.Path path = 6;
inline int PlanningData::_internal_path_size() const {
  return _internal_path().size();
}
inline int PlanningData::path_size() const {
  return _internal_path_size();
}
inline ::control::common::Path* PlanningData::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::Path>* PlanningData::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.PlanningData.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::control::common::Path& PlanningData::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.path)
  return _internal_path().Get(index);
}
inline ::control::common::Path* PlanningData::add_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::Path* _add = _internal_mutable_path()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.PlanningData.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::Path>& PlanningData::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.PlanningData.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::Path>&
PlanningData::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::Path>*
PlanningData::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// repeated .control.planning_internal.SpeedPlan speed_plan = 13;
inline int PlanningData::_internal_speed_plan_size() const {
  return _internal_speed_plan().size();
}
inline int PlanningData::speed_plan_size() const {
  return _internal_speed_plan_size();
}
inline void PlanningData::clear_speed_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_plan_.Clear();
}
inline ::control::planning_internal::SpeedPlan* PlanningData::mutable_speed_plan(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.speed_plan)
  return _internal_mutable_speed_plan()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>* PlanningData::mutable_speed_plan()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.PlanningData.speed_plan)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_speed_plan();
}
inline const ::control::planning_internal::SpeedPlan& PlanningData::speed_plan(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.speed_plan)
  return _internal_speed_plan().Get(index);
}
inline ::control::planning_internal::SpeedPlan* PlanningData::add_speed_plan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::SpeedPlan* _add = _internal_mutable_speed_plan()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.PlanningData.speed_plan)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>& PlanningData::speed_plan() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.PlanningData.speed_plan)
  return _internal_speed_plan();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>&
PlanningData::_internal_speed_plan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_plan_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::SpeedPlan>*
PlanningData::_internal_mutable_speed_plan() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.speed_plan_;
}

// repeated .control.planning_internal.STGraphDebug st_graph = 14;
inline int PlanningData::_internal_st_graph_size() const {
  return _internal_st_graph().size();
}
inline int PlanningData::st_graph_size() const {
  return _internal_st_graph_size();
}
inline void PlanningData::clear_st_graph() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.st_graph_.Clear();
}
inline ::control::planning_internal::STGraphDebug* PlanningData::mutable_st_graph(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.st_graph)
  return _internal_mutable_st_graph()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>* PlanningData::mutable_st_graph()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.PlanningData.st_graph)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_st_graph();
}
inline const ::control::planning_internal::STGraphDebug& PlanningData::st_graph(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.st_graph)
  return _internal_st_graph().Get(index);
}
inline ::control::planning_internal::STGraphDebug* PlanningData::add_st_graph() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::STGraphDebug* _add = _internal_mutable_st_graph()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.PlanningData.st_graph)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>& PlanningData::st_graph() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.PlanningData.st_graph)
  return _internal_st_graph();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>&
PlanningData::_internal_st_graph() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.st_graph_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::STGraphDebug>*
PlanningData::_internal_mutable_st_graph() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.st_graph_;
}

// repeated .control.planning_internal.SLFrameDebug sl_frame = 15;
inline int PlanningData::_internal_sl_frame_size() const {
  return _internal_sl_frame().size();
}
inline int PlanningData::sl_frame_size() const {
  return _internal_sl_frame_size();
}
inline void PlanningData::clear_sl_frame() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sl_frame_.Clear();
}
inline ::control::planning_internal::SLFrameDebug* PlanningData::mutable_sl_frame(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.sl_frame)
  return _internal_mutable_sl_frame()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>* PlanningData::mutable_sl_frame()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.PlanningData.sl_frame)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sl_frame();
}
inline const ::control::planning_internal::SLFrameDebug& PlanningData::sl_frame(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.sl_frame)
  return _internal_sl_frame().Get(index);
}
inline ::control::planning_internal::SLFrameDebug* PlanningData::add_sl_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::SLFrameDebug* _add = _internal_mutable_sl_frame()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.PlanningData.sl_frame)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>& PlanningData::sl_frame() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.PlanningData.sl_frame)
  return _internal_sl_frame();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>&
PlanningData::_internal_sl_frame() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sl_frame_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::SLFrameDebug>*
PlanningData::_internal_mutable_sl_frame() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sl_frame_;
}

// optional .control.common.Header prediction_header = 16;
inline bool PlanningData::has_prediction_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prediction_header_ != nullptr);
  return value;
}
inline const ::control::common::Header& PlanningData::_internal_prediction_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::Header* p = _impl_.prediction_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::Header&>(::control::common::_Header_default_instance_);
}
inline const ::control::common::Header& PlanningData::prediction_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.prediction_header)
  return _internal_prediction_header();
}
inline void PlanningData::unsafe_arena_set_allocated_prediction_header(::control::common::Header* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prediction_header_);
  }
  _impl_.prediction_header_ = reinterpret_cast<::control::common::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.prediction_header)
}
inline ::control::common::Header* PlanningData::release_prediction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::control::common::Header* released = _impl_.prediction_header_;
  _impl_.prediction_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::Header* PlanningData::unsafe_arena_release_prediction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.prediction_header)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::control::common::Header* temp = _impl_.prediction_header_;
  _impl_.prediction_header_ = nullptr;
  return temp;
}
inline ::control::common::Header* PlanningData::_internal_mutable_prediction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.prediction_header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::Header>(GetArena());
    _impl_.prediction_header_ = reinterpret_cast<::control::common::Header*>(p);
  }
  return _impl_.prediction_header_;
}
inline ::control::common::Header* PlanningData::mutable_prediction_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::control::common::Header* _msg = _internal_mutable_prediction_header();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.prediction_header)
  return _msg;
}
inline void PlanningData::set_allocated_prediction_header(::control::common::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prediction_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.prediction_header_ = reinterpret_cast<::control::common::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.prediction_header)
}

// repeated .control.planning_internal.ObstacleDebug obstacle = 18;
inline int PlanningData::_internal_obstacle_size() const {
  return _internal_obstacle().size();
}
inline int PlanningData::obstacle_size() const {
  return _internal_obstacle_size();
}
inline void PlanningData::clear_obstacle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.obstacle_.Clear();
}
inline ::control::planning_internal::ObstacleDebug* PlanningData::mutable_obstacle(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.obstacle)
  return _internal_mutable_obstacle()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>* PlanningData::mutable_obstacle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.PlanningData.obstacle)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_obstacle();
}
inline const ::control::planning_internal::ObstacleDebug& PlanningData::obstacle(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.obstacle)
  return _internal_obstacle().Get(index);
}
inline ::control::planning_internal::ObstacleDebug* PlanningData::add_obstacle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::ObstacleDebug* _add = _internal_mutable_obstacle()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.PlanningData.obstacle)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>& PlanningData::obstacle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.PlanningData.obstacle)
  return _internal_obstacle();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>&
PlanningData::_internal_obstacle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.obstacle_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::ObstacleDebug>*
PlanningData::_internal_mutable_obstacle() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.obstacle_;
}

// repeated .control.planning_internal.ReferenceLineDebug reference_line = 19;
inline int PlanningData::_internal_reference_line_size() const {
  return _internal_reference_line().size();
}
inline int PlanningData::reference_line_size() const {
  return _internal_reference_line_size();
}
inline void PlanningData::clear_reference_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reference_line_.Clear();
}
inline ::control::planning_internal::ReferenceLineDebug* PlanningData::mutable_reference_line(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.reference_line)
  return _internal_mutable_reference_line()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>* PlanningData::mutable_reference_line()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.PlanningData.reference_line)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_reference_line();
}
inline const ::control::planning_internal::ReferenceLineDebug& PlanningData::reference_line(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.reference_line)
  return _internal_reference_line().Get(index);
}
inline ::control::planning_internal::ReferenceLineDebug* PlanningData::add_reference_line() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::ReferenceLineDebug* _add = _internal_mutable_reference_line()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.PlanningData.reference_line)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>& PlanningData::reference_line() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.PlanningData.reference_line)
  return _internal_reference_line();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>&
PlanningData::_internal_reference_line() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reference_line_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::ReferenceLineDebug>*
PlanningData::_internal_mutable_reference_line() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.reference_line_;
}

// optional .control.planning_internal.DpPolyGraphDebug dp_poly_graph = 20;
inline bool PlanningData::has_dp_poly_graph() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dp_poly_graph_ != nullptr);
  return value;
}
inline void PlanningData::clear_dp_poly_graph() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dp_poly_graph_ != nullptr) _impl_.dp_poly_graph_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::control::planning_internal::DpPolyGraphDebug& PlanningData::_internal_dp_poly_graph() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::DpPolyGraphDebug* p = _impl_.dp_poly_graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::DpPolyGraphDebug&>(::control::planning_internal::_DpPolyGraphDebug_default_instance_);
}
inline const ::control::planning_internal::DpPolyGraphDebug& PlanningData::dp_poly_graph() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.dp_poly_graph)
  return _internal_dp_poly_graph();
}
inline void PlanningData::unsafe_arena_set_allocated_dp_poly_graph(::control::planning_internal::DpPolyGraphDebug* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dp_poly_graph_);
  }
  _impl_.dp_poly_graph_ = reinterpret_cast<::control::planning_internal::DpPolyGraphDebug*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.dp_poly_graph)
}
inline ::control::planning_internal::DpPolyGraphDebug* PlanningData::release_dp_poly_graph() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::control::planning_internal::DpPolyGraphDebug* released = _impl_.dp_poly_graph_;
  _impl_.dp_poly_graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::DpPolyGraphDebug* PlanningData::unsafe_arena_release_dp_poly_graph() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.dp_poly_graph)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::control::planning_internal::DpPolyGraphDebug* temp = _impl_.dp_poly_graph_;
  _impl_.dp_poly_graph_ = nullptr;
  return temp;
}
inline ::control::planning_internal::DpPolyGraphDebug* PlanningData::_internal_mutable_dp_poly_graph() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dp_poly_graph_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::DpPolyGraphDebug>(GetArena());
    _impl_.dp_poly_graph_ = reinterpret_cast<::control::planning_internal::DpPolyGraphDebug*>(p);
  }
  return _impl_.dp_poly_graph_;
}
inline ::control::planning_internal::DpPolyGraphDebug* PlanningData::mutable_dp_poly_graph() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::control::planning_internal::DpPolyGraphDebug* _msg = _internal_mutable_dp_poly_graph();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.dp_poly_graph)
  return _msg;
}
inline void PlanningData::set_allocated_dp_poly_graph(::control::planning_internal::DpPolyGraphDebug* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dp_poly_graph_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.dp_poly_graph_ = reinterpret_cast<::control::planning_internal::DpPolyGraphDebug*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.dp_poly_graph)
}

// optional .control.planning_internal.LatticeStTraining lattice_st_image = 21;
inline bool PlanningData::has_lattice_st_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lattice_st_image_ != nullptr);
  return value;
}
inline void PlanningData::clear_lattice_st_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lattice_st_image_ != nullptr) _impl_.lattice_st_image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::control::planning_internal::LatticeStTraining& PlanningData::_internal_lattice_st_image() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::LatticeStTraining* p = _impl_.lattice_st_image_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::LatticeStTraining&>(::control::planning_internal::_LatticeStTraining_default_instance_);
}
inline const ::control::planning_internal::LatticeStTraining& PlanningData::lattice_st_image() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.lattice_st_image)
  return _internal_lattice_st_image();
}
inline void PlanningData::unsafe_arena_set_allocated_lattice_st_image(::control::planning_internal::LatticeStTraining* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lattice_st_image_);
  }
  _impl_.lattice_st_image_ = reinterpret_cast<::control::planning_internal::LatticeStTraining*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.lattice_st_image)
}
inline ::control::planning_internal::LatticeStTraining* PlanningData::release_lattice_st_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::control::planning_internal::LatticeStTraining* released = _impl_.lattice_st_image_;
  _impl_.lattice_st_image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::LatticeStTraining* PlanningData::unsafe_arena_release_lattice_st_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.lattice_st_image)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::control::planning_internal::LatticeStTraining* temp = _impl_.lattice_st_image_;
  _impl_.lattice_st_image_ = nullptr;
  return temp;
}
inline ::control::planning_internal::LatticeStTraining* PlanningData::_internal_mutable_lattice_st_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lattice_st_image_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::LatticeStTraining>(GetArena());
    _impl_.lattice_st_image_ = reinterpret_cast<::control::planning_internal::LatticeStTraining*>(p);
  }
  return _impl_.lattice_st_image_;
}
inline ::control::planning_internal::LatticeStTraining* PlanningData::mutable_lattice_st_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::control::planning_internal::LatticeStTraining* _msg = _internal_mutable_lattice_st_image();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.lattice_st_image)
  return _msg;
}
inline void PlanningData::set_allocated_lattice_st_image(::control::planning_internal::LatticeStTraining* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lattice_st_image_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.lattice_st_image_ = reinterpret_cast<::control::planning_internal::LatticeStTraining*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.lattice_st_image)
}

// optional .control.planning_internal.AutoTuningTrainingData auto_tuning_training_data = 23;
inline bool PlanningData::has_auto_tuning_training_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_tuning_training_data_ != nullptr);
  return value;
}
inline void PlanningData::clear_auto_tuning_training_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.auto_tuning_training_data_ != nullptr) _impl_.auto_tuning_training_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::control::planning_internal::AutoTuningTrainingData& PlanningData::_internal_auto_tuning_training_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::AutoTuningTrainingData* p = _impl_.auto_tuning_training_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::AutoTuningTrainingData&>(::control::planning_internal::_AutoTuningTrainingData_default_instance_);
}
inline const ::control::planning_internal::AutoTuningTrainingData& PlanningData::auto_tuning_training_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.auto_tuning_training_data)
  return _internal_auto_tuning_training_data();
}
inline void PlanningData::unsafe_arena_set_allocated_auto_tuning_training_data(::control::planning_internal::AutoTuningTrainingData* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.auto_tuning_training_data_);
  }
  _impl_.auto_tuning_training_data_ = reinterpret_cast<::control::planning_internal::AutoTuningTrainingData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.auto_tuning_training_data)
}
inline ::control::planning_internal::AutoTuningTrainingData* PlanningData::release_auto_tuning_training_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::control::planning_internal::AutoTuningTrainingData* released = _impl_.auto_tuning_training_data_;
  _impl_.auto_tuning_training_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::AutoTuningTrainingData* PlanningData::unsafe_arena_release_auto_tuning_training_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.auto_tuning_training_data)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::control::planning_internal::AutoTuningTrainingData* temp = _impl_.auto_tuning_training_data_;
  _impl_.auto_tuning_training_data_ = nullptr;
  return temp;
}
inline ::control::planning_internal::AutoTuningTrainingData* PlanningData::_internal_mutable_auto_tuning_training_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.auto_tuning_training_data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::AutoTuningTrainingData>(GetArena());
    _impl_.auto_tuning_training_data_ = reinterpret_cast<::control::planning_internal::AutoTuningTrainingData*>(p);
  }
  return _impl_.auto_tuning_training_data_;
}
inline ::control::planning_internal::AutoTuningTrainingData* PlanningData::mutable_auto_tuning_training_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::control::planning_internal::AutoTuningTrainingData* _msg = _internal_mutable_auto_tuning_training_data();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.auto_tuning_training_data)
  return _msg;
}
inline void PlanningData::set_allocated_auto_tuning_training_data(::control::planning_internal::AutoTuningTrainingData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.auto_tuning_training_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.auto_tuning_training_data_ = reinterpret_cast<::control::planning_internal::AutoTuningTrainingData*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.auto_tuning_training_data)
}

// optional double front_clear_distance = 24;
inline bool PlanningData::has_front_clear_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void PlanningData::clear_front_clear_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.front_clear_distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline double PlanningData::front_clear_distance() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.front_clear_distance)
  return _internal_front_clear_distance();
}
inline void PlanningData::set_front_clear_distance(double value) {
  _internal_set_front_clear_distance(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:control.planning_internal.PlanningData.front_clear_distance)
}
inline double PlanningData::_internal_front_clear_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.front_clear_distance_;
}
inline void PlanningData::_internal_set_front_clear_distance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.front_clear_distance_ = value;
}

// optional .control.planning_internal.ScenarioDebug scenario = 26;
inline bool PlanningData::has_scenario() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scenario_ != nullptr);
  return value;
}
inline void PlanningData::clear_scenario() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scenario_ != nullptr) _impl_.scenario_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::control::planning_internal::ScenarioDebug& PlanningData::_internal_scenario() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::ScenarioDebug* p = _impl_.scenario_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::ScenarioDebug&>(::control::planning_internal::_ScenarioDebug_default_instance_);
}
inline const ::control::planning_internal::ScenarioDebug& PlanningData::scenario() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.scenario)
  return _internal_scenario();
}
inline void PlanningData::unsafe_arena_set_allocated_scenario(::control::planning_internal::ScenarioDebug* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scenario_);
  }
  _impl_.scenario_ = reinterpret_cast<::control::planning_internal::ScenarioDebug*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.scenario)
}
inline ::control::planning_internal::ScenarioDebug* PlanningData::release_scenario() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::control::planning_internal::ScenarioDebug* released = _impl_.scenario_;
  _impl_.scenario_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::ScenarioDebug* PlanningData::unsafe_arena_release_scenario() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.scenario)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::control::planning_internal::ScenarioDebug* temp = _impl_.scenario_;
  _impl_.scenario_ = nullptr;
  return temp;
}
inline ::control::planning_internal::ScenarioDebug* PlanningData::_internal_mutable_scenario() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scenario_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::ScenarioDebug>(GetArena());
    _impl_.scenario_ = reinterpret_cast<::control::planning_internal::ScenarioDebug*>(p);
  }
  return _impl_.scenario_;
}
inline ::control::planning_internal::ScenarioDebug* PlanningData::mutable_scenario() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::control::planning_internal::ScenarioDebug* _msg = _internal_mutable_scenario();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.scenario)
  return _msg;
}
inline void PlanningData::set_allocated_scenario(::control::planning_internal::ScenarioDebug* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.scenario_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.scenario_ = reinterpret_cast<::control::planning_internal::ScenarioDebug*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.scenario)
}

// optional .control.planning_internal.OpenSpaceDebug open_space = 27;
inline bool PlanningData::has_open_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.open_space_ != nullptr);
  return value;
}
inline void PlanningData::clear_open_space() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.open_space_ != nullptr) _impl_.open_space_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::control::planning_internal::OpenSpaceDebug& PlanningData::_internal_open_space() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::OpenSpaceDebug* p = _impl_.open_space_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::OpenSpaceDebug&>(::control::planning_internal::_OpenSpaceDebug_default_instance_);
}
inline const ::control::planning_internal::OpenSpaceDebug& PlanningData::open_space() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.open_space)
  return _internal_open_space();
}
inline void PlanningData::unsafe_arena_set_allocated_open_space(::control::planning_internal::OpenSpaceDebug* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.open_space_);
  }
  _impl_.open_space_ = reinterpret_cast<::control::planning_internal::OpenSpaceDebug*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.open_space)
}
inline ::control::planning_internal::OpenSpaceDebug* PlanningData::release_open_space() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::control::planning_internal::OpenSpaceDebug* released = _impl_.open_space_;
  _impl_.open_space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::OpenSpaceDebug* PlanningData::unsafe_arena_release_open_space() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.open_space)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::control::planning_internal::OpenSpaceDebug* temp = _impl_.open_space_;
  _impl_.open_space_ = nullptr;
  return temp;
}
inline ::control::planning_internal::OpenSpaceDebug* PlanningData::_internal_mutable_open_space() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.open_space_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::OpenSpaceDebug>(GetArena());
    _impl_.open_space_ = reinterpret_cast<::control::planning_internal::OpenSpaceDebug*>(p);
  }
  return _impl_.open_space_;
}
inline ::control::planning_internal::OpenSpaceDebug* PlanningData::mutable_open_space() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::control::planning_internal::OpenSpaceDebug* _msg = _internal_mutable_open_space();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.open_space)
  return _msg;
}
inline void PlanningData::set_allocated_open_space(::control::planning_internal::OpenSpaceDebug* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.open_space_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.open_space_ = reinterpret_cast<::control::planning_internal::OpenSpaceDebug*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.open_space)
}

// optional .control.planning_internal.SmootherDebug smoother = 28;
inline bool PlanningData::has_smoother() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.smoother_ != nullptr);
  return value;
}
inline void PlanningData::clear_smoother() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.smoother_ != nullptr) _impl_.smoother_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::control::planning_internal::SmootherDebug& PlanningData::_internal_smoother() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::SmootherDebug* p = _impl_.smoother_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::SmootherDebug&>(::control::planning_internal::_SmootherDebug_default_instance_);
}
inline const ::control::planning_internal::SmootherDebug& PlanningData::smoother() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.smoother)
  return _internal_smoother();
}
inline void PlanningData::unsafe_arena_set_allocated_smoother(::control::planning_internal::SmootherDebug* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.smoother_);
  }
  _impl_.smoother_ = reinterpret_cast<::control::planning_internal::SmootherDebug*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.smoother)
}
inline ::control::planning_internal::SmootherDebug* PlanningData::release_smoother() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::control::planning_internal::SmootherDebug* released = _impl_.smoother_;
  _impl_.smoother_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::SmootherDebug* PlanningData::unsafe_arena_release_smoother() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.smoother)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::control::planning_internal::SmootherDebug* temp = _impl_.smoother_;
  _impl_.smoother_ = nullptr;
  return temp;
}
inline ::control::planning_internal::SmootherDebug* PlanningData::_internal_mutable_smoother() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.smoother_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::SmootherDebug>(GetArena());
    _impl_.smoother_ = reinterpret_cast<::control::planning_internal::SmootherDebug*>(p);
  }
  return _impl_.smoother_;
}
inline ::control::planning_internal::SmootherDebug* PlanningData::mutable_smoother() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::control::planning_internal::SmootherDebug* _msg = _internal_mutable_smoother();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.smoother)
  return _msg;
}
inline void PlanningData::set_allocated_smoother(::control::planning_internal::SmootherDebug* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.smoother_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.smoother_ = reinterpret_cast<::control::planning_internal::SmootherDebug*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.smoother)
}

// optional .control.planning_internal.PullOverDebug pull_over = 29;
inline bool PlanningData::has_pull_over() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pull_over_ != nullptr);
  return value;
}
inline void PlanningData::clear_pull_over() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pull_over_ != nullptr) _impl_.pull_over_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::control::planning_internal::PullOverDebug& PlanningData::_internal_pull_over() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::PullOverDebug* p = _impl_.pull_over_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::PullOverDebug&>(::control::planning_internal::_PullOverDebug_default_instance_);
}
inline const ::control::planning_internal::PullOverDebug& PlanningData::pull_over() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.pull_over)
  return _internal_pull_over();
}
inline void PlanningData::unsafe_arena_set_allocated_pull_over(::control::planning_internal::PullOverDebug* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pull_over_);
  }
  _impl_.pull_over_ = reinterpret_cast<::control::planning_internal::PullOverDebug*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.pull_over)
}
inline ::control::planning_internal::PullOverDebug* PlanningData::release_pull_over() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::control::planning_internal::PullOverDebug* released = _impl_.pull_over_;
  _impl_.pull_over_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::PullOverDebug* PlanningData::unsafe_arena_release_pull_over() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.pull_over)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::control::planning_internal::PullOverDebug* temp = _impl_.pull_over_;
  _impl_.pull_over_ = nullptr;
  return temp;
}
inline ::control::planning_internal::PullOverDebug* PlanningData::_internal_mutable_pull_over() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pull_over_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::PullOverDebug>(GetArena());
    _impl_.pull_over_ = reinterpret_cast<::control::planning_internal::PullOverDebug*>(p);
  }
  return _impl_.pull_over_;
}
inline ::control::planning_internal::PullOverDebug* PlanningData::mutable_pull_over() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::control::planning_internal::PullOverDebug* _msg = _internal_mutable_pull_over();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.pull_over)
  return _msg;
}
inline void PlanningData::set_allocated_pull_over(::control::planning_internal::PullOverDebug* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pull_over_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.pull_over_ = reinterpret_cast<::control::planning_internal::PullOverDebug*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.pull_over)
}

// optional .control.planning_internal.HybridModelDebug hybrid_model = 30;
inline bool PlanningData::has_hybrid_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hybrid_model_ != nullptr);
  return value;
}
inline void PlanningData::clear_hybrid_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hybrid_model_ != nullptr) _impl_.hybrid_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::control::planning_internal::HybridModelDebug& PlanningData::_internal_hybrid_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::HybridModelDebug* p = _impl_.hybrid_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::HybridModelDebug&>(::control::planning_internal::_HybridModelDebug_default_instance_);
}
inline const ::control::planning_internal::HybridModelDebug& PlanningData::hybrid_model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.PlanningData.hybrid_model)
  return _internal_hybrid_model();
}
inline void PlanningData::unsafe_arena_set_allocated_hybrid_model(::control::planning_internal::HybridModelDebug* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hybrid_model_);
  }
  _impl_.hybrid_model_ = reinterpret_cast<::control::planning_internal::HybridModelDebug*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.PlanningData.hybrid_model)
}
inline ::control::planning_internal::HybridModelDebug* PlanningData::release_hybrid_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::control::planning_internal::HybridModelDebug* released = _impl_.hybrid_model_;
  _impl_.hybrid_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::HybridModelDebug* PlanningData::unsafe_arena_release_hybrid_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.PlanningData.hybrid_model)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::control::planning_internal::HybridModelDebug* temp = _impl_.hybrid_model_;
  _impl_.hybrid_model_ = nullptr;
  return temp;
}
inline ::control::planning_internal::HybridModelDebug* PlanningData::_internal_mutable_hybrid_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hybrid_model_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::HybridModelDebug>(GetArena());
    _impl_.hybrid_model_ = reinterpret_cast<::control::planning_internal::HybridModelDebug*>(p);
  }
  return _impl_.hybrid_model_;
}
inline ::control::planning_internal::HybridModelDebug* PlanningData::mutable_hybrid_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::control::planning_internal::HybridModelDebug* _msg = _internal_mutable_hybrid_model();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.PlanningData.hybrid_model)
  return _msg;
}
inline void PlanningData::set_allocated_hybrid_model(::control::planning_internal::HybridModelDebug* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hybrid_model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.hybrid_model_ = reinterpret_cast<::control::planning_internal::HybridModelDebug*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.PlanningData.hybrid_model)
}

// -------------------------------------------------------------------

// LatticeStPixel

// optional int32 s = 1;
inline bool LatticeStPixel::has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LatticeStPixel::clear_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t LatticeStPixel::s() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStPixel.s)
  return _internal_s();
}
inline void LatticeStPixel::set_s(::int32_t value) {
  _internal_set_s(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStPixel.s)
}
inline ::int32_t LatticeStPixel::_internal_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s_;
}
inline void LatticeStPixel::_internal_set_s(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s_ = value;
}

// optional int32 t = 2;
inline bool LatticeStPixel::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LatticeStPixel::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t LatticeStPixel::t() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStPixel.t)
  return _internal_t();
}
inline void LatticeStPixel::set_t(::int32_t value) {
  _internal_set_t(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStPixel.t)
}
inline ::int32_t LatticeStPixel::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline void LatticeStPixel::_internal_set_t(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = value;
}

// optional uint32 r = 3;
inline bool LatticeStPixel::has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LatticeStPixel::clear_r() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.r_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t LatticeStPixel::r() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStPixel.r)
  return _internal_r();
}
inline void LatticeStPixel::set_r(::uint32_t value) {
  _internal_set_r(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStPixel.r)
}
inline ::uint32_t LatticeStPixel::_internal_r() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.r_;
}
inline void LatticeStPixel::_internal_set_r(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.r_ = value;
}

// optional uint32 g = 4;
inline bool LatticeStPixel::has_g() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LatticeStPixel::clear_g() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.g_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t LatticeStPixel::g() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStPixel.g)
  return _internal_g();
}
inline void LatticeStPixel::set_g(::uint32_t value) {
  _internal_set_g(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStPixel.g)
}
inline ::uint32_t LatticeStPixel::_internal_g() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.g_;
}
inline void LatticeStPixel::_internal_set_g(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.g_ = value;
}

// optional uint32 b = 5;
inline bool LatticeStPixel::has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void LatticeStPixel::clear_b() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.b_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t LatticeStPixel::b() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStPixel.b)
  return _internal_b();
}
inline void LatticeStPixel::set_b(::uint32_t value) {
  _internal_set_b(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStPixel.b)
}
inline ::uint32_t LatticeStPixel::_internal_b() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.b_;
}
inline void LatticeStPixel::_internal_set_b(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.b_ = value;
}

// -------------------------------------------------------------------

// LatticeStTraining

// repeated .control.planning_internal.LatticeStPixel pixel = 1;
inline int LatticeStTraining::_internal_pixel_size() const {
  return _internal_pixel().size();
}
inline int LatticeStTraining::pixel_size() const {
  return _internal_pixel_size();
}
inline void LatticeStTraining::clear_pixel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pixel_.Clear();
}
inline ::control::planning_internal::LatticeStPixel* LatticeStTraining::mutable_pixel(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.LatticeStTraining.pixel)
  return _internal_mutable_pixel()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>* LatticeStTraining::mutable_pixel()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.LatticeStTraining.pixel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pixel();
}
inline const ::control::planning_internal::LatticeStPixel& LatticeStTraining::pixel(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.pixel)
  return _internal_pixel().Get(index);
}
inline ::control::planning_internal::LatticeStPixel* LatticeStTraining::add_pixel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::planning_internal::LatticeStPixel* _add = _internal_mutable_pixel()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.LatticeStTraining.pixel)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>& LatticeStTraining::pixel() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.LatticeStTraining.pixel)
  return _internal_pixel();
}
inline const ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>&
LatticeStTraining::_internal_pixel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pixel_;
}
inline ::google::protobuf::RepeatedPtrField<::control::planning_internal::LatticeStPixel>*
LatticeStTraining::_internal_mutable_pixel() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pixel_;
}

// optional double timestamp = 2;
inline bool LatticeStTraining::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LatticeStTraining::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LatticeStTraining::timestamp() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.timestamp)
  return _internal_timestamp();
}
inline void LatticeStTraining::set_timestamp(double value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStTraining.timestamp)
}
inline double LatticeStTraining::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void LatticeStTraining::_internal_set_timestamp(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// optional string annotation = 3;
inline bool LatticeStTraining::has_annotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LatticeStTraining::clear_annotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.annotation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LatticeStTraining::annotation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.annotation)
  return _internal_annotation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LatticeStTraining::set_annotation(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.annotation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStTraining.annotation)
}
inline std::string* LatticeStTraining::mutable_annotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.LatticeStTraining.annotation)
  return _s;
}
inline const std::string& LatticeStTraining::_internal_annotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.annotation_.Get();
}
inline void LatticeStTraining::_internal_set_annotation(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.annotation_.Set(value, GetArena());
}
inline std::string* LatticeStTraining::_internal_mutable_annotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.annotation_.Mutable( GetArena());
}
inline std::string* LatticeStTraining::release_annotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.LatticeStTraining.annotation)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.annotation_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.annotation_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LatticeStTraining::set_allocated_annotation(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.annotation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.annotation_.IsDefault()) {
          _impl_.annotation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.LatticeStTraining.annotation)
}

// optional uint32 num_s_grids = 4;
inline bool LatticeStTraining::has_num_s_grids() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LatticeStTraining::clear_num_s_grids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_s_grids_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t LatticeStTraining::num_s_grids() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.num_s_grids)
  return _internal_num_s_grids();
}
inline void LatticeStTraining::set_num_s_grids(::uint32_t value) {
  _internal_set_num_s_grids(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStTraining.num_s_grids)
}
inline ::uint32_t LatticeStTraining::_internal_num_s_grids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_s_grids_;
}
inline void LatticeStTraining::_internal_set_num_s_grids(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_s_grids_ = value;
}

// optional uint32 num_t_grids = 5;
inline bool LatticeStTraining::has_num_t_grids() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LatticeStTraining::clear_num_t_grids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_t_grids_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t LatticeStTraining::num_t_grids() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.num_t_grids)
  return _internal_num_t_grids();
}
inline void LatticeStTraining::set_num_t_grids(::uint32_t value) {
  _internal_set_num_t_grids(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStTraining.num_t_grids)
}
inline ::uint32_t LatticeStTraining::_internal_num_t_grids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_t_grids_;
}
inline void LatticeStTraining::_internal_set_num_t_grids(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_t_grids_ = value;
}

// optional double s_resolution = 6;
inline bool LatticeStTraining::has_s_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void LatticeStTraining::clear_s_resolution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s_resolution_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double LatticeStTraining::s_resolution() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.s_resolution)
  return _internal_s_resolution();
}
inline void LatticeStTraining::set_s_resolution(double value) {
  _internal_set_s_resolution(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStTraining.s_resolution)
}
inline double LatticeStTraining::_internal_s_resolution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s_resolution_;
}
inline void LatticeStTraining::_internal_set_s_resolution(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s_resolution_ = value;
}

// optional double t_resolution = 7;
inline bool LatticeStTraining::has_t_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void LatticeStTraining::clear_t_resolution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_resolution_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LatticeStTraining::t_resolution() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.LatticeStTraining.t_resolution)
  return _internal_t_resolution();
}
inline void LatticeStTraining::set_t_resolution(double value) {
  _internal_set_t_resolution(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:control.planning_internal.LatticeStTraining.t_resolution)
}
inline double LatticeStTraining::_internal_t_resolution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_resolution_;
}
inline void LatticeStTraining::_internal_set_t_resolution(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_resolution_ = value;
}

// -------------------------------------------------------------------

// CostComponents

// repeated double cost_component = 1;
inline int CostComponents::_internal_cost_component_size() const {
  return _internal_cost_component().size();
}
inline int CostComponents::cost_component_size() const {
  return _internal_cost_component_size();
}
inline void CostComponents::clear_cost_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cost_component_.Clear();
}
inline double CostComponents::cost_component(int index) const {
  // @@protoc_insertion_point(field_get:control.planning_internal.CostComponents.cost_component)
  return _internal_cost_component().Get(index);
}
inline void CostComponents::set_cost_component(int index, double value) {
  _internal_mutable_cost_component()->Set(index, value);
  // @@protoc_insertion_point(field_set:control.planning_internal.CostComponents.cost_component)
}
inline void CostComponents::add_cost_component(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_cost_component()->Add(value);
  // @@protoc_insertion_point(field_add:control.planning_internal.CostComponents.cost_component)
}
inline const ::google::protobuf::RepeatedField<double>& CostComponents::cost_component() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.CostComponents.cost_component)
  return _internal_cost_component();
}
inline ::google::protobuf::RepeatedField<double>* CostComponents::mutable_cost_component()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.CostComponents.cost_component)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cost_component();
}
inline const ::google::protobuf::RepeatedField<double>&
CostComponents::_internal_cost_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cost_component_;
}
inline ::google::protobuf::RepeatedField<double>* CostComponents::_internal_mutable_cost_component() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cost_component_;
}

// -------------------------------------------------------------------

// AutoTuningTrainingData

// optional .control.planning_internal.CostComponents teacher_component = 1;
inline bool AutoTuningTrainingData::has_teacher_component() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.teacher_component_ != nullptr);
  return value;
}
inline void AutoTuningTrainingData::clear_teacher_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.teacher_component_ != nullptr) _impl_.teacher_component_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control::planning_internal::CostComponents& AutoTuningTrainingData::_internal_teacher_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::CostComponents* p = _impl_.teacher_component_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::CostComponents&>(::control::planning_internal::_CostComponents_default_instance_);
}
inline const ::control::planning_internal::CostComponents& AutoTuningTrainingData::teacher_component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.AutoTuningTrainingData.teacher_component)
  return _internal_teacher_component();
}
inline void AutoTuningTrainingData::unsafe_arena_set_allocated_teacher_component(::control::planning_internal::CostComponents* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.teacher_component_);
  }
  _impl_.teacher_component_ = reinterpret_cast<::control::planning_internal::CostComponents*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.AutoTuningTrainingData.teacher_component)
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::release_teacher_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning_internal::CostComponents* released = _impl_.teacher_component_;
  _impl_.teacher_component_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::unsafe_arena_release_teacher_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.AutoTuningTrainingData.teacher_component)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control::planning_internal::CostComponents* temp = _impl_.teacher_component_;
  _impl_.teacher_component_ = nullptr;
  return temp;
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::_internal_mutable_teacher_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.teacher_component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::CostComponents>(GetArena());
    _impl_.teacher_component_ = reinterpret_cast<::control::planning_internal::CostComponents*>(p);
  }
  return _impl_.teacher_component_;
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::mutable_teacher_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control::planning_internal::CostComponents* _msg = _internal_mutable_teacher_component();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.AutoTuningTrainingData.teacher_component)
  return _msg;
}
inline void AutoTuningTrainingData::set_allocated_teacher_component(::control::planning_internal::CostComponents* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.teacher_component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.teacher_component_ = reinterpret_cast<::control::planning_internal::CostComponents*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.AutoTuningTrainingData.teacher_component)
}

// optional .control.planning_internal.CostComponents student_component = 2;
inline bool AutoTuningTrainingData::has_student_component() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.student_component_ != nullptr);
  return value;
}
inline void AutoTuningTrainingData::clear_student_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.student_component_ != nullptr) _impl_.student_component_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::control::planning_internal::CostComponents& AutoTuningTrainingData::_internal_student_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::planning_internal::CostComponents* p = _impl_.student_component_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::planning_internal::CostComponents&>(::control::planning_internal::_CostComponents_default_instance_);
}
inline const ::control::planning_internal::CostComponents& AutoTuningTrainingData::student_component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.AutoTuningTrainingData.student_component)
  return _internal_student_component();
}
inline void AutoTuningTrainingData::unsafe_arena_set_allocated_student_component(::control::planning_internal::CostComponents* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.student_component_);
  }
  _impl_.student_component_ = reinterpret_cast<::control::planning_internal::CostComponents*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.AutoTuningTrainingData.student_component)
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::release_student_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning_internal::CostComponents* released = _impl_.student_component_;
  _impl_.student_component_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::unsafe_arena_release_student_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.AutoTuningTrainingData.student_component)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::planning_internal::CostComponents* temp = _impl_.student_component_;
  _impl_.student_component_ = nullptr;
  return temp;
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::_internal_mutable_student_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.student_component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::planning_internal::CostComponents>(GetArena());
    _impl_.student_component_ = reinterpret_cast<::control::planning_internal::CostComponents*>(p);
  }
  return _impl_.student_component_;
}
inline ::control::planning_internal::CostComponents* AutoTuningTrainingData::mutable_student_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::planning_internal::CostComponents* _msg = _internal_mutable_student_component();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.AutoTuningTrainingData.student_component)
  return _msg;
}
inline void AutoTuningTrainingData::set_allocated_student_component(::control::planning_internal::CostComponents* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.student_component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.student_component_ = reinterpret_cast<::control::planning_internal::CostComponents*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.AutoTuningTrainingData.student_component)
}

// -------------------------------------------------------------------

// CloudReferenceLineResponse

// repeated .control.common.Path segment = 1;
inline int CloudReferenceLineResponse::_internal_segment_size() const {
  return _internal_segment().size();
}
inline int CloudReferenceLineResponse::segment_size() const {
  return _internal_segment_size();
}
inline ::control::common::Path* CloudReferenceLineResponse::mutable_segment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:control.planning_internal.CloudReferenceLineResponse.segment)
  return _internal_mutable_segment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::control::common::Path>* CloudReferenceLineResponse::mutable_segment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:control.planning_internal.CloudReferenceLineResponse.segment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment();
}
inline const ::control::common::Path& CloudReferenceLineResponse::segment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.CloudReferenceLineResponse.segment)
  return _internal_segment().Get(index);
}
inline ::control::common::Path* CloudReferenceLineResponse::add_segment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::control::common::Path* _add = _internal_mutable_segment()->Add();
  // @@protoc_insertion_point(field_add:control.planning_internal.CloudReferenceLineResponse.segment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::Path>& CloudReferenceLineResponse::segment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:control.planning_internal.CloudReferenceLineResponse.segment)
  return _internal_segment();
}
inline const ::google::protobuf::RepeatedPtrField<::control::common::Path>&
CloudReferenceLineResponse::_internal_segment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_;
}
inline ::google::protobuf::RepeatedPtrField<::control::common::Path>*
CloudReferenceLineResponse::_internal_mutable_segment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_;
}

// -------------------------------------------------------------------

// HybridModelDebug

// optional bool using_learning_model_output = 1 [default = false];
inline bool HybridModelDebug::has_using_learning_model_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void HybridModelDebug::clear_using_learning_model_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using_learning_model_output_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool HybridModelDebug::using_learning_model_output() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.HybridModelDebug.using_learning_model_output)
  return _internal_using_learning_model_output();
}
inline void HybridModelDebug::set_using_learning_model_output(bool value) {
  _internal_set_using_learning_model_output(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:control.planning_internal.HybridModelDebug.using_learning_model_output)
}
inline bool HybridModelDebug::_internal_using_learning_model_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.using_learning_model_output_;
}
inline void HybridModelDebug::_internal_set_using_learning_model_output(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.using_learning_model_output_ = value;
}

// optional double learning_model_output_usage_ratio = 2;
inline bool HybridModelDebug::has_learning_model_output_usage_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HybridModelDebug::clear_learning_model_output_usage_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.learning_model_output_usage_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double HybridModelDebug::learning_model_output_usage_ratio() const {
  // @@protoc_insertion_point(field_get:control.planning_internal.HybridModelDebug.learning_model_output_usage_ratio)
  return _internal_learning_model_output_usage_ratio();
}
inline void HybridModelDebug::set_learning_model_output_usage_ratio(double value) {
  _internal_set_learning_model_output_usage_ratio(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:control.planning_internal.HybridModelDebug.learning_model_output_usage_ratio)
}
inline double HybridModelDebug::_internal_learning_model_output_usage_ratio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.learning_model_output_usage_ratio_;
}
inline void HybridModelDebug::_internal_set_learning_model_output_usage_ratio(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.learning_model_output_usage_ratio_ = value;
}

// optional string learning_model_output_fail_reason = 3;
inline bool HybridModelDebug::has_learning_model_output_fail_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HybridModelDebug::clear_learning_model_output_fail_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.learning_model_output_fail_reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HybridModelDebug::learning_model_output_fail_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.HybridModelDebug.learning_model_output_fail_reason)
  return _internal_learning_model_output_fail_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HybridModelDebug::set_learning_model_output_fail_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.learning_model_output_fail_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control.planning_internal.HybridModelDebug.learning_model_output_fail_reason)
}
inline std::string* HybridModelDebug::mutable_learning_model_output_fail_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_learning_model_output_fail_reason();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.HybridModelDebug.learning_model_output_fail_reason)
  return _s;
}
inline const std::string& HybridModelDebug::_internal_learning_model_output_fail_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.learning_model_output_fail_reason_.Get();
}
inline void HybridModelDebug::_internal_set_learning_model_output_fail_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.learning_model_output_fail_reason_.Set(value, GetArena());
}
inline std::string* HybridModelDebug::_internal_mutable_learning_model_output_fail_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.learning_model_output_fail_reason_.Mutable( GetArena());
}
inline std::string* HybridModelDebug::release_learning_model_output_fail_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.HybridModelDebug.learning_model_output_fail_reason)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.learning_model_output_fail_reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.learning_model_output_fail_reason_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void HybridModelDebug::set_allocated_learning_model_output_fail_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.learning_model_output_fail_reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.learning_model_output_fail_reason_.IsDefault()) {
          _impl_.learning_model_output_fail_reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.HybridModelDebug.learning_model_output_fail_reason)
}

// optional .control.common.Path evaluated_path_reference = 4;
inline bool HybridModelDebug::has_evaluated_path_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evaluated_path_reference_ != nullptr);
  return value;
}
inline const ::control::common::Path& HybridModelDebug::_internal_evaluated_path_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control::common::Path* p = _impl_.evaluated_path_reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::control::common::Path&>(::control::common::_Path_default_instance_);
}
inline const ::control::common::Path& HybridModelDebug::evaluated_path_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control.planning_internal.HybridModelDebug.evaluated_path_reference)
  return _internal_evaluated_path_reference();
}
inline void HybridModelDebug::unsafe_arena_set_allocated_evaluated_path_reference(::control::common::Path* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evaluated_path_reference_);
  }
  _impl_.evaluated_path_reference_ = reinterpret_cast<::control::common::Path*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control.planning_internal.HybridModelDebug.evaluated_path_reference)
}
inline ::control::common::Path* HybridModelDebug::release_evaluated_path_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::common::Path* released = _impl_.evaluated_path_reference_;
  _impl_.evaluated_path_reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control::common::Path* HybridModelDebug::unsafe_arena_release_evaluated_path_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control.planning_internal.HybridModelDebug.evaluated_path_reference)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::control::common::Path* temp = _impl_.evaluated_path_reference_;
  _impl_.evaluated_path_reference_ = nullptr;
  return temp;
}
inline ::control::common::Path* HybridModelDebug::_internal_mutable_evaluated_path_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evaluated_path_reference_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control::common::Path>(GetArena());
    _impl_.evaluated_path_reference_ = reinterpret_cast<::control::common::Path*>(p);
  }
  return _impl_.evaluated_path_reference_;
}
inline ::control::common::Path* HybridModelDebug::mutable_evaluated_path_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::control::common::Path* _msg = _internal_mutable_evaluated_path_reference();
  // @@protoc_insertion_point(field_mutable:control.planning_internal.HybridModelDebug.evaluated_path_reference)
  return _msg;
}
inline void HybridModelDebug::set_allocated_evaluated_path_reference(::control::common::Path* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evaluated_path_reference_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evaluated_path_reference_ = reinterpret_cast<::control::common::Path*>(value);
  // @@protoc_insertion_point(field_set_allocated:control.planning_internal.HybridModelDebug.evaluated_path_reference)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace planning_internal
}  // namespace control


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::control::planning_internal::StGraphBoundaryDebug_StBoundaryType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning_internal::StGraphBoundaryDebug_StBoundaryType>() {
  return ::control::planning_internal::StGraphBoundaryDebug_StBoundaryType_descriptor();
}
template <>
struct is_proto_enum<::control::planning_internal::SmootherDebug_SmootherType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control::planning_internal::SmootherDebug_SmootherType>() {
  return ::control::planning_internal::SmootherDebug_SmootherType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_planning_5fmsgs_2fplanning_5finternal_2eproto_2epb_2eh
